//
//  This file is part of a concatenation of the CwlViews framework with public
//  interfaces for exposing from libraries or use in Swift Playgrounds).
//  For details, visit: https://github.com/mattgallagher/CwlViews
//
//  Copyright © 2015-2018 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any
//  purpose with or without fee is hereby granted, provided that the above
//  copyright notice and this permission notice appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
//  This file was generated by the CwlConcat tool on 2018-10-25 10:50:35 +0000 from the following files:
//   CwlTableView.swift
//   CwlTextField.swift
//   CwlSwipeGestureRecognizer.swift
//   CwlSetOrAnimate.swift
//   CwlTapGestureRecognizer.swift
//   CwlBarItem.swift
//   CwlNavigationController.swift
//   CwlView.swift
//   CwlLabel.swift
//   CwlTableSection.swift
//   CwlNavigationItem.swift
//   CwlTabBar.swift
//   CwlApplication.swift
//   CwlTabBarController.swift
//   CwlImageView.swift
//   CwlAlertController.swift
//   CwlPageViewController.swift
//   CwlTableViewCell.swift
//   CwlTabBarItem.swift
//   CwlNavigationBar.swift
//   CwlLongPressGestureRecognizer.swift
//   CwlAlertAction.swift
//   CwlSlider.swift
//   CwlWindow.swift
//   CwlSwitch.swift
//   CwlPanGestureRecognizer.swift
//   CwlSplitViewController.swift
//   CwlTextView.swift
//   CwlPinchGestureRecognizer.swift
//   CwlScrollView.swift
//   CwlGestureRecognizer.swift
//   CwlControl.swift
//   CwlButton.swift
//   CwlTextInputTraits.swift
//   CwlViewController.swift
//   CwlSearchBar.swift
//   CwlScreenEdgePanGestureRecognizer.swift
//   CwlRotationGestureRecognizer.swift
//   CwlBarButtonItem.swift
//   CwlBackingLayer.swift
//   CwlGradientLayer.swift
//   CwlWebView.swift
//   CwlStackView.swift
//   CwlLayer.swift

import UIKit

public class TableView<RowData>: ConstructingBinder, TableViewConvertible {
	public typealias Instance = UITableView
	public typealias Inherited = ScrollView
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiTableView() -> Instance { return instance() }

	public enum Binding: TableViewBinding {
		public typealias RowDataType = RowData
		public typealias EnclosingBinder = TableView
		public static func tableViewBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case tableViewStyle(Constant<UITableView.Style>)

		//	1. Value bindings may be applied at construction and may subsequently change.
		case allowsMultipleSelection(Dynamic<Bool>)
		case allowsMultipleSelectionDuringEditing(Dynamic<Bool>)
		case allowsSelection(Dynamic<Bool>)
		case allowsSelectionDuringEditing(Dynamic<Bool>)
		case backgroundView(Dynamic<ViewConvertible?>)
		case cellLayoutMarginsFollowReadableWidth(Dynamic<Bool>)
		case isEditing(Signal<SetOrAnimate<Bool>>)
		case estimatedRowHeight(Dynamic<CGFloat>)
		case estimatedSectionFooterHeight(Dynamic<CGFloat>)
		case estimatedSectionHeaderHeight(Dynamic<CGFloat>)
		case remembersLastFocusedIndexPath(Dynamic<Bool>)
		case rowHeight(Dynamic<CGFloat>)
		case sectionFooterHeight(Dynamic<CGFloat>)
		case sectionHeaderHeight(Dynamic<CGFloat>)
		case sectionIndexBackgroundColor(Dynamic<UIColor?>)
		case sectionIndexColor(Dynamic<UIColor?>)
		case sectionIndexMinimumDisplayRowCount(Dynamic<Int>)
		case sectionIndexTrackingBackgroundColor(Dynamic<UIColor?>)
		case sectionIndexTitles(Dynamic<[String]?>)
		case separatorColor(Dynamic<UIColor?>)
		case separatorEffect(Dynamic<UIVisualEffect?>)
		case separatorInset(Dynamic<UIEdgeInsets>)
		case separatorStyle(Dynamic<UITableViewCell.SeparatorStyle>)
		case tableFooterView(Dynamic<ViewConvertible?>)
		case tableHeaderView(Dynamic<ViewConvertible?>)
		case tableData(Dynamic<TableData<RowData>>)
		
		//	2. Signal bindings are performed on the object after construction.
		case deselectRow(Signal<SetOrAnimate<IndexPath>>)
		case scrollToNearestSelectedRow(Signal<SetOrAnimate<UITableView.ScrollPosition>>)
		case scrollToRow(Signal<SetOrAnimate<TableScrollPosition>>)
		case selectRow(Signal<SetOrAnimate<TableScrollPosition?>>)
		
		//	3. Action bindings are triggered by the object after construction.
		case userDidScrollToRow(SignalInput<TableRow<RowData>>)
		case accessoryButtonTapped(SignalInput<TableRow<RowData>>)
		case didDeselectRow(SignalInput<TableRow<RowData>>)
		case didEndDisplayingFooter(SignalInput<Int>)
		case didEndDisplayingHeader(SignalInput<Int>)
		case didEndDisplayingRow(SignalInput<TableRow<RowData>>)
		case didEndEditingRow(SignalInput<TableRow<RowData>?>)
		case didHightlightRow(SignalInput<TableRow<RowData>>)
		case didSelectRow(SignalInput<TableRow<RowData>>)
		case didUnhighlightRow(SignalInput<TableRow<RowData>>)
		case moveRow(SignalInput<(from: TableRow<RowData>, to: IndexPath)>)
		case selectionDidChange(SignalInput<[TableRow<RowData>]?>)
		case visibleRowsChanged(SignalInput<[TableRow<RowData>]>)
		case commit(SignalInput<(editingStyle: UITableViewCell.EditingStyle, row: TableRow<RowData>)>)
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case cellIdentifier((TableRow<RowData>) -> String?)
		case canEditRow((_ tableRowData: TableRow<RowData>) -> Bool)
		case canFocusRow((_ tableRowData: TableRow<RowData>) -> Bool)
		case canMoveRow((_ tableRowData: TableRow<RowData>) -> Bool)
		case canPerformAction((_ action: Selector, _ tableRowData: TableRow<RowData>, _ sender: Any?) -> Bool)
		case cellConstructor((_ identifier: String?, _ rowSignal: SignalMulti<RowData>) -> TableViewCellConvertible)
		case dataMissingCell((IndexPath) -> TableViewCellConvertible)
		case didUpdateFocus((UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -> Void)
		case editActionsForRow((_ tableRowData: TableRow<RowData>) -> [UITableViewRowAction]?)
		case editingStyleForRow((_ tableRowData: TableRow<RowData>) -> UITableViewCell.EditingStyle)
		case estimatedHeightForFooter((_ section: Int) -> CGFloat)
		case estimatedHeightForHeader((_ section: Int) -> CGFloat)
		case estimatedHeightForRow((_ tableRowData: TableRow<RowData>) -> CGFloat)
		case footerHeight((_ section: Int) -> CGFloat)
		case footerView((_ section: Int, _ title: String?) -> ViewConvertible?)
		case headerHeight((_ section: Int) -> CGFloat)
		case headerView((_ section: Int, _ title: String?) -> ViewConvertible?)
		case heightForRow((_ tableRowData: TableRow<RowData>) -> CGFloat)
		case indentationLevelForRow((_ tableRowData: TableRow<RowData>) -> Int)
		case indexPathForPreferredFocusedView((UITableView) -> IndexPath)
		case shouldHighlightRow((_ tableRowData: TableRow<RowData>) -> Bool)
		case shouldIndentWhileEditingRow((_ tableRowData: TableRow<RowData>) -> Bool)
		case shouldShowMenuForRow((_ tableRowData: TableRow<RowData>) -> Bool)
		case shouldUpdateFocus((UITableView, UITableViewFocusUpdateContext) -> Bool)
		case targetIndexPathForMoveFromRow((_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -> IndexPath)
		case titleForDeleteConfirmationButtonForRow((_ tableRowData: TableRow<RowData>) -> String?)
		case willBeginEditingRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> Void)
		case willDeselectRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> IndexPath?)
		case willDisplayFooter((_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void)
		case willDisplayHeader((_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void)
		case willDisplayRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>, _ cell: UITableViewCell) -> Void)
		case willSelectRow((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> IndexPath?)
	}

	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = TableView
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage(cellIdentifier: cellIdentifier) }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance {
			return subclass.init(frame: CGRect.zero, style: tableViewStyle)
		}
		
		// Actual delegate construction is handled by the scroll view preparer
		public init() {
			self.init(delegateClass: Delegate.self)
		}
		public init(delegateClass: Delegate.Type) {
			linkedPreparer = Inherited.Preparer(delegateClass: delegateClass)
		}
		var possibleDelegate: Delegate? { return linkedPreparer.possibleDelegate as? Delegate }
		mutating func delegate() -> Delegate { return linkedPreparer.delegate() as! Delegate }
		
		var tableViewStyle: UITableView.Style = .plain
		var rowsChangedInput: SignalInput<[TableRow<RowData>]>? = nil
		var cellIdentifier: (TableRow<RowData>) -> String? = { _ in nil }
		
		public mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .cellIdentifier(let x): cellIdentifier = x
			case .tableViewStyle(let x): tableViewStyle = x.value
			case .userDidScrollToRow(let x):
				let s1 = #selector(UIScrollViewDelegate.scrollViewDidScrollToTop(_:))
				let s2 = #selector(UIScrollViewDelegate.scrollViewDidEndDragging(_:willDecelerate:))
				let s3 = #selector(UIScrollViewDelegate.scrollViewDidEndDecelerating(_:))
				delegate().addSelector(s1).userDidScrollToRow = x
				_ = delegate().addSelector(s2)
				_ = delegate().addSelector(s3)
			case .accessoryButtonTapped(let x):
				let s = #selector(UITableViewDelegate.tableView(_:accessoryButtonTappedForRowWith:))
				delegate().addSelector(s).accessoryButtonTapped = x
			case .canEditRow(let x):
				let s = #selector(UITableViewDataSource.tableView(_:canEditRowAt:))
				delegate().addSelector(s).canEditRow = x
			case .canFocusRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:canFocusRowAt:))
				delegate().addSelector(s).canFocusRow = x
			case .canMoveRow(let x):
				let s = #selector(UITableViewDataSource.tableView(_:canMoveRowAt:))
				delegate().addSelector(s).canMoveRow = x
			case .canPerformAction(let x):
				let s = #selector(UITableViewDelegate.tableView(_:canPerformAction:forRowAt:withSender:))
				delegate().addSelector(s).canPerformAction = x
			case .didDeselectRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:didDeselectRowAt:))
				delegate().addSelector(s).didDeselectRow = x
			case .didEndDisplayingFooter(let x):
				let s = #selector(UITableViewDelegate.tableView(_:didEndDisplayingFooterView:forSection:))
				delegate().addSelector(s).didEndDisplayingFooter = x
			case .didEndDisplayingHeader(let x):
				let s = #selector(UITableViewDelegate.tableView(_:didEndDisplayingHeaderView:forSection:))
				delegate().addSelector(s).didEndDisplayingHeader = x
			case .didEndDisplayingRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:didEndDisplaying:forRowAt:))
				delegate().addSelector(s).didEndDisplayingRow = x
			case .didEndEditingRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:didEndEditingRowAt:))
				delegate().addSelector(s).didEndEditingRow = x
			case .didHightlightRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:didHighlightRowAt:))
				delegate().addSelector(s).didHightlightRow = x
			case .commit(let x):
				let s = #selector(UITableViewDataSource.tableView(_:commit:forRowAt:))
				delegate().addSelector(s).commit = x
			case .didSelectRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:didSelectRowAt:))
				delegate().addSelector(s).didSelectRow = x
			case .didUnhighlightRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:didUnhighlightRowAt:))
				delegate().addSelector(s).didUnhighlightRow = x
			case .didUpdateFocus(let x):
				let s = #selector(UITableViewDelegate.tableView(_:didUpdateFocusIn:with:))
				delegate().addSelector(s).didUpdateFocus = x
			case .editActionsForRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:editActionsForRowAt:))
				delegate().addSelector(s).editActionsForRow = x
			case .editingStyleForRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:editingStyleForRowAt:))
				delegate().addSelector(s).editingStyleForRow = x
			case .estimatedHeightForFooter(let x):
				let s = #selector(UITableViewDelegate.tableView(_:estimatedHeightForFooterInSection:))
				delegate().addSelector(s).estimatedHeightForFooter = x
			case .estimatedHeightForHeader(let x):
				let s = #selector(UITableViewDelegate.tableView(_:estimatedHeightForHeaderInSection:))
				delegate().addSelector(s).estimatedHeightForHeader = x
			case .estimatedHeightForRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:estimatedHeightForRowAt:))
				delegate().addSelector(s).estimatedHeightForRow = x
			case .footerHeight(let x):
				let s = #selector(UITableViewDelegate.tableView(_:heightForFooterInSection:))
				delegate().addSelector(s).footerHeight = x
			case .footerView(let x):
				let s = #selector(UITableViewDelegate.tableView(_:viewForFooterInSection:))
				delegate().addSelector(s).footerView = x
			case .headerHeight(let x):
				let s = #selector(UITableViewDelegate.tableView(_:heightForHeaderInSection:))
				delegate().addSelector(s).headerHeight = x
			case .headerView(let x):
				let s = #selector(UITableViewDelegate.tableView(_:viewForHeaderInSection:))
				delegate().addSelector(s).headerView = x
			case .heightForRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:heightForRowAt:))
				delegate().addSelector(s).heightForRow = x
			case .indentationLevelForRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:indentationLevelForRowAt:))
				delegate().addSelector(s).indentationLevelForRow = x
			case .indexPathForPreferredFocusedView(let x):
				let s = #selector(UITableViewDelegate.indexPathForPreferredFocusedView(in:))
				delegate().addSelector(s).indexPathForPreferred = x
			case .moveRow(let x):
				let s = #selector(UITableViewDataSource.tableView(_:moveRowAt:to:))
				delegate().addSelector(s).moveRow = x
			case .shouldHighlightRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:shouldHighlightRowAt:))
				delegate().addSelector(s).shouldHighlightRow = x
			case .shouldIndentWhileEditingRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:shouldIndentWhileEditingRowAt:))
				delegate().addSelector(s).shouldIndentWhileEditingRow = x
			case .shouldShowMenuForRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:shouldShowMenuForRowAt:))
				delegate().addSelector(s).shouldShowMenuForRow = x
			case .shouldUpdateFocus(let x):
				let s = #selector(UITableViewDelegate.tableView(_:shouldUpdateFocusIn:))
				delegate().addSelector(s).shouldUpdateFocus = x
			case .targetIndexPathForMoveFromRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:targetIndexPathForMoveFromRowAt:toProposedIndexPath:))
				delegate().addSelector(s).targetIndexPathForMoveFromRow = x
			case .titleForDeleteConfirmationButtonForRow(let x):
				let s = #selector(UITableViewDelegate.tableView(_:titleForDeleteConfirmationButtonForRowAt:))
				delegate().addSelector(s).titleForDeleteConfirmationButtonForRow = x
			case .visibleRowsChanged(let x):
				let s1 = #selector(UITableViewDelegate.tableView(_:willDisplay:forRowAt:))
				let s2 = #selector(UITableViewDelegate.tableView(_:didEndDisplaying:forRowAt:))
				delegate().addSelector(s1)
				delegate().addSelector(s2)
				rowsChangedInput = x
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .cellIdentifier: return nil
			case .tableViewStyle: return nil
			case .allowsMultipleSelection(let x): return x.apply(instance, storage) { i, s, v in i.allowsMultipleSelection = v }
			case .allowsMultipleSelectionDuringEditing(let x): return x.apply(instance, storage) { i, s, v in i.allowsMultipleSelectionDuringEditing = v }
			case .allowsSelection(let x): return x.apply(instance, storage) { i, s, v in i.allowsSelection = v }
			case .allowsSelectionDuringEditing(let x): return x.apply(instance, storage) { i, s, v in i.allowsSelectionDuringEditing = v }
			case .backgroundView(let x): return x.apply(instance, storage) { i, s, v in i.backgroundView = v?.uiView() }
			case .cellLayoutMarginsFollowReadableWidth(let x): return x.apply(instance, storage) { i, s, v in i.cellLayoutMarginsFollowReadableWidth = v }
			case .deselectRow(let x): return x.apply(instance, storage) { i, s, v in i.deselectRow(at: v.value, animated: v.isAnimated) }
			case .isEditing(let x): return x.apply(instance, storage) { i, s, v in i.setEditing(v.value, animated: v.isAnimated) }
			case .estimatedRowHeight(let x): return x.apply(instance, storage) { i, s, v in i.estimatedRowHeight = v }
			case .estimatedSectionFooterHeight(let x): return x.apply(instance, storage) { i, s, v in i.estimatedSectionFooterHeight = v }
			case .estimatedSectionHeaderHeight(let x): return x.apply(instance, storage) { i, s, v in i.estimatedSectionHeaderHeight = v }
			case .remembersLastFocusedIndexPath(let x): return x.apply(instance, storage) { i, s, v in i.remembersLastFocusedIndexPath = v }
			case .rowHeight(let x): return x.apply(instance, storage) { i, s, v in i.rowHeight = v }
			case .scrollToNearestSelectedRow(let x): return x.apply(instance, storage) { i, s, v in i.scrollToNearestSelectedRow(at: v.value, animated: v.isAnimated) }
			case .scrollToRow(let x):
				// You can't scroll a table view until *after* the number of sections and rows has been read from the data source.
				// This occurs on didAddToWindow but the easiest way to track it is by waiting for the contentSize to be set (which is set for the first time immediately after the row count is read). This makes assumptions about internal logic of UITableView – if this logic changes in future, scrolls set on load might be lost (not a catastrophic problem).
				// Capture the scroll signal to stall it
				let capture = x.capture()
				
				// Create a signal pair that will join the capture to the destination *after* the first `contentSize` change is observed
				let pair = Signal<SetOrAnimate<TableScrollPosition>>.create()
				var kvo: NSKeyValueObservation? = instance.observe(\.contentSize) { (i, change) in
					_ = try? capture.bind(to: pair.input, resend: true)
				}
				
				// Use the output of the pair to apply the effects as normal
				return pair.signal.apply(instance, storage) { i, s, v in
					// Remove the key value observing after the first value is received.
					if let k = kvo {
						k.invalidate()
						kvo = nil
					}
					
					// Clamp to the number of actual sections and rows
					var indexPath = v.value.indexPath
					if indexPath.section >= i.numberOfSections {
						indexPath.section = i.numberOfSections - 1
					}
					if indexPath.section < 0 {
						return
					}
					if indexPath.row >= i.numberOfRows(inSection: indexPath.section) {
						indexPath.row = i.numberOfRows(inSection: indexPath.section) - 1
					}
					if indexPath.row < 0 {
						return
					}
					
					// Finally, perform the scroll
					i.scrollToRow(at: indexPath, at: v.value.position, animated: v.isAnimated)
				}
			case .sectionFooterHeight(let x): return x.apply(instance, storage) { i, s, v in i.sectionFooterHeight = v }
			case .sectionHeaderHeight(let x): return x.apply(instance, storage) { i, s, v in i.sectionHeaderHeight = v }
			case .sectionIndexBackgroundColor(let x): return x.apply(instance, storage) { i, s, v in i.sectionIndexBackgroundColor = v }
			case .sectionIndexColor(let x): return x.apply(instance, storage) { i, s, v in i.sectionIndexColor = v }
			case .sectionIndexMinimumDisplayRowCount(let x): return x.apply(instance, storage) { i, s, v in i.sectionIndexMinimumDisplayRowCount = v }
			case .sectionIndexTrackingBackgroundColor(let x): return x.apply(instance, storage) { i, s, v in i.sectionIndexTrackingBackgroundColor = v }
			case .selectRow(let x): return x.apply(instance, storage) { i, s, v in i.selectRow(at: v.value?.indexPath, animated: v.isAnimated, scrollPosition: v.value?.position ?? .none) }
			case .separatorColor(let x): return x.apply(instance, storage) { i, s, v in i.separatorColor = v }
			case .separatorEffect(let x): return x.apply(instance, storage) { i, s, v in i.separatorEffect = v }
			case .separatorInset(let x): return x.apply(instance, storage) { i, s, v in i.separatorInset = v }
			case .separatorStyle(let x): return x.apply(instance, storage) { i, s, v in i.separatorStyle = v }
			case .tableFooterView(let x): return x.apply(instance, storage) { i, s, v	in i.tableFooterView = v?.uiView() }
			case .tableHeaderView(let x): return x.apply(instance, storage) { i, s, v in i.tableHeaderView = v?.uiView() }
			case .selectionDidChange(let x):
				return Signal.notifications(name: UITableView.selectionDidChangeNotification, object: instance).map { n -> ([TableRow<RowData>])? in
					if let tableView = n.object as? UITableView, let selection = tableView.indexPathsForSelectedRows {
						if let rows = (tableView.delegate as? Storage)?.sections.rows {
							return selection.map { TableRow<RowData>(indexPath: $0, data: rows.at($0.section)?.rows.at($0.row)) }
						} else {
							return selection.map { TableRow<RowData>(indexPath: $0, data: nil) }
						}
					} else {
						return nil
					}
				}.cancellableBind(to: x)
			case .sectionIndexTitles(let x):
				return x.apply(instance, storage) { i, s, v in
					s.indexTitles = v
					i.reloadSectionIndexTitles()
				}
			case .tableData(let x):
				return x.apply(instance, storage) { i, s, v in
					s.applyTableRowMutation(v, to: i)
				}
			case .cellConstructor(let x):
				storage.cellConstructor = x
				return nil
			case .dataMissingCell(let x):
				storage.dataMissingCell = x
				return nil
			case .userDidScrollToRow: return nil
			case .accessoryButtonTapped: return nil
			case .canEditRow: return nil
			case .canFocusRow: return nil
			case .canMoveRow: return nil
			case .canPerformAction: return nil
			case .didDeselectRow: return nil
			case .didEndDisplayingFooter: return nil
			case .didEndDisplayingHeader: return nil
			case .didEndDisplayingRow: return nil
			case .didEndEditingRow: return nil
			case .didHightlightRow: return nil
			case .didSelectRow: return nil
			case .commit: return nil
			case .didUnhighlightRow: return nil
			case .didUpdateFocus: return nil
			case .editActionsForRow: return nil
			case .editingStyleForRow: return nil
			case .estimatedHeightForFooter: return nil
			case .estimatedHeightForHeader: return nil
			case .estimatedHeightForRow: return nil
			case .footerHeight: return nil
			case .footerView: return nil
			case .headerHeight: return nil
			case .headerView: return nil
			case .heightForRow: return nil
			case .indentationLevelForRow: return nil
			case .indexPathForPreferredFocusedView: return nil
			case .moveRow: return nil
			case .shouldHighlightRow: return nil
			case .shouldIndentWhileEditingRow: return nil
			case .shouldShowMenuForRow: return nil
			case .shouldUpdateFocus: return nil
			case .targetIndexPathForMoveFromRow: return nil
			case .titleForDeleteConfirmationButtonForRow: return nil
			case .visibleRowsChanged: return nil
			case .willBeginEditingRow: return nil
			case .willDeselectRow: return nil
			case .willDisplayFooter: return nil
			case .willDisplayHeader: return nil
			case .willDisplayRow: return nil
			case .willSelectRow: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}

		public mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			storage.rowsChangedInput = rowsChangedInput

			linkedPreparer.prepareInstance(instance, storage: storage)
			instance.dataSource = storage
		}
	}

	open class Storage: ScrollView.Storage, UITableViewDelegate, UITableViewDataSource {
		open override var inUse: Bool { return true }
		open var sections = TableRowState<TableSectionState<RowData>>()
		open var indexTitles: [String]? = nil
		open var scrollJunction: (SignalCapture<SetOrAnimate<(IndexPath, UITableView.ScrollPosition)>>, SignalInput<SetOrAnimate<(IndexPath, UITableView.ScrollPosition)>>)? = nil
		open var cellIdentifier: (TableRow<RowData>) -> String?
		open var cellConstructor: ((_ identifier: String?, _ rowSignal: SignalMulti<RowData>) -> TableViewCellConvertible)?
		open var dataMissingCell: (IndexPath) -> TableViewCellConvertible = { _ in return TableViewCell() }
		
		public init(cellIdentifier: @escaping (TableRow<RowData>) -> String?) {
			self.cellIdentifier = cellIdentifier
			super.init()
		}
		
		open func numberOfSections(in tableView: UITableView) -> Int {
			return sections.globalCount
		}
		
		open func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
			return sections.rows.at(section)?.globalCount ?? 0
		}
		
		open func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
			let data = sections.rows.at(indexPath.section).flatMap { s in s.rows.at(indexPath.row - s.localOffset) }
			let identifier = cellIdentifier(TableRow(indexPath: indexPath, data: data))
			
			let cellView: UITableViewCell
			let cellInput: SignalInput<RowData>?
			if let i = identifier, let reusedView = tableView.dequeueReusableCell(withIdentifier: i) {
				cellView = reusedView
				cellInput = getSignalInput(for: reusedView, valueType: RowData.self)
			} else if let cc = cellConstructor {
				let dataTuple = Signal<RowData>.channel().multicast()
				let constructed = cc(identifier, dataTuple.signal).uiTableViewCell(reuseIdentifier: identifier)
				cellView = constructed
				cellInput = dataTuple.input
				setSignalInput(for: constructed, to: dataTuple.input)
			} else {
				return dataMissingCell(indexPath).uiTableViewCell(reuseIdentifier: nil)
			}
			
			if let d = data {
				_ = cellInput?.send(value: d)
			}
			
			return cellView
		}
		
		open func tableView(_ tableView: UITableView, titleForHeaderInSection: Int) -> String? {
			return sections.rows.at(titleForHeaderInSection)?.metadata.header
		}
		
		open func tableView(_ tableView: UITableView, titleForFooterInSection: Int) -> String? {
			return sections.rows.at(titleForFooterInSection)?.metadata.footer
		}
		
		open func sectionIndexTitles(for tableView: UITableView) -> [String]? {
			return indexTitles
		}
		
		open var rowsChangedInput: SignalInput<[TableRow<RowData>]>?
		open func notifyVisibleRowsChanged(in tableView: UITableView) {
			Exec.mainAsync.invoke {
				if let input = self.rowsChangedInput {
					let indexPaths = tableView.indexPathsForVisibleRows
					if let ip = indexPaths, ip.count > 0 {
						input.send(value: ip.map { TableRow<RowData>(indexPath: $0, data: self.sections.rows.at($0.section)?.rows.at($0.row)) })
					} else {
						input.send(value: [])
					}
				}
			}
		}
		
		open func applyTableRowMutation(_ v: TableRowMutation<TableSectionMutation<RowData>>, to i: UITableView) {
			v.apply(to: &sections)
			
			switch v.arrayMutation.kind {
			case .delete:
				i.deleteSections(v.arrayMutation.indexSet.offset(by: sections.localOffset), with: v.animation)
			case .move(let destination):
				i.beginUpdates()
				for (count, index) in v.arrayMutation.indexSet.offset(by: sections.localOffset).enumerated() {
					i.moveSection(index, toSection: destination + count)
				}
				i.endUpdates()
			case .insert:
				i.insertSections(v.arrayMutation.indexSet.offset(by: sections.localOffset), with: v.animation)
			case .scroll:
				i.reloadSections(v.arrayMutation.indexSet.offset(by: sections.localOffset), with: v.animation)
			case .update:
				for (sectionIndex, change) in zip(v.arrayMutation.indexSet.offset(by: sections.localOffset), v.arrayMutation.values) {
					if change.metadata != nil {
						i.reloadSections([sectionIndex], with: v.animation)
					} else {
						let mappedIndices = change.rowMutation.arrayMutation.indexSet.map { IndexPath(row: $0, section: sectionIndex) }
						switch change.rowMutation.arrayMutation.kind {
						case .delete: i.deleteRows(at: mappedIndices, with: change.rowMutation.animation)
						case .move(let destination):
							for (count, index) in mappedIndices.enumerated() {
								i.moveRow(at: index, to: IndexPath(row: destination + count, section: sectionIndex))
							}
						case .insert: i.insertRows(at: mappedIndices, with: change.rowMutation.animation)
						case .scroll:
							i.reloadRows(at: mappedIndices, with: change.rowMutation.animation)
						case .update:
							guard let section = sections.rows.at(sectionIndex - sections.localOffset) else { continue }
							for indexPath in mappedIndices {
								guard let cell = i.cellForRow(at: indexPath), let value = section.rows.at(indexPath.row - section.rowState.localOffset) else { continue }
								getSignalInput(for: cell, valueType: RowData.self)?.send(value: value)
							}
							notifyVisibleRowsChanged(in: i)
						case .reload:
							i.reloadSections([sectionIndex], with: change.rowMutation.animation)
						}
					}
				}
			case .reload:
				i.reloadData()
			}
		}
	}

	open class Delegate: ScrollView.Delegate, UITableViewDataSource, UITableViewDelegate {
		public required init() {
			super.init()
		}
		
		open var userDidScrollToRow: SignalInput<TableRow<RowData>>?

		open override func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) {
			super.scrollViewDidEndDragging(scrollView, willDecelerate: decelerate)
			if !decelerate, let tableView = scrollView as? UITableView, let topVisibleRow = tableView.indexPathsForVisibleRows?.last {
				userDidScrollToRow?.send(value: tableRowData(at: topVisibleRow, in: tableView))
			}
		}
		
		open override func scrollViewDidScrollToTop(_ scrollView: UIScrollView) {
			super.scrollViewDidScrollToTop(scrollView)
			if let tableView = scrollView as? UITableView, let topVisibleRow = tableView.indexPathsForVisibleRows?.last {
				userDidScrollToRow?.send(value: tableRowData(at: topVisibleRow, in: tableView))
			}
		}
		
		open override func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {
			super.scrollViewDidEndDecelerating(scrollView)
			if let tableView = scrollView as? UITableView, let topVisibleRow = tableView.indexPathsForVisibleRows?.last {
				userDidScrollToRow?.send(value: tableRowData(at: topVisibleRow, in: tableView))
			}
		}

		private func tableRowData(at indexPath: IndexPath, in tableView: UITableView) -> TableRow<RowData> {
			return TableRow<RowData>(indexPath: indexPath, data: (tableView.delegate as? Storage)?.sections.rows.at(indexPath.section)?.rows.at(indexPath.row))
		}
		
		open func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
			return 0
		}
		open func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
			return UITableViewCell()
		}
		
		open var accessoryButtonTapped: SignalInput<TableRow<RowData>>?
		open func tableView(_ tableView: UITableView, accessoryButtonTappedForRowWith indexPath: IndexPath) {
			accessoryButtonTapped?.send(value: tableRowData(at: indexPath, in: tableView))
		}
		
		open var canEditRow: ((_ tableRowData: TableRow<RowData>) -> Bool)?
		open func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool {
			return canEditRow!(tableRowData(at: indexPath, in: tableView))
		}
		
		open var canFocusRow: ((_ tableRowData: TableRow<RowData>) -> Bool)?
		open func tableView(_ tableView: UITableView, canFocusRowAt indexPath: IndexPath) -> Bool {
			return canFocusRow!(tableRowData(at: indexPath, in: tableView))
		}
		
		open var canMoveRow: ((_ tableRowData: TableRow<RowData>) -> Bool)?
		open func tableView(_ tableView: UITableView, canMoveRowAt indexPath: IndexPath) -> Bool {
			return canMoveRow!(tableRowData(at: indexPath, in: tableView))
		}
		
		open var canPerformAction: ((_ action: Selector, _ tableRowData: TableRow<RowData>, _ sender: Any?) -> Bool)?
		open func tableView(_ tableView: UITableView, canPerformAction action: Selector, forRowAt indexPath: IndexPath, withSender sender: Any?) -> Bool {
			return canPerformAction!(action, tableRowData(at: indexPath, in: tableView), sender)
		}
		
		open var didDeselectRow: SignalInput<TableRow<RowData>>?
		open func tableView(_ tableView: UITableView, didDeselectRowAt indexPath: IndexPath) {
			didDeselectRow?.send(value: tableRowData(at: indexPath, in: tableView))
		}
		
		open var didEndDisplayingHeader: SignalInput<Int>?
		open func tableView(_ tableView: UITableView, didEndDisplayingHeaderView view: UIView, forSection section: Int) {
			didEndDisplayingHeader?.send(value: section)
		}
		
		open var didEndDisplayingFooter: SignalInput<Int>?
		open func tableView(_ tableView: UITableView, didEndDisplayingFooterView view: UIView, forSection section: Int) {
			didEndDisplayingFooter?.send(value: section)
		}
		
		open var didEndDisplayingRow: SignalInput<TableRow<RowData>>?
		open func tableView(_ tableView: UITableView, didEndDisplaying cell: UITableViewCell, forRowAt indexPath: IndexPath) {
			didEndDisplayingRow?.send(value: tableRowData(at: indexPath, in: tableView))
			
			(tableView.delegate as? Storage)?.notifyVisibleRowsChanged(in: tableView)
		}
		
		open var didEndEditingRow: SignalInput<TableRow<RowData>?>?
		open func tableView(_ tableView: UITableView, didEndEditingRowAt indexPath: IndexPath?) {
			didEndEditingRow?.send(value: indexPath.map { tableRowData(at: $0, in: tableView) })
		}
		
		open var didHightlightRow: SignalInput<TableRow<RowData>>?
		open func tableView(_ tableView: UITableView, didHighlightRowAt indexPath: IndexPath) {
			didHightlightRow?.send(value: tableRowData(at: indexPath, in: tableView))
		}
		
		open var didSelectRow: SignalInput<TableRow<RowData>>?
		open func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
			didSelectRow?.send(value: tableRowData(at: indexPath, in: tableView))
		}
		
		open var didUnhighlightRow: SignalInput<TableRow<RowData>>?
		open func tableView(_ tableView: UITableView, didUnhighlightRowAt indexPath: IndexPath) {
			didUnhighlightRow?.send(value: tableRowData(at: indexPath, in: tableView))
		}
		
		open var didUpdateFocus: ((UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -> Void)?
		open func tableView(_ tableView: UITableView, didUpdateFocusIn context: UITableViewFocusUpdateContext, with coordinator: UIFocusAnimationCoordinator) {
			return didUpdateFocus!(tableView, context, coordinator)
		}
		
		open var editActionsForRow: ((_ tableRowData: TableRow<RowData>) -> [UITableViewRowAction]?)?
		open func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -> [UITableViewRowAction]? {
			return editActionsForRow!(tableRowData(at: indexPath, in: tableView))
		}
		
		open var editingStyleForRow: ((_ tableRowData: TableRow<RowData>) -> UITableViewCell.EditingStyle)?
		open func tableView(_ tableView: UITableView, editingStyleForRowAt indexPath: IndexPath) -> UITableViewCell.EditingStyle {
			return editingStyleForRow!(tableRowData(at: indexPath, in: tableView))
		}
		
		open var estimatedHeightForFooter: ((_ section: Int) -> CGFloat)?
		open func tableView(_ tableView: UITableView, estimatedHeightForFooterInSection section: Int) -> CGFloat {
			return estimatedHeightForFooter!(section)
		}
		
		open var estimatedHeightForHeader: ((_ section: Int) -> CGFloat)?
		open func tableView(_ tableView: UITableView, estimatedHeightForHeaderInSection section: Int) -> CGFloat {
			return estimatedHeightForHeader!(section)
		}
		
		open var estimatedHeightForRow: ((_ tableRowData: TableRow<RowData>) -> CGFloat)?
		open func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -> CGFloat {
			return estimatedHeightForRow!(tableRowData(at: indexPath, in: tableView))
		}
		
		open var footerHeight: ((_ section: Int) -> CGFloat)?
		open func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -> CGFloat {
			return footerHeight!(section)
		}
		
		open var footerView: ((_ section: Int, _ title: String?) -> ViewConvertible?)?
		open func tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -> UIView? {
			return footerView!(section, tableView.dataSource?.tableView?(tableView, titleForFooterInSection: section))?.uiView()
		}
		
		open var headerHeight: ((_ section: Int) -> CGFloat)?
		open func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
			return headerHeight!(section)
		}
		
		open var headerView: ((_ section: Int, _ title: String?) -> ViewConvertible?)?
		open func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
			return headerView!(section, tableView.dataSource?.tableView?(tableView, titleForHeaderInSection: section))?.uiView()
		}
		
		open var heightForRow: ((_ tableRowData: TableRow<RowData>) -> CGFloat)?
		open func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
			return heightForRow!(tableRowData(at: indexPath, in: tableView))
		}
		
		open var indentationLevelForRow: ((_ tableRowData: TableRow<RowData>) -> Int)?
		open func tableView(_ tableView: UITableView, indentationLevelForRowAt indexPath: IndexPath) -> Int {
			return indentationLevelForRow!(tableRowData(at: indexPath, in: tableView))
		}
		
		open var indexPathForPreferred: ((UITableView) -> IndexPath)?
		open func indexPathForPreferredFocusedView(in tableView: UITableView) -> IndexPath? {
			return indexPathForPreferred!(tableView)
		}
		
		open var moveRow: SignalInput<(from: TableRow<RowData>, to: IndexPath)>?
		open func tableView(_ tableView: UITableView, moveRowAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) {
			moveRow!.send(value: (from: tableRowData(at: sourceIndexPath, in: tableView), to: destinationIndexPath))
		}
		
		open var shouldHighlightRow: ((_ tableRowData: TableRow<RowData>) -> Bool)?
		open func tableView(_ tableView: UITableView, shouldHighlightRowAt indexPath: IndexPath) -> Bool {
			return shouldHighlightRow!(tableRowData(at: indexPath, in: tableView))
		}
		
		open var shouldIndentWhileEditingRow: ((_ tableRowData: TableRow<RowData>) -> Bool)?
		open func tableView(_ tableView: UITableView, shouldIndentWhileEditingRowAt indexPath: IndexPath) -> Bool {
			return shouldIndentWhileEditingRow!(tableRowData(at: indexPath, in: tableView))
		}
		
		open var shouldShowMenuForRow: ((_ tableRowData: TableRow<RowData>) -> Bool)?
		open func tableView(_ tableView: UITableView, shouldShowMenuForRowAt indexPath: IndexPath) -> Bool {
			return shouldShowMenuForRow!(tableRowData(at: indexPath, in: tableView))
		}
		
		open var shouldUpdateFocus: ((UITableView, UITableViewFocusUpdateContext) -> Bool)?
		open func tableView(_ tableView: UITableView, shouldUpdateFocusIn context: UITableViewFocusUpdateContext) -> Bool {
			return shouldUpdateFocus!(tableView, context)
		}
		
		open var targetIndexPathForMoveFromRow: ((_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -> IndexPath)?
		open func tableView(_ tableView: UITableView, targetIndexPathForMoveFromRowAt sourceIndexPath: IndexPath, toProposedIndexPath proposedDestinationIndexPath: IndexPath) -> IndexPath {
			return targetIndexPathForMoveFromRow!(tableView, sourceIndexPath, proposedDestinationIndexPath)
		}
		
		open var titleForDeleteConfirmationButtonForRow: ((_ tableRowData: TableRow<RowData>) -> String?)?
		open func tableView(_ tableView: UITableView, titleForDeleteConfirmationButtonForRowAt indexPath: IndexPath) -> String? {
			return titleForDeleteConfirmationButtonForRow!(tableRowData(at: indexPath, in: tableView))
		}
		
		open var willBeginEditingRow: ((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> Void)?
		open func tableView(_ tableView: UITableView, willBeginEditingRowAt indexPath: IndexPath) {
			willBeginEditingRow!(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		open var willDeselectRow: ((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> IndexPath?)?
		open func tableView(_ tableView: UITableView, willDeselectRowAt indexPath: IndexPath) -> IndexPath? {
			return willDeselectRow!(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		open var willDisplayFooter: ((_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void)?
		open func tableView(_ tableView: UITableView, willDisplayFooterView view: UIView, forSection section: Int) {
			willDisplayFooter!(tableView, section, view)
		}
		
		open var willDisplayHeader: ((_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void)?
		open func tableView(_ tableView: UITableView, willDisplayHeaderView view: UIView, forSection section: Int) {
			willDisplayHeader!(tableView, section, view)
		}
		
		open var willDisplayRow: ((_ tableView: UITableView, _ indexPath: IndexPath, _ cell: UITableViewCell) -> Void)?
		open func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {
			willDisplayRow?(tableView, indexPath, cell)
			(tableView.delegate as? Storage)?.notifyVisibleRowsChanged(in: tableView)
		}
		
		open var willSelectRow: ((_ tableView: UITableView, _ tableRowData: TableRow<RowData>) -> IndexPath?)?
		open func tableView(_ tableView: UITableView, willSelectRowAt indexPath: IndexPath) -> IndexPath? {
			return willSelectRow!(tableView, tableRowData(at: indexPath, in: tableView))
		}
		
		open var commit: SignalInput<(editingStyle: UITableViewCell.EditingStyle, row: TableRow<RowData>)>?
		open func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) {
			commit?.send(value: (editingStyle, tableRowData(at: indexPath, in: tableView)))
		}
	}
}

extension BindingName where Binding: TableViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .tableViewBinding(TableView.Binding.$1(v)) }) }
	public static var cellIdentifier: BindingName<(TableRow<Binding.RowDataType>) -> String?, Binding> { return BindingName<(TableRow<Binding.RowDataType>) -> String?, Binding>({ v in .tableViewBinding(TableView.Binding.cellIdentifier(v)) }) }
	public static var tableViewStyle: BindingName<Constant<UITableView.Style>, Binding> { return BindingName<Constant<UITableView.Style>, Binding>({ v in .tableViewBinding(TableView.Binding.tableViewStyle(v)) }) }
	public static var allowsMultipleSelection: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .tableViewBinding(TableView.Binding.allowsMultipleSelection(v)) }) }
	public static var allowsMultipleSelectionDuringEditing: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .tableViewBinding(TableView.Binding.allowsMultipleSelectionDuringEditing(v)) }) }
	public static var allowsSelection: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .tableViewBinding(TableView.Binding.allowsSelection(v)) }) }
	public static var allowsSelectionDuringEditing: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .tableViewBinding(TableView.Binding.allowsSelectionDuringEditing(v)) }) }
	public static var backgroundView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .tableViewBinding(TableView.Binding.backgroundView(v)) }) }
	public static var cellLayoutMarginsFollowReadableWidth: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .tableViewBinding(TableView.Binding.cellLayoutMarginsFollowReadableWidth(v)) }) }
	public static var isEditing: BindingName<Signal<SetOrAnimate<Bool>>, Binding> { return BindingName<Signal<SetOrAnimate<Bool>>, Binding>({ v in .tableViewBinding(TableView.Binding.isEditing(v)) }) }
	public static var estimatedRowHeight: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .tableViewBinding(TableView.Binding.estimatedRowHeight(v)) }) }
	public static var estimatedSectionFooterHeight: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .tableViewBinding(TableView.Binding.estimatedSectionFooterHeight(v)) }) }
	public static var estimatedSectionHeaderHeight: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .tableViewBinding(TableView.Binding.estimatedSectionHeaderHeight(v)) }) }
	public static var remembersLastFocusedIndexPath: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .tableViewBinding(TableView.Binding.remembersLastFocusedIndexPath(v)) }) }
	public static var rowHeight: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .tableViewBinding(TableView.Binding.rowHeight(v)) }) }
	public static var sectionFooterHeight: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .tableViewBinding(TableView.Binding.sectionFooterHeight(v)) }) }
	public static var sectionHeaderHeight: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .tableViewBinding(TableView.Binding.sectionHeaderHeight(v)) }) }
	public static var sectionIndexBackgroundColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .tableViewBinding(TableView.Binding.sectionIndexBackgroundColor(v)) }) }
	public static var sectionIndexColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .tableViewBinding(TableView.Binding.sectionIndexColor(v)) }) }
	public static var sectionIndexMinimumDisplayRowCount: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .tableViewBinding(TableView.Binding.sectionIndexMinimumDisplayRowCount(v)) }) }
	public static var sectionIndexTrackingBackgroundColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .tableViewBinding(TableView.Binding.sectionIndexTrackingBackgroundColor(v)) }) }
	public static var sectionIndexTitles: BindingName<Dynamic<[String]?>, Binding> { return BindingName<Dynamic<[String]?>, Binding>({ v in .tableViewBinding(TableView.Binding.sectionIndexTitles(v)) }) }
	public static var separatorColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .tableViewBinding(TableView.Binding.separatorColor(v)) }) }
	public static var separatorEffect: BindingName<Dynamic<UIVisualEffect?>, Binding> { return BindingName<Dynamic<UIVisualEffect?>, Binding>({ v in .tableViewBinding(TableView.Binding.separatorEffect(v)) }) }
	public static var separatorInset: BindingName<Dynamic<UIEdgeInsets>, Binding> { return BindingName<Dynamic<UIEdgeInsets>, Binding>({ v in .tableViewBinding(TableView.Binding.separatorInset(v)) }) }
	public static var separatorStyle: BindingName<Dynamic<UITableViewCell.SeparatorStyle>, Binding> { return BindingName<Dynamic<UITableViewCell.SeparatorStyle>, Binding>({ v in .tableViewBinding(TableView.Binding.separatorStyle(v)) }) }
	public static var tableFooterView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .tableViewBinding(TableView.Binding.tableFooterView(v)) }) }
	public static var tableHeaderView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .tableViewBinding(TableView.Binding.tableHeaderView(v)) }) }
	public static var tableData: BindingName<Dynamic<TableData<Binding.RowDataType>>, Binding> { return BindingName<Dynamic<TableData<Binding.RowDataType>>, Binding>({ v in .tableViewBinding(TableView.Binding.tableData(v)) }) }
	public static var deselectRow: BindingName<Signal<SetOrAnimate<IndexPath>>, Binding> { return BindingName<Signal<SetOrAnimate<IndexPath>>, Binding>({ v in .tableViewBinding(TableView.Binding.deselectRow(v)) }) }
	public static var scrollToNearestSelectedRow: BindingName<Signal<SetOrAnimate<UITableView.ScrollPosition>>, Binding> { return BindingName<Signal<SetOrAnimate<UITableView.ScrollPosition>>, Binding>({ v in .tableViewBinding(TableView.Binding.scrollToNearestSelectedRow(v)) }) }
	public static var scrollToRow: BindingName<Signal<SetOrAnimate<TableScrollPosition>>, Binding> { return BindingName<Signal<SetOrAnimate<TableScrollPosition>>, Binding>({ v in .tableViewBinding(TableView.Binding.scrollToRow(v)) }) }
	public static var selectRow: BindingName<Signal<SetOrAnimate<TableScrollPosition?>>, Binding> { return BindingName<Signal<SetOrAnimate<TableScrollPosition?>>, Binding>({ v in .tableViewBinding(TableView.Binding.selectRow(v)) }) }
	public static var userDidScrollToRow: BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding> { return BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding>({ v in .tableViewBinding(TableView.Binding.userDidScrollToRow(v)) }) }
	public static var accessoryButtonTapped: BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding> { return BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding>({ v in .tableViewBinding(TableView.Binding.accessoryButtonTapped(v)) }) }
	public static var didDeselectRow: BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding> { return BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding>({ v in .tableViewBinding(TableView.Binding.didDeselectRow(v)) }) }
	public static var didEndDisplayingFooter: BindingName<SignalInput<Int>, Binding> { return BindingName<SignalInput<Int>, Binding>({ v in .tableViewBinding(TableView.Binding.didEndDisplayingFooter(v)) }) }
	public static var didEndDisplayingHeader: BindingName<SignalInput<Int>, Binding> { return BindingName<SignalInput<Int>, Binding>({ v in .tableViewBinding(TableView.Binding.didEndDisplayingHeader(v)) }) }
	public static var didEndDisplayingRow: BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding> { return BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding>({ v in .tableViewBinding(TableView.Binding.didEndDisplayingRow(v)) }) }
	public static var didEndEditingRow: BindingName<SignalInput<TableRow<Binding.RowDataType>?>, Binding> { return BindingName<SignalInput<TableRow<Binding.RowDataType>?>, Binding>({ v in .tableViewBinding(TableView.Binding.didEndEditingRow(v)) }) }
	public static var didHightlightRow: BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding> { return BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding>({ v in .tableViewBinding(TableView.Binding.didHightlightRow(v)) }) }
	public static var didSelectRow: BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding> { return BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding>({ v in .tableViewBinding(TableView.Binding.didSelectRow(v)) }) }
	public static var didUnhighlightRow: BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding> { return BindingName<SignalInput<TableRow<Binding.RowDataType>>, Binding>({ v in .tableViewBinding(TableView.Binding.didUnhighlightRow(v)) }) }
	public static var moveRow: BindingName<SignalInput<(from: TableRow<Binding.RowDataType>, to: IndexPath)>, Binding> { return BindingName<SignalInput<(from: TableRow<Binding.RowDataType>, to: IndexPath)>, Binding>({ v in .tableViewBinding(TableView.Binding.moveRow(v)) }) }
	public static var selectionDidChange: BindingName<SignalInput<[TableRow<Binding.RowDataType>]?>, Binding> { return BindingName<SignalInput<[TableRow<Binding.RowDataType>]?>, Binding>({ v in .tableViewBinding(TableView.Binding.selectionDidChange(v)) }) }
	public static var visibleRowsChanged: BindingName<SignalInput<[TableRow<Binding.RowDataType>]>, Binding> { return BindingName<SignalInput<[TableRow<Binding.RowDataType>]>, Binding>({ v in .tableViewBinding(TableView.Binding.visibleRowsChanged(v)) }) }
	public static var commit: BindingName<SignalInput<(editingStyle: UITableViewCell.EditingStyle, row: TableRow<Binding.RowDataType>)>, Binding> { return BindingName<SignalInput<(editingStyle: UITableViewCell.EditingStyle, row: TableRow<Binding.RowDataType>)>, Binding>({ v in .tableViewBinding(TableView.Binding.commit(v)) }) }
	public static var canEditRow: BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, Binding> { return BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, Binding>({ v in .tableViewBinding(TableView.Binding.canEditRow(v)) }) }
	public static var canFocusRow: BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, Binding> { return BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, Binding>({ v in .tableViewBinding(TableView.Binding.canFocusRow(v)) }) }
	public static var canMoveRow: BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, Binding> { return BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, Binding>({ v in .tableViewBinding(TableView.Binding.canMoveRow(v)) }) }
	public static var canPerformAction: BindingName<(_ action: Selector, _ tableRowData: TableRow<Binding.RowDataType>, _ sender: Any?) -> Bool, Binding> { return BindingName<(_ action: Selector, _ tableRowData: TableRow<Binding.RowDataType>, _ sender: Any?) -> Bool, Binding>({ v in .tableViewBinding(TableView.Binding.canPerformAction(v)) }) }
	public static var cellConstructor: BindingName<(_ identifier: String?, _ rowSignal: Signal<Binding.RowDataType>) -> TableViewCellConvertible, Binding> { return BindingName<(_ identifier: String?, _ rowSignal: Signal<Binding.RowDataType>) -> TableViewCellConvertible, Binding>({ v in .tableViewBinding(TableView.Binding.cellConstructor(v)) }) }
	public static var dataMissingCell: BindingName<(IndexPath) -> TableViewCellConvertible, Binding> { return BindingName<(IndexPath) -> TableViewCellConvertible, Binding>({ v in .tableViewBinding(TableView.Binding.dataMissingCell(v)) }) }
	public static var didUpdateFocus: BindingName<(UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -> Void, Binding> { return BindingName<(UITableView, UITableViewFocusUpdateContext, UIFocusAnimationCoordinator) -> Void, Binding>({ v in .tableViewBinding(TableView.Binding.didUpdateFocus(v)) }) }
	public static var editActionsForRow: BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> [UITableViewRowAction]?, Binding> { return BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> [UITableViewRowAction]?, Binding>({ v in .tableViewBinding(TableView.Binding.editActionsForRow(v)) }) }
	public static var editingStyleForRow: BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> UITableViewCell.EditingStyle, Binding> { return BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> UITableViewCell.EditingStyle, Binding>({ v in .tableViewBinding(TableView.Binding.editingStyleForRow(v)) }) }
	public static var estimatedHeightForFooter: BindingName<(_ section: Int) -> CGFloat, Binding> { return BindingName<(_ section: Int) -> CGFloat, Binding>({ v in .tableViewBinding(TableView.Binding.estimatedHeightForFooter(v)) }) }
	public static var estimatedHeightForHeader: BindingName<(_ section: Int) -> CGFloat, Binding> { return BindingName<(_ section: Int) -> CGFloat, Binding>({ v in .tableViewBinding(TableView.Binding.estimatedHeightForHeader(v)) }) }
	public static var estimatedHeightForRow: BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat, Binding> { return BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat, Binding>({ v in .tableViewBinding(TableView.Binding.estimatedHeightForRow(v)) }) }
	public static var footerHeight: BindingName<(_ section: Int) -> CGFloat, Binding> { return BindingName<(_ section: Int) -> CGFloat, Binding>({ v in .tableViewBinding(TableView.Binding.footerHeight(v)) }) }
	public static var footerView: BindingName<(_ section: Int, _ title: String?) -> ViewConvertible?, Binding> { return BindingName<(_ section: Int, _ title: String?) -> ViewConvertible?, Binding>({ v in .tableViewBinding(TableView.Binding.footerView(v)) }) }
	public static var headerHeight: BindingName<(_ section: Int) -> CGFloat, Binding> { return BindingName<(_ section: Int) -> CGFloat, Binding>({ v in .tableViewBinding(TableView.Binding.headerHeight(v)) }) }
	public static var headerView: BindingName<(_ section: Int, _ title: String?) -> ViewConvertible?, Binding> { return BindingName<(_ section: Int, _ title: String?) -> ViewConvertible?, Binding>({ v in .tableViewBinding(TableView.Binding.headerView(v)) }) }
	public static var heightForRow: BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat, Binding> { return BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> CGFloat, Binding>({ v in .tableViewBinding(TableView.Binding.heightForRow(v)) }) }
	public static var indentationLevelForRow: BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Int, Binding> { return BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Int, Binding>({ v in .tableViewBinding(TableView.Binding.indentationLevelForRow(v)) }) }
	public static var indexPathForPreferredFocusedView: BindingName<(UITableView) -> IndexPath, Binding> { return BindingName<(UITableView) -> IndexPath, Binding>({ v in .tableViewBinding(TableView.Binding.indexPathForPreferredFocusedView(v)) }) }
	public static var shouldHighlightRow: BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, Binding> { return BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, Binding>({ v in .tableViewBinding(TableView.Binding.shouldHighlightRow(v)) }) }
	public static var shouldIndentWhileEditingRow: BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, Binding> { return BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, Binding>({ v in .tableViewBinding(TableView.Binding.shouldIndentWhileEditingRow(v)) }) }
	public static var shouldShowMenuForRow: BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, Binding> { return BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> Bool, Binding>({ v in .tableViewBinding(TableView.Binding.shouldShowMenuForRow(v)) }) }
	public static var shouldUpdateFocus: BindingName<(UITableView, UITableViewFocusUpdateContext) -> Bool, Binding> { return BindingName<(UITableView, UITableViewFocusUpdateContext) -> Bool, Binding>({ v in .tableViewBinding(TableView.Binding.shouldUpdateFocus(v)) }) }
	public static var targetIndexPathForMoveFromRow: BindingName<(_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -> IndexPath, Binding> { return BindingName<(_ tableView: UITableView, _ sourceIndexPath: IndexPath, _ proposedIndexPath: IndexPath) -> IndexPath, Binding>({ v in .tableViewBinding(TableView.Binding.targetIndexPathForMoveFromRow(v)) }) }
	public static var titleForDeleteConfirmationButtonForRow: BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> String?, Binding> { return BindingName<(_ tableRowData: TableRow<Binding.RowDataType>) -> String?, Binding>({ v in .tableViewBinding(TableView.Binding.titleForDeleteConfirmationButtonForRow(v)) }) }
	public static var willBeginEditingRow: BindingName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Void, Binding> { return BindingName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> Void, Binding>({ v in .tableViewBinding(TableView.Binding.willBeginEditingRow(v)) }) }
	public static var willDeselectRow: BindingName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?, Binding> { return BindingName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?, Binding>({ v in .tableViewBinding(TableView.Binding.willDeselectRow(v)) }) }
	public static var willDisplayFooter: BindingName<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void, Binding> { return BindingName<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void, Binding>({ v in .tableViewBinding(TableView.Binding.willDisplayFooter(v)) }) }
	public static var willDisplayHeader: BindingName<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void, Binding> { return BindingName<(_ tableView: UITableView, _ section: Int, _ view: UIView) -> Void, Binding>({ v in .tableViewBinding(TableView.Binding.willDisplayHeader(v)) }) }
	public static var willDisplayRow: BindingName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>, _ cell: UITableViewCell) -> Void, Binding> { return BindingName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>, _ cell: UITableViewCell) -> Void, Binding>({ v in .tableViewBinding(TableView.Binding.willDisplayRow(v)) }) }
	public static var willSelectRow: BindingName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?, Binding> { return BindingName<(_ tableView: UITableView, _ tableRowData: TableRow<Binding.RowDataType>) -> IndexPath?, Binding>({ v in .tableViewBinding(TableView.Binding.willSelectRow(v)) }) }
}

public protocol TableViewConvertible: ScrollViewConvertible {
	func uiTableView() -> UITableView
}
extension TableViewConvertible {
	public func uiScrollView() -> ScrollView.Instance { return uiTableView() }
}
extension TableView.Instance: TableViewConvertible {
	public func uiTableView() -> UITableView { return self }
}

public protocol TableViewBinding: ScrollViewBinding {
	associatedtype RowDataType
	static func tableViewBinding(_ binding: TableView<RowDataType>.Binding) -> Self
}
extension TableViewBinding {
	public static func scrollViewBinding(_ binding: ScrollView.Binding) -> Self {
		return tableViewBinding(.inheritedBinding(binding))
	}
}

public typealias TableData<RowData> = TableRowMutation<TableSectionMutation<RowData>>

public struct TableScrollPosition {
	public let indexPath: IndexPath
	public let position: UITableView.ScrollPosition
	public init(indexPath: IndexPath, position: UITableView.ScrollPosition = .none) {
		self.indexPath = indexPath
		self.position = position
	}
	
	public static func none(_ indexPath: IndexPath) -> TableScrollPosition {
		return TableScrollPosition(indexPath: indexPath, position: .none)
	}
	
	public static func top(_ indexPath: IndexPath) -> TableScrollPosition {
		return TableScrollPosition(indexPath: indexPath, position: .top)
	}
	
	public static func middle(_ indexPath: IndexPath) -> TableScrollPosition {
		return TableScrollPosition(indexPath: indexPath, position: .middle)
	}
	
	public static func bottom(_ indexPath: IndexPath) -> TableScrollPosition {
		return TableScrollPosition(indexPath: indexPath, position: .bottom)
	}
}

public func updateFirstRow<RowData>(_ storage: Var<IndexPath?>) -> SignalInput<[TableRow<RowData>]> {
	return Input().map { $0.first?.indexPath }.bind(to: storage.updatingInput)
}

extension SignalInterface where OutputValue == IndexPath? {
	public func restoreFirstRow() -> Signal<SetOrAnimate<TableScrollPosition>> {
		return compactMap { $0.map { .top($0) } }.animate(.none)
	}
}

public struct TableRow<RowData> {
	public let indexPath: IndexPath
	public let data: RowData?
	
	public init(indexPath: IndexPath, data: RowData?) {
		self.indexPath = indexPath
		self.data = data
	}
}

public class TextField: ConstructingBinder, TextFieldConvertible {
	public typealias Instance = UITextField
	public typealias Inherited = Control
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiTextField() -> Instance { return instance() }
	
	public enum Binding: TextFieldBinding {
		public typealias EnclosingBinder = TextField
		public static func textFieldBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case textInputTraits(Constant<TextInputTraits>)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case text(Dynamic<String>)
		case attributedText(Dynamic<NSAttributedString?>)
		case placeholder(Dynamic<String?>)
		case attributedPlaceholder(Dynamic<NSAttributedString?>)
		case defaultTextAttributes(Dynamic<[NSAttributedString.Key: Any]>)
		case font(Dynamic<UIFont?>)
		case textColor(Dynamic<UIColor?>)
		case textAlignment(Dynamic<NSTextAlignment>)
		case typingAttributes(Dynamic<[NSAttributedString.Key: Any]?>)
		case adjustsFontSizeToFitWidth(Dynamic<Bool>)
		case minimumFontSize(Dynamic<CGFloat>)
		case clearsOnBeginEditing(Dynamic<Bool>)
		case clearsOnInsertion(Dynamic<Bool>)
		case allowsEditingTextAttributes(Dynamic<Bool>)
		case borderStyle(Dynamic<UITextField.BorderStyle>)
		case background(Dynamic<UIImage?>)
		case disabledBackground(Dynamic<UIImage?>)
		case clearButtonMode(Dynamic<UITextField.ViewMode>)
		case leftView(Dynamic<ViewConvertible?>)
		case leftViewMode(Dynamic<UITextField.ViewMode>)
		case rightView(Dynamic<ViewConvertible?>)
		case rightViewMode(Dynamic<UITextField.ViewMode>)
		case inputView(Dynamic<ViewConvertible?>)
		case inputAccessoryView(Dynamic<ViewConvertible?>)
		
		//	2. Signal bindings are performed on the object after construction.
		case resignFirstResponder(Signal<Void>)
		
		//	3. Action bindings are triggered by the object after construction.
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case didBeginEditing((_ textField: UITextField) -> Void)
		case didChange((_ textField: UITextField) -> Void)
		case didEndEditing((_ textField: UITextField) -> Void)
		@available(iOS 10.0, *)
		case didEndEditingWithReason((_ textField: UITextField, _ reason: UITextField.DidEndEditingReason) -> Void)
		case shouldBeginEditing((_ textField: UITextField) -> Bool)
		case shouldEndEditing((_ textField: UITextField) -> Bool)
		case shouldChangeCharacters((_ textField: UITextField, _ range: NSRange, _ replacementString: String) -> Bool)
		case shouldClear((_ textField: UITextField) -> Bool)
		case shouldReturn((_ textField: UITextField) -> Bool)
	}
	
	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = TextField
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		public init() {
			self.init(delegateClass: Delegate.self)
		}
		public init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		public let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		public mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .didEndEditingWithReason(let x):
				if #available(iOS 10.0, *) {
					let s = #selector(UITextFieldDelegate.textFieldDidEndEditing(_:reason:))
					delegate().addSelector(s).didEndEditingWithReason = x
				}
			case .shouldBeginEditing(let x):
				let s = #selector(UITextFieldDelegate.textFieldShouldBeginEditing(_:))
				delegate().addSelector(s).shouldBeginEditing = x
			case .shouldEndEditing(let x):
				let s = #selector(UITextFieldDelegate.textFieldShouldEndEditing(_:))
				delegate().addSelector(s).shouldEndEditing = x
			case .shouldChangeCharacters(let x):
				let s = #selector(UITextFieldDelegate.textField(_:shouldChangeCharactersIn:replacementString:))
				delegate().addSelector(s).shouldChangeCharacters = x
			case .shouldClear(let x):
				let s = #selector(UITextFieldDelegate.textFieldShouldClear(_:))
				delegate().addSelector(s).shouldClear = x
			case .shouldReturn(let x):
				let s = #selector(UITextFieldDelegate.textFieldShouldReturn(_:))
				delegate().addSelector(s).shouldReturn = x
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		public mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
			storage.dynamicDelegate = possibleDelegate
			if storage.inUse {
				instance.delegate = storage
			}
			
			linkedPreparer.prepareInstance(instance, storage: storage)
		}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .textInputTraits(let x):
				return AggregateLifetime(lifetimes: x.value.bindings.lazy.compactMap { trait in
					switch trait {
					case .autocapitalizationType(let y): return y.apply(instance, storage) { i, s, v in i.autocapitalizationType = v }
					case .autocorrectionType(let y): return y.apply(instance, storage) { i, s, v in i.autocorrectionType = v }
					case .spellCheckingType(let y): return y.apply(instance, storage) { i, s, v in i.spellCheckingType = v }
					case .enablesReturnKeyAutomatically(let y): return y.apply(instance, storage) { i, s, v in i.enablesReturnKeyAutomatically = v }
					case .keyboardAppearance(let y): return y.apply(instance, storage) { i, s, v in i.keyboardAppearance = v }
					case .keyboardType(let y): return y.apply(instance, storage) { i, s, v in i.keyboardType = v }
					case .returnKeyType(let y): return y.apply(instance, storage) { i, s, v in i.returnKeyType = v }
					case .isSecureTextEntry(let y): return y.apply(instance, storage) { i, s, v in i.isSecureTextEntry = v }
					case .textContentType(let y):
						return y.apply(instance, storage) { i, s, v in
							if #available(iOS 10.0, *) {
								i.textContentType = v
							}
						}
					case .smartDashesType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartDashesType = v
							}
						}
					case .smartQuotesType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartQuotesType = v
							}
						}
					case .smartInsertDeleteType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartInsertDeleteType = v
							}
						}
					}
				})
			case .text(let x): return x.apply(instance, storage) { i, s, v in i.text = v }
			case .attributedText(let x): return x.apply(instance, storage) { i, s, v in i.attributedText = v }
			case .placeholder(let x): return x.apply(instance, storage) { i, s, v in i.placeholder = v }
			case .attributedPlaceholder(let x): return x.apply(instance, storage) { i, s, v in i.attributedPlaceholder = v }
			case .defaultTextAttributes(let x): return x.apply(instance, storage) { i, s, v in i.defaultTextAttributes = v }
			case .font(let x): return x.apply(instance, storage) { i, s, v in i.font = v }
			case .textColor(let x): return x.apply(instance, storage) { i, s, v in i.textColor = v }
			case .textAlignment(let x): return x.apply(instance, storage) { i, s, v in i.textAlignment = v }
			case .typingAttributes(let x): return x.apply(instance, storage) { i, s, v in i.typingAttributes = v }
			case .adjustsFontSizeToFitWidth(let x): return x.apply(instance, storage) { i, s, v in i.adjustsFontSizeToFitWidth = v }
			case .minimumFontSize(let x): return x.apply(instance, storage) { i, s, v in i.minimumFontSize = v }
			case .clearsOnBeginEditing(let x): return x.apply(instance, storage) { i, s, v in i.clearsOnBeginEditing = v }
			case .clearsOnInsertion(let x): return x.apply(instance, storage) { i, s, v in i.clearsOnInsertion = v }
			case .allowsEditingTextAttributes(let x): return x.apply(instance, storage) { i, s, v in i.allowsEditingTextAttributes = v }
			case .borderStyle(let x): return x.apply(instance, storage) { i, s, v in i.borderStyle = v }
			case .background(let x): return x.apply(instance, storage) { i, s, v in i.background = v }
			case .disabledBackground(let x): return x.apply(instance, storage) { i, s, v in i.disabledBackground = v }
			case .clearButtonMode(let x): return x.apply(instance, storage) { i, s, v in i.clearButtonMode = v }
			case .leftView(let x): return x.apply(instance, storage) { i, s, v in i.leftView = v?.uiView() }
			case .leftViewMode(let x): return x.apply(instance, storage) { i, s, v in i.leftViewMode = v }
			case .rightView(let x): return x.apply(instance, storage) { i, s, v in i.rightView = v?.uiView() }
			case .rightViewMode(let x): return x.apply(instance, storage) { i, s, v in i.rightViewMode = v }
			case .inputView(let x): return x.apply(instance, storage) { i, s, v in i.inputView = v?.uiView() }
			case .inputAccessoryView(let x): return x.apply(instance, storage) { i, s, v in i.inputAccessoryView = v?.uiView() }
			case .resignFirstResponder(let x): return x.apply(instance, storage) { i, s, v in i.resignFirstResponder() }
			case .didBeginEditing(let x):
				return Signal
					.notifications(name: UITextField.textDidBeginEditingNotification, object: instance)
					.compactMap { notification in return notification.object as? UITextField }
					.subscribeValues { field in x(field) }
			case .didEndEditing(let x):
				return Signal
					.notifications(name: UITextField.textDidEndEditingNotification, object: instance)
					.compactMap { notification in return notification.object as? UITextField }
					.subscribeValues { field in x(field) }
			case .didChange(let x):
				return Signal
					.notifications(name: UITextField.textDidChangeNotification, object: instance)
					.compactMap { notification in return notification.object as? UITextField }
					.subscribeValues { field in x(field) }
			case .didEndEditingWithReason: return nil
			case .shouldBeginEditing: return nil
			case .shouldEndEditing: return nil
			case .shouldChangeCharacters: return nil
			case .shouldClear: return nil
			case .shouldReturn: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	open class Storage: Control.Storage, UITextFieldDelegate {}
	
	open class Delegate: DynamicDelegate, UITextFieldDelegate {
		public required override init() {
			super.init()
		}
		
		open var shouldBeginEditing: ((_ textField: UITextField) -> Bool)?
		open func textFieldShouldBeginEditing(_ textField: UITextField) -> Bool {
			return shouldBeginEditing!(textField)
		}
		
		open var shouldEndEditing: ((_ textField: UITextField) -> Bool)?
		open func textFieldShouldEndEditing(_ textField: UITextField) -> Bool {
			return shouldEndEditing!(textField)
		}
		
		open var shouldChangeCharacters: ((_ textField: UITextField, _ range: NSRange, _ replacementString: String) -> Bool)?
		open func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
			return shouldChangeCharacters!(textField, range, string)
		}
		
		open var shouldClear: ((_ textField: UITextField) -> Bool)?
		open func textFieldShouldClear(_ textField: UITextField) -> Bool {
			return shouldClear!(textField)
		}
		
		open var shouldReturn: ((_ textField: UITextField) -> Bool)?
		open func textFieldShouldReturn(_ textField: UITextField) -> Bool {
			return shouldReturn!(textField)
		}
		
		open var didEndEditingWithReason: Any?
		@available(iOS 10.0, *)
		open func textFieldDidEndEditing(_ textField: UITextField, reason: UITextField.DidEndEditingReason) {
			(didEndEditingWithReason as! (UITextField, UITextField.DidEndEditingReason) -> Void)(textField, reason)
		}
	}
}

extension BindingName where Binding: TextFieldBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .textFieldBinding(TextField.Binding.$1(v)) }) }
	public static var textInputTraits: BindingName<Constant<TextInputTraits>, Binding> { return BindingName<Constant<TextInputTraits>, Binding>({ v in .textFieldBinding(TextField.Binding.textInputTraits(v)) }) }
	public static var text: BindingName<Dynamic<String>, Binding> { return BindingName<Dynamic<String>, Binding>({ v in .textFieldBinding(TextField.Binding.text(v)) }) }
	public static var attributedText: BindingName<Dynamic<NSAttributedString?>, Binding> { return BindingName<Dynamic<NSAttributedString?>, Binding>({ v in .textFieldBinding(TextField.Binding.attributedText(v)) }) }
	public static var placeholder: BindingName<Dynamic<String?>, Binding> { return BindingName<Dynamic<String?>, Binding>({ v in .textFieldBinding(TextField.Binding.placeholder(v)) }) }
	public static var attributedPlaceholder: BindingName<Dynamic<NSAttributedString?>, Binding> { return BindingName<Dynamic<NSAttributedString?>, Binding>({ v in .textFieldBinding(TextField.Binding.attributedPlaceholder(v)) }) }
	public static var defaultTextAttributes: BindingName<Dynamic<[NSAttributedString.Key: Any]>, Binding> { return BindingName<Dynamic<[NSAttributedString.Key: Any]>, Binding>({ v in .textFieldBinding(TextField.Binding.defaultTextAttributes(v)) }) }
	public static var font: BindingName<Dynamic<UIFont?>, Binding> { return BindingName<Dynamic<UIFont?>, Binding>({ v in .textFieldBinding(TextField.Binding.font(v)) }) }
	public static var textColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .textFieldBinding(TextField.Binding.textColor(v)) }) }
	public static var textAlignment: BindingName<Dynamic<NSTextAlignment>, Binding> { return BindingName<Dynamic<NSTextAlignment>, Binding>({ v in .textFieldBinding(TextField.Binding.textAlignment(v)) }) }
	public static var typingAttributes: BindingName<Dynamic<[NSAttributedString.Key: Any]?>, Binding> { return BindingName<Dynamic<[NSAttributedString.Key: Any]?>, Binding>({ v in .textFieldBinding(TextField.Binding.typingAttributes(v)) }) }
	public static var adjustsFontSizeToFitWidth: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .textFieldBinding(TextField.Binding.adjustsFontSizeToFitWidth(v)) }) }
	public static var minimumFontSize: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .textFieldBinding(TextField.Binding.minimumFontSize(v)) }) }
	public static var clearsOnBeginEditing: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .textFieldBinding(TextField.Binding.clearsOnBeginEditing(v)) }) }
	public static var clearsOnInsertion: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .textFieldBinding(TextField.Binding.clearsOnInsertion(v)) }) }
	public static var allowsEditingTextAttributes: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .textFieldBinding(TextField.Binding.allowsEditingTextAttributes(v)) }) }
	public static var borderStyle: BindingName<Dynamic<UITextField.BorderStyle>, Binding> { return BindingName<Dynamic<UITextField.BorderStyle>, Binding>({ v in .textFieldBinding(TextField.Binding.borderStyle(v)) }) }
	public static var background: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .textFieldBinding(TextField.Binding.background(v)) }) }
	public static var disabledBackground: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .textFieldBinding(TextField.Binding.disabledBackground(v)) }) }
	public static var clearButtonMode: BindingName<Dynamic<UITextField.ViewMode>, Binding> { return BindingName<Dynamic<UITextField.ViewMode>, Binding>({ v in .textFieldBinding(TextField.Binding.clearButtonMode(v)) }) }
	public static var leftView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .textFieldBinding(TextField.Binding.leftView(v)) }) }
	public static var leftViewMode: BindingName<Dynamic<UITextField.ViewMode>, Binding> { return BindingName<Dynamic<UITextField.ViewMode>, Binding>({ v in .textFieldBinding(TextField.Binding.leftViewMode(v)) }) }
	public static var rightView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .textFieldBinding(TextField.Binding.rightView(v)) }) }
	public static var rightViewMode: BindingName<Dynamic<UITextField.ViewMode>, Binding> { return BindingName<Dynamic<UITextField.ViewMode>, Binding>({ v in .textFieldBinding(TextField.Binding.rightViewMode(v)) }) }
	public static var inputView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .textFieldBinding(TextField.Binding.inputView(v)) }) }
	public static var inputAccessoryView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .textFieldBinding(TextField.Binding.inputAccessoryView(v)) }) }
	public static var resignFirstResponder: BindingName<Signal<Void>, Binding> { return BindingName<Signal<Void>, Binding>({ v in .textFieldBinding(TextField.Binding.resignFirstResponder(v)) }) }
	public static var didBeginEditing: BindingName<(_ textField: UITextField) -> Void, Binding> { return BindingName<(_ textField: UITextField) -> Void, Binding>({ v in .textFieldBinding(TextField.Binding.didBeginEditing(v)) }) }
	public static var didChange: BindingName<(_ textField: UITextField) -> Void, Binding> { return BindingName<(_ textField: UITextField) -> Void, Binding>({ v in .textFieldBinding(TextField.Binding.didChange(v)) }) }
	public static var didEndEditing: BindingName<(_ textField: UITextField) -> Void, Binding> { return BindingName<(_ textField: UITextField) -> Void, Binding>({ v in .textFieldBinding(TextField.Binding.didEndEditing(v)) }) }
	@available(iOS 10.0, *)
	public static var didEndEditingWithReason: BindingName<(_ textField: UITextField, _ reason: UITextField.DidEndEditingReason) -> Void, Binding> { return BindingName<(_ textField: UITextField, _ reason: UITextField.DidEndEditingReason) -> Void, Binding>({ v in .textFieldBinding(TextField.Binding.didEndEditingWithReason(v)) }) }
	public static var shouldBeginEditing: BindingName<(_ textField: UITextField) -> Bool, Binding> { return BindingName<(_ textField: UITextField) -> Bool, Binding>({ v in .textFieldBinding(TextField.Binding.shouldBeginEditing(v)) }) }
	public static var shouldEndEditing: BindingName<(_ textField: UITextField) -> Bool, Binding> { return BindingName<(_ textField: UITextField) -> Bool, Binding>({ v in .textFieldBinding(TextField.Binding.shouldEndEditing(v)) }) }
	public static var shouldChangeCharacters: BindingName<(_ textField: UITextField, _ range: NSRange, _ replacementString: String) -> Bool, Binding> { return BindingName<(_ textField: UITextField, _ range: NSRange, _ replacementString: String) -> Bool, Binding>({ v in .textFieldBinding(TextField.Binding.shouldChangeCharacters(v)) }) }
	public static var shouldClear: BindingName<(_ textField: UITextField) -> Bool, Binding> { return BindingName<(_ textField: UITextField) -> Bool, Binding>({ v in .textFieldBinding(TextField.Binding.shouldClear(v)) }) }
	public static var shouldReturn: BindingName<(_ textField: UITextField) -> Bool, Binding> { return BindingName<(_ textField: UITextField) -> Bool, Binding>({ v in .textFieldBinding(TextField.Binding.shouldReturn(v)) }) }
}

extension BindingName where Binding: TextFieldBinding {
	// Additional helper binding names
	public static var textChanged: BindingName<SignalInput<String>, Binding> {
		return BindingName<SignalInput<String>, Binding>({ v in .textFieldBinding(TextField.Binding.didChange { textField in if let t = textField.text { v.send(value: t) } }) })
	}
	public static var attributedTextChanged: BindingName<SignalInput<NSAttributedString>, Binding> {
		return BindingName<SignalInput<NSAttributedString>, Binding>({ v in .textFieldBinding(TextField.Binding.didChange { textField in if let t = textField.attributedText { v.send(value: t) } }) })
	}
}

public protocol TextFieldConvertible: ControlConvertible {
	func uiTextField() -> TextField.Instance
}
extension TextFieldConvertible {
	public func uiControl() -> Control.Instance { return uiTextField() }
}
extension TextField.Instance: TextFieldConvertible {
	public func uiTextField() -> TextField.Instance { return self }
}

public protocol TextFieldBinding: ControlBinding {
	static func textFieldBinding(_ binding: TextField.Binding) -> Self
}
extension TextFieldBinding {
	public static func controlBinding(_ binding: Control.Binding) -> Self {
		return textFieldBinding(.inheritedBinding(binding))
	}
}

public func textFieldResignOnReturn(condition: @escaping (UITextField) -> Bool = { _ in return true }) -> (UITextField) -> Bool {
	return { tf in
		if condition(tf) {
			tf.resignFirstResponder()
			return false
		}
		return true
	}
}

public class SwipeGestureRecognizer: ConstructingBinder, SwipeGestureRecognizerConvertible {
	public typealias Instance = UISwipeGestureRecognizer
	public typealias Inherited = GestureRecognizer
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiSwipeGestureRecognizer() -> Instance { return instance() }
	
	public enum Binding: SwipeGestureRecognizerBinding {
		public typealias EnclosingBinder = SwipeGestureRecognizer
		public static func swipeGestureRecognizerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case direction(Dynamic<UISwipeGestureRecognizer.Direction>)
		case numberOfTouchesRequired(Dynamic<Int>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = SwipeGestureRecognizer
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		public init() {}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .direction(let x): return x.apply(instance, storage) { i, s, v in i.direction = v }
			case .numberOfTouchesRequired(let x): return x.apply(instance, storage) { i, s, v in i.numberOfTouchesRequired = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	public typealias Storage = GestureRecognizer.Storage
}

extension BindingName where Binding: SwipeGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .swipeGestureRecognizerBinding(SwipeGestureRecognizer.Binding.$1(v)) }) }
	public static var direction: BindingName<Dynamic<UISwipeGestureRecognizer.Direction>, Binding> { return BindingName<Dynamic<UISwipeGestureRecognizer.Direction>, Binding>({ v in .swipeGestureRecognizerBinding(SwipeGestureRecognizer.Binding.direction(v)) }) }
	public static var numberOfTouchesRequired: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .swipeGestureRecognizerBinding(SwipeGestureRecognizer.Binding.numberOfTouchesRequired(v)) }) }
}

public protocol SwipeGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiSwipeGestureRecognizer() -> SwipeGestureRecognizer.Instance
}
extension SwipeGestureRecognizerConvertible {
	public func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiSwipeGestureRecognizer() }
}
extension SwipeGestureRecognizer.Instance: SwipeGestureRecognizerConvertible {
	public func uiSwipeGestureRecognizer() -> SwipeGestureRecognizer.Instance { return self }
}

public protocol SwipeGestureRecognizerBinding: GestureRecognizerBinding {
	static func swipeGestureRecognizerBinding(_ binding: SwipeGestureRecognizer.Binding) -> Self
}
extension SwipeGestureRecognizerBinding {
	public static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return swipeGestureRecognizerBinding(.inheritedBinding(binding))
	}
}

/// A value abstraction of the arguments to some AppKit/UIKit methods with a `setValue(_:,animated:)` structure.
public struct SetOrAnimate<Value> {
	public let value: Value
	public let isAnimated: Bool
	
	public static func set(_ value: Value) -> SetOrAnimate<Value> {
		return SetOrAnimate<Value>(value: value, isAnimated: false)
	}
	public static func animate(_ value: Value) -> SetOrAnimate<Value> {
		return SetOrAnimate<Value>(value: value, isAnimated: true)
	}
}

extension SignalInterface {
	/// A signal transformation which wraps the output in `SetOrAnimate` with the first value as in `set` but subsequent values as in `animate`
	public func animate(_ choice: AnimationChoice = .subsequent) -> Signal<SetOrAnimate<OutputValue>> {
		return map(initialState: false) { (alreadyReceived: inout Bool, value: OutputValue) in
			if alreadyReceived || choice == .all {
				return .animate(value)
			} else {
				if choice == .subsequent {
					alreadyReceived = true
				}
				return .set(value)
			}
		}
	}
}

/// This is currently used in PageViewController but I feel like it should replace SetOrAnimate and possibly the animation in TableRowMution, too.
public struct SetAnimatable<Value, Animation> {
	public let value: Value
	public let animation: Animation?
	
	public static func set(_ value: Value) -> SetAnimatable<Value, Animation> {
		return SetAnimatable<Value, Animation>(value: value, animation: nil)
	}
	public static func animate(_ value: Value, animation: Animation) -> SetAnimatable<Value, Animation> {
		return SetAnimatable<Value, Animation>(value: value, animation: animation)
	}
}


public class TapGestureRecognizer: ConstructingBinder, TapGestureRecognizerConvertible {
	public typealias Instance = UITapGestureRecognizer
	public typealias Inherited = GestureRecognizer
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiTapGestureRecognizer() -> Instance { return instance() }
	
	public enum Binding: TapGestureRecognizerBinding {
		public typealias EnclosingBinder = TapGestureRecognizer
		public static func tapGestureRecognizerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case numberOfTapsRequired(Dynamic<Int>)
		case numberOfTouchesRequired(Dynamic<Int>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = TapGestureRecognizer
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		public init() {}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .numberOfTapsRequired(let x): return x.apply(instance, storage) { i, s, v in i.numberOfTapsRequired = v }
			case .numberOfTouchesRequired(let x): return x.apply(instance, storage) { i, s, v in i.numberOfTouchesRequired = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	public typealias Storage = GestureRecognizer.Storage
}

extension BindingName where Binding: TapGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .tapGestureRecognizerBinding(TapGestureRecognizer.Binding.$1(v)) }) }
	public static var numberOfTapsRequired: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .tapGestureRecognizerBinding(TapGestureRecognizer.Binding.numberOfTapsRequired(v)) }) }
	public static var numberOfTouchesRequired: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .tapGestureRecognizerBinding(TapGestureRecognizer.Binding.numberOfTouchesRequired(v)) }) }
}

public protocol TapGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiTapGestureRecognizer() -> TapGestureRecognizer.Instance
}
extension TapGestureRecognizerConvertible {
	public func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiTapGestureRecognizer() }
}
extension TapGestureRecognizer.Instance: TapGestureRecognizerConvertible {
	public func uiTapGestureRecognizer() -> TapGestureRecognizer.Instance { return self }
}

public protocol TapGestureRecognizerBinding: GestureRecognizerBinding {
	static func tapGestureRecognizerBinding(_ binding: TapGestureRecognizer.Binding) -> Self
}
extension TapGestureRecognizerBinding {
	public static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return tapGestureRecognizerBinding(.inheritedBinding(binding))
	}
}

public class BarItem: ConstructingBinder, BarItemConvertible {
	public typealias Instance = UIBarItem
	public typealias Inherited = BaseBinder
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiBarItem() -> Instance { return instance() }
	
	public enum Binding: BarItemBinding {
		public typealias EnclosingBinder = BarItem
		public static func barItemBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case isEnabled(Dynamic<Bool>)
		case image(Dynamic<UIImage?>)
		case landscapeImagePhone(Dynamic<UIImage?>)
		case imageInsets(Dynamic<UIEdgeInsets>)
		case landscapeImagePhoneInsets(Dynamic<UIEdgeInsets>)
		case title(Dynamic<String>)
		case tag(Dynamic<Int>)
		case titleTextAttributes(Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]>>)

		//	2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}

	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = BarItem
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		public init() {}

		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .isEnabled(let x): return x.apply(instance, storage) { i, s, v in i.isEnabled = v }
			case .image(let x): return x.apply(instance, storage) { i, s, v in i.image = v }
			case .landscapeImagePhone(let x): return x.apply(instance, storage) { i, s, v in i.landscapeImagePhone = v }
			case .imageInsets(let x): return x.apply(instance, storage) { i, s, v in i.imageInsets = v }
			case .landscapeImagePhoneInsets(let x): return x.apply(instance, storage) { i, s, v in i.landscapeImagePhoneInsets = v }
			case .title(let x): return x.apply(instance, storage) { i, s, v in i.title = v }
			case .tag(let x): return x.apply(instance, storage) { i, s, v in i.tag = v }
			case .titleTextAttributes(let x):
				var previous: ScopedValues<UIControl.State, [NSAttributedString.Key: Any]>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setTitleTextAttributes([:], for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setTitleTextAttributes(c.1, for: c.0)
					}
				}
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: (), storage: ())
			}
		}
	}

	public typealias Storage = ObjectBinderStorage
}

extension BindingName where Binding: BarItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .barItemBinding(BarItem.Binding.$1(v)) }) }
	public static var isEnabled: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .barItemBinding(BarItem.Binding.isEnabled(v)) }) }
	public static var image: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .barItemBinding(BarItem.Binding.image(v)) }) }
	public static var landscapeImagePhone: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .barItemBinding(BarItem.Binding.landscapeImagePhone(v)) }) }
	public static var imageInsets: BindingName<Dynamic<UIEdgeInsets>, Binding> { return BindingName<Dynamic<UIEdgeInsets>, Binding>({ v in .barItemBinding(BarItem.Binding.imageInsets(v)) }) }
	public static var landscapeImagePhoneInsets: BindingName<Dynamic<UIEdgeInsets>, Binding> { return BindingName<Dynamic<UIEdgeInsets>, Binding>({ v in .barItemBinding(BarItem.Binding.landscapeImagePhoneInsets(v)) }) }
	public static var title: BindingName<Dynamic<String>, Binding> { return BindingName<Dynamic<String>, Binding>({ v in .barItemBinding(BarItem.Binding.title(v)) }) }
	public static var tag: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .barItemBinding(BarItem.Binding.tag(v)) }) }
	public static var titleTextAttributes: BindingName<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]>>, Binding>({ v in .barItemBinding(BarItem.Binding.titleTextAttributes(v)) }) }
}

public protocol BarItemConvertible {
	func uiBarItem() -> BarItem.Instance
}
extension BarItem.Instance: BarItemConvertible {
	public func uiBarItem() -> BarItem.Instance { return self }
}

public protocol BarItemBinding: BaseBinding {
	static func barItemBinding(_ binding: BarItem.Binding) -> Self
}
extension BarItemBinding {
	public static func baseBinding(_ binding: BaseBinder.Binding) -> Self {
		return barItemBinding(.inheritedBinding(binding))
	}
}

public class NavigationController: ConstructingBinder, NavigationControllerConvertible {
	public typealias Instance = UINavigationController
	public typealias Inherited = ViewController
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiNavigationController() -> Instance { return instance() }
	
	public enum Binding: NavigationControllerBinding {
		public typealias EnclosingBinder = NavigationController
		public static func navigationControllerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case navigationBar(Constant<NavigationBar>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case stack(Dynamic<StackMutation<ViewControllerConvertible>>)
		case supportedInterfaceOrientations(Dynamic<UIInterfaceOrientationMask>)
		case preferredInterfaceOrientation(Dynamic<UIInterfaceOrientation>)
		case isNavigationBarHidden(Dynamic<SetOrAnimate<Bool>>)
		case isToolbarHidden(Dynamic<SetOrAnimate<Bool>>)
		case hidesBarsOnTap(Dynamic<Bool>)
		case hidesBarsOnSwipe(Dynamic<Bool>)
		case hidesBarsWhenVerticallyCompact(Dynamic<Bool>)
		case hidesBarsWhenKeyboardAppears(Dynamic<Bool>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		case poppedToCount(SignalInput<Int>)
		case willShow(SignalInput<(viewController: UIViewController, animated: Bool)>)
		case didShow(SignalInput<(viewController: UIViewController, animated: Bool)>)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case animationController((_ navigationController: UINavigationController, _ operation: UINavigationController.Operation, _ from: UIViewController, _ to: UIViewController) -> UIViewControllerAnimatedTransitioning?)
		case interactionController((_ navigationController: UINavigationController, _ animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?)
	}

	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = NavigationController
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage(popSignal: popSignal) }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init(nibName: nil, bundle: nil) }
		
		public init() {
			self.init(delegateClass: NavigationControllerDelegate.self)
		}
		public init<Value>(delegateClass: Value.Type) where Value: NavigationControllerDelegate {
			self.delegateClass = delegateClass
		}
		public let delegateClass: NavigationControllerDelegate.Type
		var possibleDelegate: NavigationControllerDelegate? = nil
		mutating func delegate() -> NavigationControllerDelegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		var popSignal: SignalInput<Int>? = nil
		
		public mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .poppedToCount(let x): popSignal = x
			case .supportedInterfaceOrientations:
				delegate().addSelector(#selector(UINavigationControllerDelegate.navigationControllerSupportedInterfaceOrientations(_:)))
			case .preferredInterfaceOrientation:
				delegate().addSelector(#selector(UINavigationControllerDelegate.navigationControllerPreferredInterfaceOrientationForPresentation(_:)))
			case .animationController(let x):
				let s = #selector(UINavigationControllerDelegate.navigationController(_:animationControllerFor:from:to:))
				delegate().addSelector(s).animationController = x
			case .interactionController(let x):
				let s = #selector(UINavigationControllerDelegate.navigationController(_:interactionControllerFor:))
				delegate().addSelector(s).interactionController = x
			case .willShow:
				let s = #selector(UINavigationControllerDelegate.navigationController(_:willShow:animated:))
				delegate().addSelector(s)
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		public mutating func prepareInstance(_ instance: UINavigationController, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
			storage.dynamicDelegate = possibleDelegate
			instance.delegate = storage
			
			linkedPreparer.prepareInstance(instance, storage: storage)
		}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .navigationBar(let x):
				x.value.applyBindings(to: instance.navigationBar)
				return nil
			case .stack(let x):
				return x.apply(instance, storage) { i, s, v in
					switch v {
					case .push(let e):
						s.expectedStackCount += 1
						i.pushViewController(e.uiViewController(), animated: true)
					case .pop:
						s.expectedStackCount -= 1
						i.popViewController(animated: true)
					case .popToCount(let c):
						s.expectedStackCount = c
						i.popToViewController(i.viewControllers[c - 1], animated: true)
					case .reload(let newStack):
						s.expectedStackCount = newStack.count
						i.setViewControllers(newStack.map { $0.uiViewController() }, animated: false)
					}
				}
			case .isNavigationBarHidden(let x): return x.apply(instance, storage) { i, s, v in i.setNavigationBarHidden(v.value, animated: v.isAnimated) }
			case .isToolbarHidden(let x): return x.apply(instance, storage) { i, s, v in i.setToolbarHidden(v.value, animated: v.isAnimated) }
			case .hidesBarsOnTap(let x): return x.apply(instance, storage) { i, s, v in i.hidesBarsOnTap = v }
			case .hidesBarsOnSwipe(let x): return x.apply(instance, storage) { i, s, v in i.hidesBarsOnSwipe = v }
			case .hidesBarsWhenVerticallyCompact(let x): return x.apply(instance, storage) { i, s, v in i.hidesBarsWhenVerticallyCompact = v }
			case .hidesBarsWhenKeyboardAppears(let x): return x.apply(instance, storage) { i, s, v in i.hidesBarsWhenKeyboardAppears = v }
			case .supportedInterfaceOrientations: return nil
			case .preferredInterfaceOrientation: return nil
			case .didShow(let x):
				storage.didShow = x
				return nil
			case .willShow: return nil
			case .animationController: return nil
			case .interactionController: return nil
			case .poppedToCount: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}

	open class Storage: ViewController.Storage, UINavigationControllerDelegate {
		open var supportedInterfaceOrientations: UIInterfaceOrientationMask = .all
		open var preferredInterfaceOrientation: UIInterfaceOrientation = .portrait
		open var expectedStackCount: Int = 0
		public let popSignal: SignalInput<Int>?
		weak var collapsedController: UINavigationController?
		
		open override var inUse: Bool {
			return true
		}
		
		public init(popSignal: SignalInput<Int>?) {
			self.popSignal = popSignal
			super.init()
		}
		
		open var didShow: SignalInput<(viewController: UIViewController, animated: Bool)>?
		public func navigationController(_ navigationController: UINavigationController, didShow viewController: UIViewController, animated: Bool) {
			// Handle pop operations triggered by the back button
			if animated, navigationController.viewControllers.count < expectedStackCount, let ps = popSignal {
				ps.send(value: navigationController.viewControllers.count)
			}
			
			// Handle removal of collapsed split view details
			if animated, navigationController.viewControllers.count == expectedStackCount, let collapsed = collapsedController, let splitViewStorage = navigationController.splitViewController?.getBinderStorage(type: SplitViewController.Storage.self) {
				collapsedController = nil
				splitViewStorage.collapsedController(collapsed)
			}
			
			// Track when a collapsed split view is added
			if navigationController.viewControllers.count == expectedStackCount + 1, let collapsed = navigationController.viewControllers.last as? UINavigationController {
				collapsedController = collapsed
			}
			
			didShow?.send(value: (viewController: viewController, animated: animated))
		}
	}
}

open class NavigationControllerDelegate: DynamicDelegate, UINavigationControllerDelegate {
	public required override init() {
		super.init()
	}
	
	open var willShow: ((UIViewController, Bool) -> Void)?
	open func navigationController(_ navigationController: UINavigationController, willShow viewController: UIViewController, animated: Bool) {
		return willShow!(viewController, animated)
	}
	
	open var supportedInterfaceOrientations: (() -> UIInterfaceOrientationMask)?
	open func navigationControllerSupportedInterfaceOrientations(_ navigationController: UINavigationController) -> UIInterfaceOrientationMask {
		return supportedInterfaceOrientations!()
	}
	
	open var preferredInterfaceOrientationForPresentation: (() -> UIInterfaceOrientation)?
	open func navigationControllerPreferredInterfaceOrientationForPresentation(_ navigationController: UINavigationController) -> UIInterfaceOrientation {
		return preferredInterfaceOrientationForPresentation!()
	}
	
	open var animationController: ((_ navigationController: UINavigationController, _ operation: UINavigationController.Operation, _ from: UIViewController, _ to: UIViewController) -> UIViewControllerAnimatedTransitioning?)?
	open func navigationController(_ navigationController: UINavigationController, animationControllerFor operation: UINavigationController.Operation, from fromVC: UIViewController, to toVC: UIViewController) -> UIViewControllerAnimatedTransitioning? {
		return animationController!(navigationController, operation, fromVC, toVC)
	}
	
	open var interactionController: ((_ navigationController: UINavigationController, _ animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?)?
	open func navigationController(_ navigationController: UINavigationController, interactionControllerFor animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?
	{
		return interactionController!(navigationController, animationController)
	}
}

extension BindingName where Binding: NavigationControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.$1(v)) }) }
	public static var navigationBar: BindingName<Constant<NavigationBar>, Binding> { return BindingName<Constant<NavigationBar>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.navigationBar(v)) }) }
	public static var stack: BindingName<Dynamic<StackMutation<ViewControllerConvertible>>, Binding> { return BindingName<Dynamic<StackMutation<ViewControllerConvertible>>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.stack(v)) }) }
	public static var supportedInterfaceOrientations: BindingName<Dynamic<UIInterfaceOrientationMask>, Binding> { return BindingName<Dynamic<UIInterfaceOrientationMask>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.supportedInterfaceOrientations(v)) }) }
	public static var preferredInterfaceOrientation: BindingName<Dynamic<UIInterfaceOrientation>, Binding> { return BindingName<Dynamic<UIInterfaceOrientation>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.preferredInterfaceOrientation(v)) }) }
	public static var isNavigationBarHidden: BindingName<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingName<Dynamic<SetOrAnimate<Bool>>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.isNavigationBarHidden(v)) }) }
	public static var isToolbarHidden: BindingName<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingName<Dynamic<SetOrAnimate<Bool>>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.isToolbarHidden(v)) }) }
	public static var hidesBarsOnTap: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.hidesBarsOnTap(v)) }) }
	public static var hidesBarsOnSwipe: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.hidesBarsOnSwipe(v)) }) }
	public static var hidesBarsWhenVerticallyCompact: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.hidesBarsWhenVerticallyCompact(v)) }) }
	public static var hidesBarsWhenKeyboardAppears: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.hidesBarsWhenKeyboardAppears(v)) }) }
	public static var poppedToCount: BindingName<SignalInput<Int>, Binding> { return BindingName<SignalInput<Int>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.poppedToCount(v)) }) }
	public static var willShow: BindingName<SignalInput<(viewController: UIViewController, animated: Bool)>, Binding> { return BindingName<SignalInput<(viewController: UIViewController, animated: Bool)>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.willShow(v)) }) }
	public static var didShow: BindingName<SignalInput<(viewController: UIViewController, animated: Bool)>, Binding> { return BindingName<SignalInput<(viewController: UIViewController, animated: Bool)>, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.didShow(v)) }) }
	public static var animationController: BindingName<(_ navigationController: UINavigationController, _ operation: UINavigationController.Operation, _ from: UIViewController, _ to: UIViewController) -> UIViewControllerAnimatedTransitioning?, Binding> { return BindingName<(_ navigationController: UINavigationController, _ operation: UINavigationController.Operation, _ from: UIViewController, _ to: UIViewController) -> UIViewControllerAnimatedTransitioning?, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.animationController(v)) }) }
	public static var interactionController: BindingName<(_ navigationController: UINavigationController, _ animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?, Binding> { return BindingName<(_ navigationController: UINavigationController, _ animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?, Binding>({ v in .navigationControllerBinding(NavigationController.Binding.interactionController(v)) }) }
}

public protocol NavigationControllerConvertible: ViewControllerConvertible {
	func uiNavigationController() -> NavigationController.Instance
}
extension NavigationControllerConvertible {
	public func uiViewController() -> ViewController.Instance { return uiNavigationController() }
}
extension NavigationController.Instance: NavigationControllerConvertible {
	public func uiNavigationController() -> NavigationController.Instance { return self }
}

public protocol NavigationControllerBinding: ViewControllerBinding {
	static func navigationControllerBinding(_ binding: NavigationController.Binding) -> Self
}
extension NavigationControllerBinding {
	public static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return navigationControllerBinding(.inheritedBinding(binding))
	}
}

public class View: ConstructingBinder, ViewConvertible {
	public typealias Instance = UIView
	public typealias Inherited = BaseBinder
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiView() -> Instance { return instance() }

	public enum Binding: ViewBinding {
		public typealias EnclosingBinder = View
		public static func viewBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case layer(Constant<BackingLayer>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case layout(Dynamic<Layout>)
		case backgroundColor(Dynamic<(UIColor?)>)
		case isHidden(Dynamic<(Bool)>)
		case alpha(Dynamic<(CGFloat)>)
		case isOpaque(Dynamic<(Bool)>)
		case tintColor(Dynamic<(UIColor)>)
		case tintAdjustmentMode(Dynamic<(UIView.TintAdjustmentMode)>)
		case clipsToBounds(Dynamic<(Bool)>)
		case clearsContextBeforeDrawing(Dynamic<(Bool)>)
		case mask(Dynamic<(ViewConvertible?)>)
		case isUserInteractionEnabled(Dynamic<(Bool)>)
		case isMultipleTouchEnabled(Dynamic<(Bool)>)
		case isExclusiveTouch(Dynamic<(Bool)>)
		case contentMode(Dynamic<(UIView.ContentMode)>)
		case horizontalContentCompressionResistancePriority(Dynamic<UILayoutPriority>)
		case verticalContentCompressionResistancePriority(Dynamic<UILayoutPriority>)
		case horizontalContentHuggingPriority(Dynamic<UILayoutPriority>)
		case verticalContentHuggingPriority(Dynamic<UILayoutPriority>)
		case semanticContentAttribute(Dynamic<(UISemanticContentAttribute)>)
		case layoutMargins(Dynamic<(UIEdgeInsets)>)
		case preservesSuperviewLayoutMargins(Dynamic<(Bool)>)
		case gestureRecognizers(Dynamic<[UIGestureRecognizer]>)
		case motionEffects(Dynamic<([UIMotionEffect])>)
		case tag(Dynamic<Int>)
		case restorationIdentifier(Dynamic<String?>)

		// 2. Signal bindings are performed on the object after construction.
		case endEditing(Signal<Bool>)
		case becomeFirstResponder(Signal<Void>)
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}

	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = View
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init(frame: CGRect.zero) }
		
		public init() {}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .layer(let x):
				x.value.applyBindings(to: instance.layer)
				return nil
			case .layout(let x):
				return x.apply(instance, storage) { i, s, v in
					instance.applyLayout(v)
				}
			case .backgroundColor(let x): return x.apply(instance, storage) { i, s, v in i.backgroundColor = v }
			case .isHidden(let x): return x.apply(instance, storage) { i, s, v in i.isHidden = v }
			case .alpha(let x): return x.apply(instance, storage) { i, s, v in i.alpha = v }
			case .isOpaque(let x): return x.apply(instance, storage) { i, s, v in i.isOpaque = v }
			case .tintColor(let x): return x.apply(instance, storage) { i, s, v in i.tintColor = v }
			case .tintAdjustmentMode(let x): return x.apply(instance, storage) { i, s, v in i.tintAdjustmentMode = v }
			case .clipsToBounds(let x): return x.apply(instance, storage) { i, s, v in i.clipsToBounds = v }
			case .clearsContextBeforeDrawing(let x): return x.apply(instance, storage) { i, s, v in i.clearsContextBeforeDrawing = v }
			case .mask(let x): return x.apply(instance, storage) { i, s, v in i.mask = v?.uiView() }
			case .isUserInteractionEnabled(let x): return x.apply(instance, storage) { i, s, v in i.isUserInteractionEnabled = v }
			case .isMultipleTouchEnabled(let x): return x.apply(instance, storage) { i, s, v in i.isMultipleTouchEnabled = v }
			case .isExclusiveTouch(let x): return x.apply(instance, storage) { i, s, v in i.isExclusiveTouch = v }
			case .restorationIdentifier(let x): return x.apply(instance, storage) { i, s, v in i.restorationIdentifier = v }
			case .contentMode(let x): return x.apply(instance, storage) { i, s, v in i.contentMode = v }
			case .horizontalContentCompressionResistancePriority(let x): return x.apply(instance, storage) { i, s, v in i.setContentCompressionResistancePriority(v, for: NSLayoutConstraint.Axis.horizontal) }
			case .verticalContentCompressionResistancePriority(let x): return x.apply(instance, storage) { i, s, v in i.setContentCompressionResistancePriority(v, for: NSLayoutConstraint.Axis.vertical) }
			case .horizontalContentHuggingPriority(let x): return x.apply(instance, storage) { i, s, v in i.setContentHuggingPriority(v, for: NSLayoutConstraint.Axis.horizontal) }
			case .verticalContentHuggingPriority(let x): return x.apply(instance, storage) { i, s, v in i.setContentHuggingPriority(v, for: NSLayoutConstraint.Axis.vertical) }
			case .semanticContentAttribute(let x): return x.apply(instance, storage) { i, s, v in i.semanticContentAttribute = v }
			case .layoutMargins(let x): return x.apply(instance, storage) { i, s, v in i.layoutMargins = v }
			case .preservesSuperviewLayoutMargins(let x): return x.apply(instance, storage) { i, s, v in i.preservesSuperviewLayoutMargins = v }
			case .gestureRecognizers(let x): return x.apply(instance, storage) { i, s, v in i.gestureRecognizers = v }
			case .motionEffects(let x): return x.apply(instance, storage) { i, s, v in i.motionEffects = v }
			case .tag(let x): return x.apply(instance, storage) { i, s, v in i.tag = v }
			case .endEditing(let x): return x.apply(instance, storage) { i, s, v in i.endEditing(v) }
			case .becomeFirstResponder(let x): return x.apply(instance, storage) { i, s, v in i.becomeFirstResponder() }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: (), storage: ())
			}
		}
	}

	public typealias Storage = ObjectBinderStorage
}

extension BindingName where Binding: ViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .viewBinding(View.Binding.$1(v)) }) }
	public static var layer: BindingName<Constant<BackingLayer>, Binding> { return BindingName<Constant<BackingLayer>, Binding>({ v in .viewBinding(View.Binding.layer(v)) }) }
	public static var layout: BindingName<Dynamic<Layout>, Binding> { return BindingName<Dynamic<Layout>, Binding>({ v in .viewBinding(View.Binding.layout(v)) }) }
	public static var backgroundColor: BindingName<Dynamic<(UIColor?)>, Binding> { return BindingName<Dynamic<(UIColor?)>, Binding>({ v in .viewBinding(View.Binding.backgroundColor(v)) }) }
	public static var isHidden: BindingName<Dynamic<(Bool)>, Binding> { return BindingName<Dynamic<(Bool)>, Binding>({ v in .viewBinding(View.Binding.isHidden(v)) }) }
	public static var alpha: BindingName<Dynamic<(CGFloat)>, Binding> { return BindingName<Dynamic<(CGFloat)>, Binding>({ v in .viewBinding(View.Binding.alpha(v)) }) }
	public static var isOpaque: BindingName<Dynamic<(Bool)>, Binding> { return BindingName<Dynamic<(Bool)>, Binding>({ v in .viewBinding(View.Binding.isOpaque(v)) }) }
	public static var tintColor: BindingName<Dynamic<(UIColor)>, Binding> { return BindingName<Dynamic<(UIColor)>, Binding>({ v in .viewBinding(View.Binding.tintColor(v)) }) }
	public static var tintAdjustmentMode: BindingName<Dynamic<(UIView.TintAdjustmentMode)>, Binding> { return BindingName<Dynamic<(UIView.TintAdjustmentMode)>, Binding>({ v in .viewBinding(View.Binding.tintAdjustmentMode(v)) }) }
	public static var clipsToBounds: BindingName<Dynamic<(Bool)>, Binding> { return BindingName<Dynamic<(Bool)>, Binding>({ v in .viewBinding(View.Binding.clipsToBounds(v)) }) }
	public static var clearsContextBeforeDrawing: BindingName<Dynamic<(Bool)>, Binding> { return BindingName<Dynamic<(Bool)>, Binding>({ v in .viewBinding(View.Binding.clearsContextBeforeDrawing(v)) }) }
	public static var mask: BindingName<Dynamic<(ViewConvertible?)>, Binding> { return BindingName<Dynamic<(ViewConvertible?)>, Binding>({ v in .viewBinding(View.Binding.mask(v)) }) }
	public static var isUserInteractionEnabled: BindingName<Dynamic<(Bool)>, Binding> { return BindingName<Dynamic<(Bool)>, Binding>({ v in .viewBinding(View.Binding.isUserInteractionEnabled(v)) }) }
	public static var isMultipleTouchEnabled: BindingName<Dynamic<(Bool)>, Binding> { return BindingName<Dynamic<(Bool)>, Binding>({ v in .viewBinding(View.Binding.isMultipleTouchEnabled(v)) }) }
	public static var isExclusiveTouch: BindingName<Dynamic<(Bool)>, Binding> { return BindingName<Dynamic<(Bool)>, Binding>({ v in .viewBinding(View.Binding.isExclusiveTouch(v)) }) }
	public static var contentMode: BindingName<Dynamic<(UIView.ContentMode)>, Binding> { return BindingName<Dynamic<(UIView.ContentMode)>, Binding>({ v in .viewBinding(View.Binding.contentMode(v)) }) }
	public static var horizontalContentCompressionResistancePriority: BindingName<Dynamic<UILayoutPriority>, Binding> { return BindingName<Dynamic<UILayoutPriority>, Binding>({ v in .viewBinding(View.Binding.horizontalContentCompressionResistancePriority(v)) }) }
	public static var verticalContentCompressionResistancePriority: BindingName<Dynamic<UILayoutPriority>, Binding> { return BindingName<Dynamic<UILayoutPriority>, Binding>({ v in .viewBinding(View.Binding.verticalContentCompressionResistancePriority(v)) }) }
	public static var horizontalContentHuggingPriority: BindingName<Dynamic<UILayoutPriority>, Binding> { return BindingName<Dynamic<UILayoutPriority>, Binding>({ v in .viewBinding(View.Binding.horizontalContentHuggingPriority(v)) }) }
	public static var verticalContentHuggingPriority: BindingName<Dynamic<UILayoutPriority>, Binding> { return BindingName<Dynamic<UILayoutPriority>, Binding>({ v in .viewBinding(View.Binding.verticalContentHuggingPriority(v)) }) }
	public static var semanticContentAttribute: BindingName<Dynamic<(UISemanticContentAttribute)>, Binding> { return BindingName<Dynamic<(UISemanticContentAttribute)>, Binding>({ v in .viewBinding(View.Binding.semanticContentAttribute(v)) }) }
	public static var layoutMargins: BindingName<Dynamic<(UIEdgeInsets)>, Binding> { return BindingName<Dynamic<(UIEdgeInsets)>, Binding>({ v in .viewBinding(View.Binding.layoutMargins(v)) }) }
	public static var preservesSuperviewLayoutMargins: BindingName<Dynamic<(Bool)>, Binding> { return BindingName<Dynamic<(Bool)>, Binding>({ v in .viewBinding(View.Binding.preservesSuperviewLayoutMargins(v)) }) }
	public static var gestureRecognizers: BindingName<Dynamic<[UIGestureRecognizer]>, Binding> { return BindingName<Dynamic<[UIGestureRecognizer]>, Binding>({ v in .viewBinding(View.Binding.gestureRecognizers(v)) }) }
	public static var motionEffects: BindingName<Dynamic<([UIMotionEffect])>, Binding> { return BindingName<Dynamic<([UIMotionEffect])>, Binding>({ v in .viewBinding(View.Binding.motionEffects(v)) }) }
	public static var tag: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .viewBinding(View.Binding.tag(v)) }) }
	public static var restorationIdentifier: BindingName<Dynamic<String?>, Binding> { return BindingName<Dynamic<String?>, Binding>({ v in .viewBinding(View.Binding.restorationIdentifier(v)) }) }
	public static var endEditing: BindingName<Signal<Bool>, Binding> { return BindingName<Signal<Bool>, Binding>({ v in .viewBinding(View.Binding.endEditing(v)) }) }
	public static var becomeFirstResponder: BindingName<Signal<Void>, Binding> { return BindingName<Signal<Void>, Binding>({ v in .viewBinding(View.Binding.becomeFirstResponder(v)) }) }
}

public protocol ViewBinding: BaseBinding {
	static func viewBinding(_ binding: View.Binding) -> Self
}
extension ViewBinding {
	public static func baseBinding(_ binding: BaseBinder.Binding) -> Self {
		return viewBinding(.inheritedBinding(binding))
	}
}


public class Label: ConstructingBinder, LabelConvertible {
	public typealias Instance = UILabel
	public typealias Inherited = View
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiLabel() -> Instance { return instance() }
	
	public enum Binding: LabelBinding {
		public typealias EnclosingBinder = Label
		public static func labelBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case text(Dynamic<String>)
		case attributedText(Dynamic<NSAttributedString?>)
		case font(Dynamic<UIFont>)
		case textColor(Dynamic<UIColor>)
		case textAlignment(Dynamic<NSTextAlignment>)
		case lineBreakMode(Dynamic<NSLineBreakMode>)
		case isEnabled(Dynamic<Bool>)
		case adjustsFontSizeToFitWidth(Dynamic<Bool>)
		case allowsDefaultTighteningForTruncation(Dynamic<Bool>)
		case baselineAdjustment(Dynamic<UIBaselineAdjustment>)
		case minimumScaleFactor(Dynamic<CGFloat>)
		case numberOfLines(Dynamic<Int>)
		case highlightedTextColor(Dynamic<UIColor?>)
		case isHighlighted(Dynamic<Bool>)
		case shadowColor(Dynamic<UIColor?>)
		case shadowOffset(Dynamic<CGSize>)
		case preferredMaxLayoutWidth(Dynamic<CGFloat>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = Label
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		public init() {}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .text(let x): return x.apply(instance, storage) { i, s, v in i.text = v }
			case .attributedText(let x): return x.apply(instance, storage) { i, s, v in i.attributedText = v }
			case .font(let x): return x.apply(instance, storage) { i, s, v in i.font = v }
			case .textColor(let x): return x.apply(instance, storage) { i, s, v in i.textColor = v }
			case .textAlignment(let x): return x.apply(instance, storage) { i, s, v in i.textAlignment = v }
			case .lineBreakMode(let x): return x.apply(instance, storage) { i, s, v in i.lineBreakMode = v }
			case .isEnabled(let x): return x.apply(instance, storage) { i, s, v in i.isEnabled = v }
			case .adjustsFontSizeToFitWidth(let x): return x.apply(instance, storage) { i, s, v in i.adjustsFontSizeToFitWidth = v }
			case .allowsDefaultTighteningForTruncation(let x): return x.apply(instance, storage) { i, s, v in i.allowsDefaultTighteningForTruncation = v }
			case .baselineAdjustment(let x): return x.apply(instance, storage) { i, s, v in i.baselineAdjustment = v }
			case .minimumScaleFactor(let x): return x.apply(instance, storage) { i, s, v in i.minimumScaleFactor = v }
			case .numberOfLines(let x): return x.apply(instance, storage) { i, s, v in i.numberOfLines = v }
			case .highlightedTextColor(let x): return x.apply(instance, storage) { i, s, v in i.highlightedTextColor = v }
			case .isHighlighted(let x): return x.apply(instance, storage) { i, s, v in i.isHighlighted = v }
			case .shadowColor(let x): return x.apply(instance, storage) { i, s, v in i.shadowColor = v }
			case .shadowOffset(let x): return x.apply(instance, storage) { i, s, v in i.shadowOffset = v }
			case .preferredMaxLayoutWidth(let x): return x.apply(instance, storage) { i, s, v in i.preferredMaxLayoutWidth = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	public typealias Storage = View.Storage
}

extension BindingName where Binding: LabelBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .labelBinding(Label.Binding.$1(v)) }) }
	public static var text: BindingName<Dynamic<String>, Binding> { return BindingName<Dynamic<String>, Binding>({ v in .labelBinding(Label.Binding.text(v)) }) }
	public static var attributedText: BindingName<Dynamic<NSAttributedString?>, Binding> { return BindingName<Dynamic<NSAttributedString?>, Binding>({ v in .labelBinding(Label.Binding.attributedText(v)) }) }
	public static var font: BindingName<Dynamic<UIFont>, Binding> { return BindingName<Dynamic<UIFont>, Binding>({ v in .labelBinding(Label.Binding.font(v)) }) }
	public static var textColor: BindingName<Dynamic<UIColor>, Binding> { return BindingName<Dynamic<UIColor>, Binding>({ v in .labelBinding(Label.Binding.textColor(v)) }) }
	public static var textAlignment: BindingName<Dynamic<NSTextAlignment>, Binding> { return BindingName<Dynamic<NSTextAlignment>, Binding>({ v in .labelBinding(Label.Binding.textAlignment(v)) }) }
	public static var lineBreakMode: BindingName<Dynamic<NSLineBreakMode>, Binding> { return BindingName<Dynamic<NSLineBreakMode>, Binding>({ v in .labelBinding(Label.Binding.lineBreakMode(v)) }) }
	public static var isEnabled: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .labelBinding(Label.Binding.isEnabled(v)) }) }
	public static var adjustsFontSizeToFitWidth: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .labelBinding(Label.Binding.adjustsFontSizeToFitWidth(v)) }) }
	public static var allowsDefaultTighteningForTruncation: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .labelBinding(Label.Binding.allowsDefaultTighteningForTruncation(v)) }) }
	public static var baselineAdjustment: BindingName<Dynamic<UIBaselineAdjustment>, Binding> { return BindingName<Dynamic<UIBaselineAdjustment>, Binding>({ v in .labelBinding(Label.Binding.baselineAdjustment(v)) }) }
	public static var minimumScaleFactor: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .labelBinding(Label.Binding.minimumScaleFactor(v)) }) }
	public static var numberOfLines: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .labelBinding(Label.Binding.numberOfLines(v)) }) }
	public static var highlightedTextColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .labelBinding(Label.Binding.highlightedTextColor(v)) }) }
	public static var isHighlighted: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .labelBinding(Label.Binding.isHighlighted(v)) }) }
	public static var shadowColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .labelBinding(Label.Binding.shadowColor(v)) }) }
	public static var shadowOffset: BindingName<Dynamic<CGSize>, Binding> { return BindingName<Dynamic<CGSize>, Binding>({ v in .labelBinding(Label.Binding.shadowOffset(v)) }) }
	public static var preferredMaxLayoutWidth: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .labelBinding(Label.Binding.preferredMaxLayoutWidth(v)) }) }
}

public protocol LabelConvertible: ViewConvertible {
	func uiLabel() -> Label.Instance
}
extension LabelConvertible {
	public func uiView() -> View.Instance { return uiLabel() }
}
extension Label.Instance: LabelConvertible {
	public func uiLabel() -> Label.Instance { return self }
}

public protocol LabelBinding: ViewBinding {
	static func labelBinding(_ binding: Label.Binding) -> Self
}

extension LabelBinding {
	public static func viewBinding(_ binding: View.Binding) -> Self {
		return labelBinding(.inheritedBinding(binding))
	}
}

/// Storage for the string data associated with a `UITableView` section.
public struct TableSectionMetadata {
	public let header: String?
	public let footer: String?
	public init(header: String? = nil, footer: String? = nil) {
		(self.header, self.footer) = (header, footer)
	}
}

/// This data type models the most recent change to a section of a `UITableView`. When used as the `Value` type for a `TableRowMutation`, the combined data type can model all the section, header, footer and row data of an entire `UITableView`.
public struct TableSectionMutation<Value>: ExpressibleByArrayLiteral {
	public let metadata: TableSectionMetadata?
	public let rowMutation: TableRowMutation<Value>

	public init(metadata: TableSectionMetadata?, rowMutation: TableRowMutation<Value>) {
		self.metadata = metadata
		self.rowMutation = rowMutation
	}
	
	public init(header: String? = nil, footer: String? = nil, rowMutation: TableRowMutation<Value>) {
		let metadata = header != nil || footer != nil ? TableSectionMetadata(header: header, footer: footer) : nil
		self.init(metadata: metadata, rowMutation: rowMutation)
	}
	
	public init(arrayLiteral elements: Value...) {
		self.init(rowMutation: TableRowMutation(array: elements))
	}
	
	public init() {
		self.init(rowMutation: TableRowMutation())
	}
}

/// A data type that can be used to cache the destination end of a `TableSectionMutation<Value>` change stream.
public struct TableSectionState<Value> {
	public var rowState = TableRowState<Value>()
	public var metadata: TableSectionMetadata
	
	init(initial: TableSectionMutation<Value>) {
		self.metadata = initial.metadata ?? TableSectionMetadata()
		initial.rowMutation.apply(to: &rowState)
	}
	
	public var rows: Deque<Value> {
		get {
			return rowState.rows
		} set {
			rowState.rows = newValue
		}
	}
	
	public var localOffset: Int {
		get {
			return rowState.localOffset
		} set {
			rowState.localOffset = newValue
		}
	}
	
	public var globalCount: Int {
		get {
			return rowState.globalCount
		} set {
			rowState.globalCount = newValue
		}
	}
}

/// An extension of the same premise in `TableRowMutation.apply` for `TableRowMutation<TableSectionMutation<Value>>` that maps the `TableSectionMutation` onto a `TableSectionState` and correctly applies the mutation in the nested `TableSectionMutation` to the target on update.
extension TableRowMutation {
	public func apply<Row>(to sections: inout TableRowState<TableSectionState<Row>>) where TableSectionMutation<Row> == Value {
		sections.globalCount = self.globalCount
		sections.localOffset = self.localOffset
		let indexSet = self.arrayMutation.indexSet
		let values = self.arrayMutation.values
		switch self.arrayMutation.kind {
		case .delete:
			indexSet.rangeView.reversed().forEach { sections.rows.removeSubrange($0) }
		case .scroll(let offset):
			sections.rows.removeSubrange(offset > 0 ? sections.rows.startIndex..<offset : (sections.rows.endIndex + offset)..<sections.rows.endIndex)
			sections.rows.insert(contentsOf: values.map { TableSectionState<Row>(initial: $0) }, at: offset > 0 ? sections.rows.endIndex : sections.rows.startIndex)
		case .move(let index):
			let moving = indexSet.map { sections.rows[$0] }
			indexSet.rangeView.reversed().forEach { sections.rows.removeSubrange($0) }
			sections.rows.insert(contentsOf: moving, at: index)
		case .insert:
			for (i, v) in zip(indexSet, values) {
				sections.rows.insert(TableSectionState<Row>(initial: v), at: i)
			}
		case .update:
			for (valuesIndex, sectionIndex) in indexSet.enumerated() {
				var section = sections.rows[sectionIndex]
				let mutation = values[valuesIndex]
				if let m = mutation.metadata {
					section.metadata = m
				}
				mutation.rowMutation.apply(to: &section.rowState)
				sections.rows.replaceSubrange(sectionIndex..<(sectionIndex + 1), with: CollectionOfOne(section))
			}
		case .reload:
			sections.rows.replaceSubrange(sections.rows.startIndex..<sections.rows.endIndex, with: values.map { TableSectionState<Row>(initial: $0) })
		}
	}
}


public class NavigationItem: ConstructingBinder, NavigationItemConvertible {
	public typealias Instance = UINavigationItem
	public typealias Inherited = BaseBinder
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiNavigationItem() -> Instance { return instance() }
	
	public enum Binding: NavigationItemBinding {
		public typealias EnclosingBinder = NavigationItem
		public static func navigationItemBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case title(Dynamic<String>)
		case titleView(Dynamic<ViewConvertible?>)
		case prompt(Dynamic<String?>)
		case backBarButtonItem(Dynamic<BarButtonItemConvertible?>)
		case hidesBackButton(Dynamic<SetOrAnimate<Bool>>)
		case leftBarButtonItems(Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>)
		case rightBarButtonItems(Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>)
		case leftItemsSupplementBackButton(Dynamic<Bool>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}

	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = NavigationItem
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		public init() {}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .title(let x): return x.apply(instance, storage) { i, s, v in i.title = v }
			case .titleView(let x): return x.apply(instance, storage) { i, s, v in i.titleView = v?.uiView() }
			case .prompt(let x): return x.apply(instance, storage) { i, s, v in i.prompt = v }
			case .backBarButtonItem(let x): return x.apply(instance, storage) { i, s, v in i.backBarButtonItem = v?.uiBarButtonItem() }
			case .hidesBackButton(let x): return x.apply(instance, storage) { i, s, v in i.setHidesBackButton(v.value, animated: v.isAnimated) }
			case .leftBarButtonItems(let x): return x.apply(instance, storage) { i, s, v in i.setLeftBarButtonItems(v.value.map { $0.uiBarButtonItem() }, animated: v.isAnimated) }
			case .rightBarButtonItems(let x): return x.apply(instance, storage) { i, s, v in i.setRightBarButtonItems(v.value.map { $0.uiBarButtonItem() }, animated: v.isAnimated) }
			case .leftItemsSupplementBackButton(let x): return x.apply(instance, storage) { i, s, v in i.leftItemsSupplementBackButton = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: (), storage: ())
			}
		}
	}

	public typealias Storage = ObjectBinderStorage
}

extension BindingName where Binding: NavigationItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.$1(v)) }) }
	public static var title: BindingName<Dynamic<String>, Binding> { return BindingName<Dynamic<String>, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.title(v)) }) }
	public static var titleView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.titleView(v)) }) }
	public static var prompt: BindingName<Dynamic<String?>, Binding> { return BindingName<Dynamic<String?>, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.prompt(v)) }) }
	public static var backBarButtonItem: BindingName<Dynamic<BarButtonItemConvertible?>, Binding> { return BindingName<Dynamic<BarButtonItemConvertible?>, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.backBarButtonItem(v)) }) }
	public static var hidesBackButton: BindingName<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingName<Dynamic<SetOrAnimate<Bool>>, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.hidesBackButton(v)) }) }
	public static var leftBarButtonItems: BindingName<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding> { return BindingName<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.leftBarButtonItems(v)) }) }
	public static var rightBarButtonItems: BindingName<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding> { return BindingName<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.rightBarButtonItems(v)) }) }
	public static var leftItemsSupplementBackButton: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .navigationItemBinding(NavigationItem.Binding.leftItemsSupplementBackButton(v)) }) }
}

extension BindingName where Binding: NavigationItemBinding {
	// Additional helper binding names
	public static func leftBarButtonItems(animate: AnimationChoice = .subsequent) -> BindingName<Dynamic<[BarButtonItemConvertible]>, Binding> { return BindingName<Dynamic<[BarButtonItemConvertible]>, Binding>({ (v: Dynamic<[BarButtonItemConvertible]>) -> Binding in
		switch v {
		case .constant(let b) where animate == .all: return Binding.navigationItemBinding(NavigationItem.Binding.leftBarButtonItems(Dynamic.constant(.animate(b))))
		case .constant(let b): return Binding.navigationItemBinding(NavigationItem.Binding.leftBarButtonItems(Dynamic.constant(.set(b))))
		case .dynamic(let b): return Binding.navigationItemBinding(NavigationItem.Binding.leftBarButtonItems(Dynamic.dynamic(b.animate(animate))))
		}
	}) }
	public static func rightBarButtonItems(animate: AnimationChoice = .subsequent) -> BindingName<Dynamic<[BarButtonItemConvertible]>, Binding> { return BindingName<Dynamic<[BarButtonItemConvertible]>, Binding>({ (v: Dynamic<[BarButtonItemConvertible]>) -> Binding in
		switch v {
		case .constant(let b) where animate == .all: return Binding.navigationItemBinding(NavigationItem.Binding.rightBarButtonItems(Dynamic.constant(.animate(b))))
		case .constant(let b): return Binding.navigationItemBinding(NavigationItem.Binding.rightBarButtonItems(Dynamic.constant(.set(b))))
		case .dynamic(let b): return Binding.navigationItemBinding(NavigationItem.Binding.rightBarButtonItems(Dynamic.dynamic(b.animate(animate))))
		}
	}) }
}

public protocol NavigationItemConvertible {
	func uiNavigationItem() -> NavigationItem.Instance
}
extension NavigationItem.Instance: NavigationItemConvertible {
	public func uiNavigationItem() -> NavigationItem.Instance { return self }
}

public protocol NavigationItemBinding: BaseBinding {
	static func navigationItemBinding(_ binding: NavigationItem.Binding) -> Self
}
extension NavigationItemBinding {
	public static func baseBinding(_ binding: BaseBinder.Binding) -> Self {
		return navigationItemBinding(.inheritedBinding(binding))
	}
}

import UIKit

public class TabBar<ItemIdentifier: Hashable>: ConstructingBinder, TabBarConvertible {
	public typealias Instance = UITabBar
	public typealias Inherited = View
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiTabBar() -> Instance { return instance() }
	
	public enum Binding: TabBarBinding {
		public typealias ItemIdentifierType = ItemIdentifier
		public typealias EnclosingBinder = TabBar
		public static func tabBarBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.

		// 1. Value bindings may be applied at construction and may subsequently change.
		case items(Dynamic<SetOrAnimate<[ItemIdentifier]>>)
		case barStyle(Dynamic<UIBarStyle>)
		case isTranslucent(Dynamic<Bool>)
		case barTintColor(Dynamic<UIColor>)
		case tintColor(Dynamic<UIColor>)
		@available(iOS 10.0, *)
		case unselectedItemTintColor(Dynamic<UIColor>)
		case backgroundImage(Dynamic<UIImage?>)
		case shadowImage(Dynamic<UIImage?>)
		case selectionIndicatorImage(Dynamic<UIImage?>)
		case itemPositioning(Dynamic<UITabBar.ItemPositioning>)
		case itemSpacing(Dynamic<CGFloat>)
		case itemWidth(Dynamic<CGFloat>)

		// 2. Signal bindings are performed on the object after construction.
		case selectItem(Signal<ItemIdentifier>)
		case customizingItems(Signal<SetOrAnimate<[ItemIdentifier]?>>)

		// 3. Action bindings are triggered by the object after construction.
		case willBeginCustomizing(SignalInput<[ItemIdentifier]>)
		case didBeginCustomizing(SignalInput<[ItemIdentifier]>)
		case willEndCustomizing(SignalInput<([ItemIdentifier], Bool)>)
		case didEndCustomizing(SignalInput<([ItemIdentifier], Bool)>)
		case didSelectItem(SignalInput<ItemIdentifier>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case itemConstructor((ItemIdentifier) -> TabBarItemConvertible)
	}

	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = TabBar
		public var linkedPreparer = Inherited.Preparer()

		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }

		public init() {
			self.init(delegateClass: Delegate.self)
		}
		public init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		public let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		var tabBarItemConstructor: ((ItemIdentifier) -> TabBarItemConvertible)?

		public mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .itemConstructor(let x): tabBarItemConstructor = x
			case .willBeginCustomizing(let x):
				let s = #selector(UITabBarDelegate.tabBar(_:willBeginCustomizing:))
				delegate().addSelector(s).willBeginCustomizing = x
			case .didBeginCustomizing(let x):
				let s = #selector(UITabBarDelegate.tabBar(_:didBeginCustomizing:))
				delegate().addSelector(s).didBeginCustomizing = x
			case .willEndCustomizing(let x):
				let s = #selector(UITabBarDelegate.tabBar(_:willEndCustomizing:changed:))
				delegate().addSelector(s).willEndCustomizing = x
			case .didEndCustomizing(let x):
				let s = #selector(UITabBarDelegate.tabBar(_:didEndCustomizing:changed:))
				delegate().addSelector(s).didEndCustomizing = x
			case .didSelectItem(let x):
				let s = #selector(UITabBarDelegate.tabBar(_:didSelect:))
				delegate().addSelector(s).didSelectIndex = x
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		public mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")

			storage.dynamicDelegate = possibleDelegate
			storage.tabBarItemConstructor = tabBarItemConstructor
			
			if storage.inUse {
				instance.delegate = storage
			}
			
			linkedPreparer.prepareInstance(instance, storage: storage)
		}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			// e.g. case .someProperty(let x): return x.apply(instance, storage) { inst, stor, val in inst.someProperty = val }
			case .itemConstructor: return nil
			case .items(let x):
				return x.apply(instance, storage) { inst, stor, val in
					let items = val.value.compactMap { stor.tabBarItem(for: $0) }
					inst.setItems(items, animated: val.isAnimated)
				}
			case .selectItem(let x): return x.apply(instance, storage) { inst, stor, val in inst.selectedItem = stor.tabBarItem(for: val) }
			case .barStyle(let x): return x.apply(instance, storage) { inst, stor, val in inst.barStyle = val }
			case .isTranslucent(let x): return x.apply(instance, storage) { inst, stor, val in inst.isTranslucent = val }
			case .barTintColor(let x): return x.apply(instance, storage) { inst, stor, val in inst.barTintColor = val }
			case .tintColor(let x): return x.apply(instance, storage) { inst, stor, val in inst.tintColor = val }
			case .unselectedItemTintColor(let x): return x.apply(instance, storage) { inst, stor, val in
					if #available(iOS 10.0, *) {
						inst.unselectedItemTintColor = val
					}
				}
			case .backgroundImage(let x): return x.apply(instance, storage) { inst, stor, val in inst.backgroundImage = val }
			case .shadowImage(let x): return x.apply(instance, storage) { inst, stor, val in inst.shadowImage = val }
			case .selectionIndicatorImage(let x): return x.apply(instance, storage) { inst, stor, val in inst.selectionIndicatorImage = val }
			case .itemPositioning(let x): return x.apply(instance, storage) { inst, stor, val in inst.itemPositioning = val }
			case .itemSpacing(let x): return x.apply(instance, storage) { inst, stor, val in inst.itemSpacing = val }
			case .itemWidth(let x): return x.apply(instance, storage) { inst, stor, val in inst.itemWidth = val }
			case .customizingItems(let x): return x.apply(instance, storage) { inst, stor, val in
				if let v = val.value {
					let items = v.compactMap { stor.tabBarItem(for: $0) }
					inst.beginCustomizingItems(items)
				} else {
					inst.endCustomizing(animated: val.isAnimated)
				}
			}
			case .willBeginCustomizing: return nil
			case .didBeginCustomizing: return nil
			case .willEndCustomizing: return nil
			case .didEndCustomizing: return nil
			case .didSelectItem: return nil
			case .inheritedBinding(let b): return linkedPreparer.applyBinding(b, instance: instance, storage: storage)
			}
		}
	}

	open class Storage: View.Storage, UITabBarDelegate {
		open var tabBarItemConstructor: ((ItemIdentifier) -> TabBarItemConvertible)?
		open var allItems: [ItemIdentifier: TabBarItemConvertible] = [:]
		
		open override var inUse: Bool { return true }
		
		open func identifier(for tabBarItem: UITabBarItem) -> ItemIdentifier? {
			return allItems.first(where: { pair -> Bool in
				pair.value.uiTabBarItem() === tabBarItem
			})?.key
		}
		open func tabBarItem(for identifier: ItemIdentifier) -> UITabBarItem? {
			if let existing = allItems[identifier] {
				return existing.uiTabBarItem()
			}
			if let constructor = tabBarItemConstructor {
				let new = constructor(identifier)
				allItems[identifier] = new
				return new.uiTabBarItem()
			}
			return nil
		}
	}
	
	open class Delegate: DynamicDelegate, UITabBarDelegate {
		public required override init() {
			super.init()
		}

		open var didSelectIndex: SignalInput<ItemIdentifier>?
		open func tabBar(_ tabBar: UITabBar, didSelect item: UITabBarItem) {
			if let identifier = (tabBar.delegate as? Storage)?.identifier(for: item) {
				didSelectIndex?.send(value: identifier)
			}
		}

		open var willBeginCustomizing: SignalInput<[ItemIdentifier]>?
		open func tabBar(_ tabBar: UITabBar, willBeginCustomizing items: [UITabBarItem]) {
			if let storage = tabBar.delegate as? Storage {
				willBeginCustomizing?.send(value: items.compactMap { storage.identifier(for: $0) })
			}
		}

		open var didBeginCustomizing: SignalInput<[ItemIdentifier]>?
		open func tabBar(_ tabBar: UITabBar, didBeginCustomizing items: [UITabBarItem]) {
			if let storage = tabBar.delegate as? Storage {
				didBeginCustomizing?.send(value: items.compactMap { storage.identifier(for: $0) })
			}
		}

		open var willEndCustomizing: SignalInput<([ItemIdentifier], Bool)>?
		open func tabBar(_ tabBar: UITabBar, willEndCustomizing items: [UITabBarItem], changed: Bool) {
			if let storage = tabBar.delegate as? Storage {
				willEndCustomizing?.send(value: (items.compactMap { storage.identifier(for: $0) }, changed))
			}
		}

		open var didEndCustomizing: SignalInput<([ItemIdentifier], Bool)>?
		open func tabBar(_ tabBar: UITabBar, didEndCustomizing items: [UITabBarItem], changed: Bool) {
			if let storage = tabBar.delegate as? Storage {
				didEndCustomizing?.send(value: (items.compactMap { storage.identifier(for: $0) }, changed))
			}
		}
	}
}

extension BindingName where Binding: TabBarBinding {
	// You can easily convert the `Binding` cases to `BindingName` by copying them to here and using the following Xcode-style regex:
	// Find:    case ([^\(]+)\((.+)\)$
	// Replace: public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.$1(v)) }) }
	public static var items: BindingName<Dynamic<SetOrAnimate<[Binding.ItemIdentifierType]>>, Binding> { return BindingName<Dynamic<SetOrAnimate<[Binding.ItemIdentifierType]>>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.items(v)) }) }
	public static var selectItem: BindingName<Signal<Binding.ItemIdentifierType>, Binding> { return BindingName<Signal<Binding.ItemIdentifierType>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.selectItem(v)) }) }
	public static var barStyle: BindingName<Dynamic<UIBarStyle>, Binding> { return BindingName<Dynamic<UIBarStyle>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.barStyle(v)) }) }
	public static var isTranslucent: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.isTranslucent(v)) }) }
	public static var barTintColor: BindingName<Dynamic<UIColor>, Binding> { return BindingName<Dynamic<UIColor>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.barTintColor(v)) }) }
	public static var tintColor: BindingName<Dynamic<UIColor>, Binding> { return BindingName<Dynamic<UIColor>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.tintColor(v)) }) }
	@available(iOS 10.0, *)
	public static var unselectedItemTintColor: BindingName<Dynamic<UIColor>, Binding> { return BindingName<Dynamic<UIColor>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.unselectedItemTintColor(v)) }) }
	public static var backgroundImage: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.backgroundImage(v)) }) }
	public static var shadowImage: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.shadowImage(v)) }) }
	public static var selectionIndicatorImage: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.selectionIndicatorImage(v)) }) }
	public static var itemPositioning: BindingName<Dynamic<UITabBar.ItemPositioning>, Binding> { return BindingName<Dynamic<UITabBar.ItemPositioning>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.itemPositioning(v)) }) }
	public static var itemSpacing: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.itemSpacing(v)) }) }
	public static var itemWidth: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.itemWidth(v)) }) }
	public static var customizingItems: BindingName<Signal<SetOrAnimate<[Binding.ItemIdentifierType]?>>, Binding> { return BindingName<Signal<SetOrAnimate<[Binding.ItemIdentifierType]?>>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.customizingItems(v)) }) }
	public static var willBeginCustomizing: BindingName<SignalInput<[Binding.ItemIdentifierType]>, Binding> { return BindingName<SignalInput<[Binding.ItemIdentifierType]>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.willBeginCustomizing(v)) }) }
	public static var didBeginCustomizing: BindingName<SignalInput<[Binding.ItemIdentifierType]>, Binding> { return BindingName<SignalInput<[Binding.ItemIdentifierType]>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.didBeginCustomizing(v)) }) }
	public static var willEndCustomizing: BindingName<SignalInput<([Binding.ItemIdentifierType], Bool)>, Binding> { return BindingName<SignalInput<([Binding.ItemIdentifierType], Bool)>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.willEndCustomizing(v)) }) }
	public static var didEndCustomizing: BindingName<SignalInput<([Binding.ItemIdentifierType], Bool)>, Binding> { return BindingName<SignalInput<([Binding.ItemIdentifierType], Bool)>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.didEndCustomizing(v)) }) }
	public static var didSelectItem: BindingName<SignalInput<Binding.ItemIdentifierType>, Binding> { return BindingName<SignalInput<Binding.ItemIdentifierType>, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.didSelectItem(v)) }) }
	public static var itemConstructor: BindingName<(Binding.ItemIdentifierType) -> TabBarItemConvertible, Binding> { return BindingName<(Binding.ItemIdentifierType) -> TabBarItemConvertible, Binding>({ v in .tabBarBinding(TabBar<Binding.ItemIdentifierType>.Binding.itemConstructor(v)) }) }
}

public protocol TabBarConvertible {
	func uiTabBar() -> UITabBar
}
extension TabBarConvertible {
	public func uiView() -> View.Instance { return uiTabBar() }
}
extension TabBar.Instance: TabBarConvertible {
	public func uiTabBar() -> UITabBar { return self }
}

public protocol TabBarBinding: ViewBinding {
	associatedtype ItemIdentifierType: Hashable
	static func tabBarBinding(_ binding: TabBar<ItemIdentifierType>.Binding) -> Self
}
extension TabBarBinding {
	public static func viewBinding(_ binding: View.Binding) -> Self {
		return tabBarBinding(.inheritedBinding(binding))
	}
}

public func applicationMain(subclass: UIApplication.Type = UIApplication.self, application: @escaping () -> Application) -> Never {
	Application.Storage.finish = { () -> Void in
		application().applyBindings(to: UIApplication.shared)
	}
	
	return CommandLine.unsafeArgv.withMemoryRebound(to: Optional<UnsafeMutablePointer<Int8>>.self, capacity: Int(CommandLine.argc)) { argv -> Never in
		_ = UIApplicationMain(CommandLine.argc, argv, NSStringFromClass(subclass), NSStringFromClass(Application.Storage.self))
		fatalError("UIApplicationMain completed unexpectedly")
	}
}

public class Application: Binder {
	public typealias Inherited = BaseBinder
	public typealias Instance = UIApplication
	
	public var state: BinderState<Instance, BindingsOnlyParameters<Binding>>
	public required init(state: BinderState<Instance, BindingsOnlyParameters<Binding>>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}

	public enum Binding: ApplicationBinding {
		public typealias EnclosingBinder = Application
		public static func applicationBinding(_ binding: Application.Binding) -> Application.Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case ignoreInteractionEvents(Dynamic<Bool>)
		case supportShakeToEdit(Dynamic<Bool>)
		case isIdleTimerDisabled(Dynamic<Bool>)
		case shortcutItems(Dynamic<[UIApplicationShortcutItem]?>)
		case isNetworkActivityIndicatorVisible(Dynamic<Bool>)
		case applicationIconBadgeNumber(Dynamic<Int>)
		case window(Dynamic<WindowConvertible?>)
		case additionalWindows(Dynamic<[WindowConvertible]>)

		//	2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.
		case didBecomeActive(SignalInput<Void>)
		case willResignActive(SignalInput<Void>)
		case didEnterBackground(SignalInput<Void>)
		case willEnterForeground(SignalInput<Void>)
		case protectedDataWillBecomeUnavailable(SignalInput<Void>)
		case protectedDataDidBecomeAvailable(SignalInput<Void>)
		case didReceiveMemoryWarning(SignalInput<Void>)
		case significantTimeChange(SignalInput<Void>)
		case performFetch(SignalInput<SignalInput<UIBackgroundFetchResult>>)
		case handleEventsForBackgroundURLSession(SignalInput<Callback<String, ()>>)
		case registerForRemoteNotifications(Signal<Bool>)
		case didRegisterRemoteNotifications(SignalInput<Result<Data>>)
		case didReceiveRemoteNotification(SignalInput<Callback<[AnyHashable: Any], UIBackgroundFetchResult>>)
		case didFailToContinueUserActivity(SignalInput<(String, Error)>)
		case performAction(SignalInput<Callback<UIApplicationShortcutItem, Bool>>)
		case handleWatchKitExtensionRequest(SignalInput<Callback<[AnyHashable: Any]?, [AnyHashable: Any]?>>)

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case willContinueUserActivity((String) -> Bool)
		case continueUserActivity((Callback<NSUserActivity, [UIUserActivityRestoring]?>) -> Bool)
		case didUpdate((NSUserActivity) -> Void)
		case willFinishLaunching(([UIApplication.LaunchOptionsKey: Any]?) -> Bool)
		case didFinishLaunching(([UIApplication.LaunchOptionsKey: Any]?) -> Bool)
		case willEncodeRestorableState((NSKeyedArchiver) -> Void)
		case didDecodeRestorableState((NSKeyedUnarchiver) -> Void)
		case willTerminate(() -> Void)
		case shouldSaveApplicationState((_ coder: NSCoder) -> Bool)
		case shouldRestoreApplicationState((_ coder: NSCoder) -> Bool)
		case viewControllerWithRestorationPath((_ path: [String], _ coder: NSCoder) -> UIViewController)
		case open((_ url: URL, _ options: [UIApplication.OpenURLOptionsKey: Any]) -> Bool)
		case shouldAllowExtensionPointIdentifier((UIApplication.ExtensionPointIdentifier) -> Bool)
		case shouldRequestHealthAuthorization(() -> Void)
	}

	public struct Preparer: StoragePreparer {
		public typealias EnclosingBinder = Application
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage {
			let storage: Storage
			if let s = Storage.underConstruction {
				storage = s
			} else {
				storage = Storage()
			}
			return storage
		}
		
		public init() {
			self.init(delegateClass: Delegate.self)
		}
		public init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		public let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		public mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .didFinishLaunching(let x):
				let s = #selector(UIApplicationDelegate.application(_:didFinishLaunchingWithOptions:))
				delegate().addSelector(s).didFinishLaunching = x
			case .willTerminate(let x):
				let s = #selector(UIApplicationDelegate.applicationWillTerminate(_:))
				delegate().addSelector(s).willTerminate = x
			case .protectedDataWillBecomeUnavailable(let x):
				let s = #selector(UIApplicationDelegate.applicationProtectedDataWillBecomeUnavailable(_:))
				delegate().addSelector(s).protectedDataWillBecomeUnavailable = x
			case .protectedDataDidBecomeAvailable(let x):
				let s = #selector(UIApplicationDelegate.applicationProtectedDataDidBecomeAvailable(_:))
				delegate().addSelector(s).protectedDataDidBecomeAvailable = x
			case .willEncodeRestorableState(let x):
				let s = #selector(UIApplicationDelegate.application(_:willEncodeRestorableStateWith:))
				delegate().addSelector(s).willEncodeRestorableState = x
				
				// Automatically enable `shouldSaveApplicationState` if `willEncodeRestorableState` is isEnabled
				if delegate().shouldSaveApplicationState == nil {
					let shouldSave = #selector(UIApplicationDelegate.application(_:shouldSaveApplicationState:))
					delegate().addSelector(shouldSave).shouldSaveApplicationState = { _ in return true }
				}
			case .didDecodeRestorableState(let x):
				let s = #selector(UIApplicationDelegate.application(_:didDecodeRestorableStateWith:))
				delegate().addSelector(s).didDecodeRestorableState = x
				
				// Automatically enable `shouldRestoreApplicationState` if `didDecodeRestorableState` is isEnabled
				if delegate().shouldRestoreApplicationState == nil {
					let shouldRestore = #selector(UIApplicationDelegate.application(_:shouldRestoreApplicationState:))
					delegate().addSelector(shouldRestore).shouldRestoreApplicationState = { _ in return true }
				}
			case .performFetch(let x):
				let s = #selector(UIApplicationDelegate.application(_:performFetchWithCompletionHandler:))
				delegate().addSelector(s).performFetch = x
			case .handleEventsForBackgroundURLSession(let x):
				let s = #selector(UIApplicationDelegate.application(_:handleEventsForBackgroundURLSession:completionHandler:))
				delegate().addSelector(s).handleEventsForBackgroundURLSession = x
			case .didRegisterRemoteNotifications(let x):
				let s1 = #selector(UIApplicationDelegate.application(_:didRegisterForRemoteNotificationsWithDeviceToken:))
				let s2 = #selector(UIApplicationDelegate.application(_:didFailToRegisterForRemoteNotificationsWithError:))
				delegate().addSelector(s1).didRegisterRemoteNotifications = x
				delegate().addSelector(s2)
			case .didReceiveRemoteNotification(let x):
				let s = #selector(UIApplicationDelegate.application(_:didReceiveRemoteNotification:fetchCompletionHandler:))
				delegate().addSelector(s).didReceiveRemoteNotification = x
			case .didFailToContinueUserActivity(let x):
				let s = #selector(UIApplicationDelegate.application(_:didFailToContinueUserActivityWithType:error:))
				delegate().addSelector(s).didFailToContinueUserActivity = x
			case .performAction(let x):
				let s = #selector(UIApplicationDelegate.application(_:performActionFor:completionHandler:))
				delegate().addSelector(s).performAction = x
			case .handleWatchKitExtensionRequest(let x):
				let s = #selector(UIApplicationDelegate.application(_:handleWatchKitExtensionRequest:reply:))
				delegate().addSelector(s).handleWatchKitExtensionRequest = x
			case .shouldRequestHealthAuthorization(let x):
				let s = #selector(UIApplicationDelegate.applicationShouldRequestHealthAuthorization(_:))
				delegate().addSelector(s).shouldRequestHealthAuthorization = x
			case .willContinueUserActivity(let x):
				let s = #selector(UIApplicationDelegate.application(_:willContinueUserActivityWithType:))
				delegate().addSelector(s).willContinueUserActivity = x
			case .continueUserActivity(let x):
				let s = #selector(UIApplicationDelegate.application(_:continue:restorationHandler:))
				delegate().addSelector(s).continueUserActivity = x
			case .didUpdate(let x):
				let s = #selector(UIApplicationDelegate.application(_:didUpdate:))
				delegate().addSelector(s).didUpdate = x
			case .shouldSaveApplicationState(let x):
				let s = #selector(UIApplicationDelegate.application(_:shouldSaveApplicationState:))
				delegate().addSelector(s).shouldSaveApplicationState = x
			case .shouldRestoreApplicationState(let x):
				let s = #selector(UIApplicationDelegate.application(_:shouldRestoreApplicationState:))
				delegate().addSelector(s).shouldRestoreApplicationState = x
			case .viewControllerWithRestorationPath(let x):
				let s = #selector(UIApplicationDelegate.application(_:viewControllerWithRestorationIdentifierPath:coder:))
				delegate().addSelector(s).viewControllerWithRestorationPath = x
			case .open(let x):
				if #available(iOS 9.0, *) {
					let s = #selector(UIApplicationDelegate.application(_:open:options:))
					delegate().addSelector(s).open = x
				}
			case .shouldAllowExtensionPointIdentifier(let x):
				let s = #selector(UIApplicationDelegate.application(_:shouldAllowExtensionPointIdentifier:))
				delegate().addSelector(s).shouldAllowExtensionPointIdentifier = x
			case .inheritedBinding(let s): linkedPreparer.prepareBinding(s)
			default: break
			}
		}
		
		public mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
			storage.dynamicDelegate = possibleDelegate
			instance.delegate = storage

			linkedPreparer.prepareInstance(instance, storage: storage)
		}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .additionalWindows(let x):
				return x.apply(instance, storage) { i, s, v in
					s.additionalWindows = v.map { $0.uiWindow() }
				}
			case .window(let x):
				return x.apply(instance, storage) { i, s, v in
					s.window = v?.uiWindow()
				}
			case .ignoreInteractionEvents(let x):
				return x.apply(instance, storage) { i, s, v in
					switch (i.isIgnoringInteractionEvents, v) {
					case (false, true): i.beginIgnoringInteractionEvents()
					case (true, false): i.endIgnoringInteractionEvents()
					default: break
					}
				}
			case .supportShakeToEdit(let x): return x.apply(instance, storage) { i, s, v in i.applicationSupportsShakeToEdit = v }
			case .isIdleTimerDisabled(let x): return x.apply(instance, storage) { i, s, v in i.isIdleTimerDisabled = v }
			case .shortcutItems(let x): return x.apply(instance, storage) { i, s, v in i.shortcutItems = v }
			case .isNetworkActivityIndicatorVisible(let x): return x.apply(instance, storage) { i, s, v in i.isNetworkActivityIndicatorVisible = v }
			case .applicationIconBadgeNumber(let x): return x.apply(instance, storage) { i, s, v in i.applicationIconBadgeNumber = v }
			case .registerForRemoteNotifications(let x):
				return x.apply(instance, storage) { i, s, v in
					switch (i.isRegisteredForRemoteNotifications, v) {
					case (false, true): i.registerForRemoteNotifications()
					case (true, false): i.unregisterForRemoteNotifications()
					default: break
					}
				}
			case .didBecomeActive(let x):
				return Signal.notifications(name: UIApplication.didBecomeActiveNotification, object: instance).map { n in return () }.cancellableBind(to: x)
			case .willResignActive(let x):
				return Signal.notifications(name: UIApplication.willResignActiveNotification, object: instance).map { n in return () }.cancellableBind(to: x)
			case .didEnterBackground(let x):
				return Signal.notifications(name: UIApplication.didEnterBackgroundNotification, object: instance).map { n in return () }.cancellableBind(to: x)
			case .willEnterForeground(let x):
				return Signal.notifications(name: UIApplication.willEnterForegroundNotification, object: instance).map { n in return () }.cancellableBind(to: x)
			case .didReceiveMemoryWarning(let x):
				return Signal.notifications(name: UIApplication.didReceiveMemoryWarningNotification, object: instance).map { n in return () }.cancellableBind(to: x)
			case .significantTimeChange(let x):
				return Signal.notifications(name: UIApplication.significantTimeChangeNotification, object: instance).map { n in return () }.cancellableBind(to: x)
			case .willFinishLaunching(let x):
				storage.willFinishLaunching = x
				return nil
			case .didFinishLaunching: return nil
			case .protectedDataWillBecomeUnavailable: return nil
			case .protectedDataDidBecomeAvailable: return nil
			case .performFetch: return nil
			case .handleEventsForBackgroundURLSession: return nil
			case .didRegisterRemoteNotifications: return nil
			case .didReceiveRemoteNotification: return nil
			case .didFailToContinueUserActivity: return nil
			case .performAction: return nil
			case .handleWatchKitExtensionRequest: return nil
			case .shouldRequestHealthAuthorization: return nil
				
			case .willContinueUserActivity: return nil
			case .continueUserActivity: return nil
			case .didUpdate: return nil
			case .willEncodeRestorableState: return nil
			case .didDecodeRestorableState: return nil
			case .willTerminate: return nil
			case .shouldSaveApplicationState: return nil
			case .shouldRestoreApplicationState: return nil
			case .viewControllerWithRestorationPath: return nil
			case .open: return nil
			case .shouldAllowExtensionPointIdentifier: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}

	open class Storage: ObjectBinderStorage, UIApplicationDelegate {
		public static var finish: (() -> Void)? = nil
		fileprivate static var underConstruction: Storage? = nil
		
		open var window: UIWindow? = nil
		open var additionalWindows: [UIWindow] = []
		
		open var willFinishLaunching: (([UIApplication.LaunchOptionsKey: Any]?) -> Bool)?
		public func application(_ application: UIApplication, willFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
			// Disconnect the delegate since we're about to change behavior
			UIApplication.shared.delegate = nil
			
			// Apply the styles to the application and delegate.
			if let finish = Storage.finish {
				Storage.underConstruction = self
				finish()
				Storage.underConstruction = nil
				Storage.finish = nil
			} else {
				preconditionFailure("Application bindings must be initialized by calling applicationMain.")
			}
			
			assert(UIApplication.shared.delegate === self, "Failed to reconnect delegate")
			
			
			// Apply the view hierarchy
			window?.makeKeyAndVisible()
			
			// Invoke any user-supplied code
			return willFinishLaunching?(launchOptions) ?? true
		}
		
		open override var inUse: Bool {
			return true
		}
	}

	open class Delegate: DynamicDelegate, UIApplicationDelegate {
		public required override init() {
			super.init()
		}
		
		open var didFinishLaunching: (([UIApplication.LaunchOptionsKey: Any]?) -> Bool)?
		open func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil) -> Bool {
			return didFinishLaunching!(launchOptions)
		}
		
		open var willTerminate: (() -> Void)?
		open func applicationWillTerminate(_ application: UIApplication) {
			return willTerminate!()
		}
		
		open var protectedDataWillBecomeUnavailable: SignalInput<Void>?
		open func applicationProtectedDataWillBecomeUnavailable(_ application: UIApplication) {
			protectedDataWillBecomeUnavailable!.send(value: ())
		}
		
		open var protectedDataDidBecomeAvailable: SignalInput<Void>?
		open func applicationProtectedDataDidBecomeAvailable(_ application: UIApplication) {
			protectedDataDidBecomeAvailable!.send(value: ())
		}
		
		open var willEncodeRestorableState: ((NSKeyedArchiver) -> Void)?
		open func application(_ application: UIApplication, willEncodeRestorableStateWith coder: NSCoder) {
			return willEncodeRestorableState!(coder as! NSKeyedArchiver)
		}
		
		open var didDecodeRestorableState: ((NSKeyedUnarchiver) -> Void)?
		open func application(_ application: UIApplication, didDecodeRestorableStateWith coder: NSCoder) {
			return didDecodeRestorableState!(coder as! NSKeyedUnarchiver)
		}
		
		open var performFetch: SignalInput<SignalInput<UIBackgroundFetchResult>>?
		open func application(_ application: UIApplication, performFetchWithCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {
			let (input, _) = Signal<UIBackgroundFetchResult>.create { s in
				s.subscribeUntilEnd { r in
					switch r {
					case .success(let bfr): completionHandler(bfr)
					case .failure: completionHandler(UIBackgroundFetchResult.failed)
					}
				}
			}
			performFetch!.send(value: input)
		}
		
		open var handleEventsForBackgroundURLSession: SignalInput<Callback<String, ()>>?
		open func application(_ application: UIApplication, handleEventsForBackgroundURLSession session: String, completionHandler: @escaping () -> Void) {
			let (input, _) = Signal<Void>.create { s in s.subscribeWhile { r in completionHandler(); return false } }
			handleEventsForBackgroundURLSession!.send(value: Callback(session, input))
		}
		
		open var didRegisterUserNotifications: Any?
		@available(iOS, introduced: 8.0, deprecated: 10.0, message: "Use UserNotifications Framework's UNNotificationSettings")
		open func application(_ application: UIApplication, didRegister notificationSettings: UIUserNotificationSettings) {
			(didRegisterUserNotifications as! SignalInput<UIUserNotificationSettings>).send(value: notificationSettings)
		}
		
		open var didRegisterRemoteNotifications: SignalInput<Result<Data>>?
		open func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
			didRegisterRemoteNotifications!.send(value: Result.success(deviceToken))
		}
		open func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
			didRegisterRemoteNotifications!.send(value: Result.failure(error))
		}
		
		open var didReceiveLocalNotification: Any?
		@available(iOS, introduced: 4.0, deprecated: 10.0, message: "Use UserNotifications Framework's UNNotificationSettings")
		open func application(_ application: UIApplication, didReceive: UILocalNotification) {
			(didReceiveLocalNotification as! SignalInput<UILocalNotification>).send(value: didReceive)
		}
		
		open var didReceiveRemoteNotification: SignalInput<Callback<[AnyHashable: Any], UIBackgroundFetchResult>>?
		open func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any], fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {
			let (input, _) = Signal<UIBackgroundFetchResult>.create { s in
				s.subscribeUntilEnd { r in
					switch r {
					case .success(let bfr): completionHandler(bfr)
					case .failure: completionHandler(UIBackgroundFetchResult.failed)
					}
				}
			}
			didReceiveRemoteNotification!.send(value: Callback(userInfo, input))
		}
		
		open var handleLocalNotificationAction: Any?
		@available(iOS, introduced: 4.0, deprecated: 10.0, message: "Use UserNotifications Framework's UNNotificationSettings")
		open func application(_ application: UIApplication, handleActionWithIdentifier identifier: String?, for localNotification: UILocalNotification, completionHandler: @escaping () -> Void) {
			let (input, _) = Signal<Void>.create { s in s.subscribeWhile { r in completionHandler(); return false } }
			(handleLocalNotificationAction as! SignalInput<Callback<(String?, UILocalNotification), ()>>).send(value: Callback((identifier, localNotification), input))
		}
		
		open var handleRemoteNotificationAction: SignalInput<Callback<(String?, [AnyHashable: Any]), ()>>?
		open func application(_ application: UIApplication, handleActionWithIdentifier identifier: String?, forRemoteNotification userInfo: [AnyHashable: Any], completionHandler: @escaping () -> Void) {
			let (input, _) = Signal<Void>.create { s in s.subscribeWhile { r in completionHandler(); return false } }
			handleRemoteNotificationAction!.send(value: Callback((identifier, userInfo), input))
		}
		
		open var handleLocalNotificationResponseInfoAction: Any?
		@available(iOS, introduced: 4.0, deprecated: 10.0, message: "Use UserNotifications Framework's UNNotificationSettings")
		open func application(_ application: UIApplication, handleActionWithIdentifier identifier: String?, for localNotification: UILocalNotification, withResponseInfo responseInfo: [AnyHashable : Any], completionHandler: @escaping () -> Void) {
			let (input, _) = Signal<Void>.create { s in s.subscribeWhile { r in completionHandler(); return false } }
			(handleLocalNotificationResponseInfoAction as! SignalInput<Callback<(String?, UILocalNotification, [AnyHashable : Any]), ()>>).send(value: Callback((identifier, localNotification, responseInfo), input))
		}
		
		open var handleRemoteNotificationResponseInfoAction: SignalInput<Callback<(String?, [AnyHashable: Any], [AnyHashable : Any]), ()>>?
		open func application(_ application: UIApplication, handleActionWithIdentifier identifier: String?, forRemoteNotification userInfo: [AnyHashable: Any], withResponseInfo responseInfo: [AnyHashable : Any], completionHandler: @escaping () -> Void) {
			let (input, _) = Signal<Void>.create { s in s.subscribeWhile { r in completionHandler(); return false } }
			handleRemoteNotificationResponseInfoAction!.send(value: Callback((identifier, userInfo, responseInfo), input))
		}
		
		open var didFailToContinueUserActivity: SignalInput<(String, Error)>?
		open func application(_ application: UIApplication, didFailToContinueUserActivityWithType userActivityType: String, error: Error) {
			didFailToContinueUserActivity!.send(value: (userActivityType, error))
		}
		
		open var handleWatchKitExtensionRequest: SignalInput<Callback<[AnyHashable: Any]?, [AnyHashable: Any]?>>?
		open func application(_ application: UIApplication, handleWatchKitExtensionRequest userInfo: [AnyHashable : Any]?, reply: @escaping ([AnyHashable : Any]?) -> Void) {
			let (input, _) = Signal<[AnyHashable: Any]?>.create { s in s.subscribeWhile { r in reply(r.value ?? nil); return false } }
			handleWatchKitExtensionRequest!.send(value: Callback(userInfo, input))
		}
		
		open var shouldRequestHealthAuthorization: (() -> Void)?
		open func applicationShouldRequestHealthAuthorization(_ application: UIApplication) {
			shouldRequestHealthAuthorization!()
		}
		
		open var willContinueUserActivity: ((String) -> Bool)?
		open func application(_ application: UIApplication, willContinueUserActivityWithType userActivityType: String) -> Bool {
			return willContinueUserActivity!(userActivityType)
		}
		
		open var continueUserActivity: ((Callback<NSUserActivity, [UIUserActivityRestoring]?>) -> Bool)?
		open func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {
			let (input, _) = Signal<[UIUserActivityRestoring]?>.create { s in s.subscribeWhile { r in restorationHandler(r.value ?? nil); return false } }
			return continueUserActivity!(Callback(userActivity, input))
		}
		
		open var didUpdate: ((NSUserActivity) -> Void)?
		open func application(_ application: UIApplication, didUpdate userActivity: NSUserActivity) {
			didUpdate!(userActivity)
		}
		
		open var shouldSaveApplicationState: ((NSCoder) -> Bool)?
		open func application(_ application: UIApplication, shouldSaveApplicationState coder: NSCoder) -> Bool {
			return shouldSaveApplicationState!(coder)
		}
		
		open var shouldRestoreApplicationState: ((NSCoder) -> Bool)?
		open func application(_ application: UIApplication, shouldRestoreApplicationState coder: NSCoder) -> Bool {
			return shouldRestoreApplicationState!(coder)
		}
		
		open var viewControllerWithRestorationPath: (([String], NSCoder) -> UIViewController?)?
		open func application(_ application: UIApplication, viewControllerWithRestorationIdentifierPath identifierComponents: [String], coder: NSCoder) -> UIViewController? {
			return viewControllerWithRestorationPath!(identifierComponents, coder)
		}
		
		open var open: ((URL, [UIApplication.OpenURLOptionsKey: Any]) -> Bool)?
		open func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {
			return open!(url, options)
		}
		
		open var shouldAllowExtensionPointIdentifier: ((UIApplication.ExtensionPointIdentifier) -> Bool)?
		open func application(_ application: UIApplication, shouldAllowExtensionPointIdentifier extensionPointIdentifier: UIApplication.ExtensionPointIdentifier) -> Bool {
			return shouldAllowExtensionPointIdentifier!(extensionPointIdentifier)
		}
		
		open var performAction: SignalInput<Callback<UIApplicationShortcutItem, Bool>>?
		open func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -> Void) {
			let (input, _) = Signal<Bool>.create { s in s.subscribeWhile { r in completionHandler(r.value ?? false); return false } }
			performAction!.send(value: Callback(shortcutItem, input))
		}
	}
}

extension BindingName where Binding: ApplicationBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .applicationBinding(Application.Binding.$1(v)) }) }
	public static var ignoreInteractionEvents: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .applicationBinding(Application.Binding.ignoreInteractionEvents(v)) }) }
	public static var supportShakeToEdit: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .applicationBinding(Application.Binding.supportShakeToEdit(v)) }) }
	public static var isIdleTimerDisabled: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .applicationBinding(Application.Binding.isIdleTimerDisabled(v)) }) }
	public static var shortcutItems: BindingName<Dynamic<[UIApplicationShortcutItem]?>, Binding> { return BindingName<Dynamic<[UIApplicationShortcutItem]?>, Binding>({ v in .applicationBinding(Application.Binding.shortcutItems(v)) }) }
	public static var isNetworkActivityIndicatorVisible: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .applicationBinding(Application.Binding.isNetworkActivityIndicatorVisible(v)) }) }
	public static var applicationIconBadgeNumber: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .applicationBinding(Application.Binding.applicationIconBadgeNumber(v)) }) }
	public static var window: BindingName<Dynamic<WindowConvertible?>, Binding> { return BindingName<Dynamic<WindowConvertible?>, Binding>({ v in .applicationBinding(Application.Binding.window(v)) }) }
	public static var additionalWindows: BindingName<Dynamic<[WindowConvertible]>, Binding> { return BindingName<Dynamic<[WindowConvertible]>, Binding>({ v in .applicationBinding(Application.Binding.additionalWindows(v)) }) }
	public static var didBecomeActive: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .applicationBinding(Application.Binding.didBecomeActive(v)) }) }
	public static var willResignActive: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .applicationBinding(Application.Binding.willResignActive(v)) }) }
	public static var didEnterBackground: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .applicationBinding(Application.Binding.didEnterBackground(v)) }) }
	public static var willEnterForeground: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .applicationBinding(Application.Binding.willEnterForeground(v)) }) }
	public static var protectedDataWillBecomeUnavailable: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .applicationBinding(Application.Binding.protectedDataWillBecomeUnavailable(v)) }) }
	public static var protectedDataDidBecomeAvailable: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .applicationBinding(Application.Binding.protectedDataDidBecomeAvailable(v)) }) }
	public static var didReceiveMemoryWarning: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .applicationBinding(Application.Binding.didReceiveMemoryWarning(v)) }) }
	public static var significantTimeChange: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .applicationBinding(Application.Binding.significantTimeChange(v)) }) }
	public static var performFetch: BindingName<SignalInput<SignalInput<UIBackgroundFetchResult>>, Binding> { return BindingName<SignalInput<SignalInput<UIBackgroundFetchResult>>, Binding>({ v in .applicationBinding(Application.Binding.performFetch(v)) }) }
	public static var handleEventsForBackgroundURLSession: BindingName<SignalInput<Callback<String, ()>>, Binding> { return BindingName<SignalInput<Callback<String, ()>>, Binding>({ v in .applicationBinding(Application.Binding.handleEventsForBackgroundURLSession(v)) }) }
	public static var registerForRemoteNotifications: BindingName<Signal<Bool>, Binding> { return BindingName<Signal<Bool>, Binding>({ v in .applicationBinding(Application.Binding.registerForRemoteNotifications(v)) }) }
	public static var didRegisterRemoteNotifications: BindingName<SignalInput<Result<Data>>, Binding> { return BindingName<SignalInput<Result<Data>>, Binding>({ v in .applicationBinding(Application.Binding.didRegisterRemoteNotifications(v)) }) }
	public static var didReceiveRemoteNotification: BindingName<SignalInput<Callback<[AnyHashable: Any], UIBackgroundFetchResult>>, Binding> { return BindingName<SignalInput<Callback<[AnyHashable: Any], UIBackgroundFetchResult>>, Binding>({ v in .applicationBinding(Application.Binding.didReceiveRemoteNotification(v)) }) }
	public static var didFailToContinueUserActivity: BindingName<SignalInput<(String, Error)>, Binding> { return BindingName<SignalInput<(String, Error)>, Binding>({ v in .applicationBinding(Application.Binding.didFailToContinueUserActivity(v)) }) }
	public static var performAction: BindingName<SignalInput<Callback<UIApplicationShortcutItem, Bool>>, Binding> { return BindingName<SignalInput<Callback<UIApplicationShortcutItem, Bool>>, Binding>({ v in .applicationBinding(Application.Binding.performAction(v)) }) }
	public static var handleWatchKitExtensionRequest: BindingName<SignalInput<Callback<([AnyHashable: Any]?), [AnyHashable: Any]?>>, Binding> { return BindingName<SignalInput<Callback<([AnyHashable: Any]?), [AnyHashable: Any]?>>, Binding>({ v in .applicationBinding(Application.Binding.handleWatchKitExtensionRequest(v)) }) }
	public static var willContinueUserActivity: BindingName<(String) -> Bool, Binding> { return BindingName<(String) -> Bool, Binding>({ v in .applicationBinding(Application.Binding.willContinueUserActivity(v)) }) }
	public static var continueUserActivity: BindingName<(Callback<NSUserActivity, [UIUserActivityRestoring]?>) -> Bool, Binding> { return BindingName<(Callback<NSUserActivity, [UIUserActivityRestoring]?>) -> Bool, Binding>({ v in .applicationBinding(Application.Binding.continueUserActivity(v)) }) }
	public static var didUpdate: BindingName<(NSUserActivity) -> Void, Binding> { return BindingName<(NSUserActivity) -> Void, Binding>({ v in .applicationBinding(Application.Binding.didUpdate(v)) }) }
	public static var willFinishLaunching: BindingName<([UIApplication.LaunchOptionsKey: Any]?) -> Bool, Binding> { return BindingName<([UIApplication.LaunchOptionsKey: Any]?) -> Bool, Binding>({ v in .applicationBinding(Application.Binding.willFinishLaunching(v)) }) }
	public static var didFinishLaunching: BindingName<([UIApplication.LaunchOptionsKey: Any]?) -> Bool, Binding> { return BindingName<([UIApplication.LaunchOptionsKey: Any]?) -> Bool, Binding>({ v in .applicationBinding(Application.Binding.didFinishLaunching(v)) }) }
	public static var willEncodeRestorableState: BindingName<(NSKeyedArchiver) -> Void, Binding> { return BindingName<(NSKeyedArchiver) -> Void, Binding>({ v in .applicationBinding(Application.Binding.willEncodeRestorableState(v)) }) }
	public static var didDecodeRestorableState: BindingName<(NSKeyedUnarchiver) -> Void, Binding> { return BindingName<(NSKeyedUnarchiver) -> Void, Binding>({ v in .applicationBinding(Application.Binding.didDecodeRestorableState(v)) }) }
	public static var willTerminate: BindingName<() -> Void, Binding> { return BindingName<() -> Void, Binding>({ v in .applicationBinding(Application.Binding.willTerminate(v)) }) }
	public static var shouldSaveApplicationState: BindingName<(_ coder: NSCoder) -> Bool, Binding> { return BindingName<(_ coder: NSCoder) -> Bool, Binding>({ v in .applicationBinding(Application.Binding.shouldSaveApplicationState(v)) }) }
	public static var shouldRestoreApplicationState: BindingName<(_ coder: NSCoder) -> Bool, Binding> { return BindingName<(_ coder: NSCoder) -> Bool, Binding>({ v in .applicationBinding(Application.Binding.shouldRestoreApplicationState(v)) }) }
	public static var viewControllerWithRestorationPath: BindingName<(_ path: [String], _ coder: NSCoder) -> UIViewController, Binding> { return BindingName<(_ path: [String], _ coder: NSCoder) -> UIViewController, Binding>({ v in .applicationBinding(Application.Binding.viewControllerWithRestorationPath(v)) }) }
	public static var open: BindingName<(_ url: URL, _ options: [UIApplication.OpenURLOptionsKey: Any]) -> Bool, Binding> { return BindingName<(_ url: URL, _ options: [UIApplication.OpenURLOptionsKey: Any]) -> Bool, Binding>({ v in .applicationBinding(Application.Binding.open(v)) }) }
	public static var shouldAllowExtensionPointIdentifier: BindingName<(UIApplication.ExtensionPointIdentifier) -> Bool, Binding> { return BindingName<(UIApplication.ExtensionPointIdentifier) -> Bool, Binding>({ v in .applicationBinding(Application.Binding.shouldAllowExtensionPointIdentifier(v)) }) }
	public static var shouldRequestHealthAuthorization: BindingName<() -> Void, Binding> { return BindingName<() -> Void, Binding>({ v in .applicationBinding(Application.Binding.shouldRequestHealthAuthorization(v)) }) }
}

public protocol ApplicationBinding: BaseBinding {
	static func applicationBinding(_ binding: Application.Binding) -> Self
}
extension ApplicationBinding {
	public static func baseBinding(_ binding: BaseBinder.Binding) -> Self {
		return applicationBinding(.inheritedBinding(binding))
	}
}

#if os(macOS)
	import AppKit
#else
	import UIKit
#endif

public class TabBarController<ItemIdentifier: Hashable>: ConstructingBinder, TabBarControllerConvertible {
	public typealias Instance = UITabBarController
	public typealias Inherited = ViewController
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiTabBarController() -> Instance { return instance() }
	
	public enum Binding: TabBarControllerBinding {
		public typealias ItemIdentifierType = ItemIdentifier
		public typealias EnclosingBinder = TabBarController
		public static func tabBarControllerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case tabBar(Constant<TabBar<ItemIdentifier>>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case items(Dynamic<SetOrAnimate<[ItemIdentifier]>>)
		case customizableItems(Dynamic<Set<ItemIdentifier>>)

		// 2. Signal bindings are performed on the object after construction.
		case selectItem(Signal<ItemIdentifier>)

		// 3. Action bindings are triggered by the object after construction.
		case didSelect(SignalInput<ItemIdentifier>)
		case willBeginCustomizing(SignalInput<[ItemIdentifier]>)
		case willEndCustomizing(SignalInput<([ItemIdentifier], Bool)>)
		case didEndCustomizing(SignalInput<([ItemIdentifier], Bool)>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case tabConstructor((ItemIdentifier) -> ViewControllerConvertible)
		case shouldSelect((ItemIdentifier) -> Bool)
		case supportedInterfaceOrientations(() -> UIInterfaceOrientationMask)
		case preferredInterfaceOrientationForPresentation(() -> UIInterfaceOrientation)
		case interactionControllerForAnimation((UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?)
		case animationControllerForTransition((UIViewController, UIViewController) -> UIViewControllerAnimatedTransitioning?)
	}

	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = TabBarController
		public var linkedPreparer = Inherited.Preparer()

		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }

		public init() {
			self.init(delegateClass: Delegate.self)
		}
		public init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		public let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		var tabConstructor: ((ItemIdentifier) -> ViewControllerConvertible)?
		
		public mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .tabConstructor(let x): tabConstructor = x
			case .shouldSelect(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarController(_:shouldSelect:))
				delegate().addSelector(s).shouldSelect = x
			case .supportedInterfaceOrientations(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarControllerSupportedInterfaceOrientations(_:))
				delegate().addSelector(s).supportedInterfaceOrientations = x
			case .preferredInterfaceOrientationForPresentation(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarControllerPreferredInterfaceOrientationForPresentation(_:))
				delegate().addSelector(s).preferredInterfaceOrientationForPresentation = x
			case .interactionControllerForAnimation(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarController(_:interactionControllerFor:))
				delegate().addSelector(s).interactionControllerForAnimation = x
			case .animationControllerForTransition(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarController(_:animationControllerForTransitionFrom:to:))
				delegate().addSelector(s).animationControllerForTransition = x
			case .willBeginCustomizing(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarController(_:willBeginCustomizing:))
				delegate().addSelector(s).willBeginCustomizing = x
			case .willEndCustomizing(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarController(_:willEndCustomizing:changed:))
				delegate().addSelector(s).willEndCustomizing = x
			case .didEndCustomizing(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarController(_:didEndCustomizing:changed:))
				delegate().addSelector(s).didEndCustomizing = x
			case .didSelect(let x):
				let s = #selector(UITabBarControllerDelegate.tabBarController(_:didSelect:))
				delegate().addSelector(s).didSelect = x
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		public mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")

			storage.dynamicDelegate = possibleDelegate
			storage.tabConstructor = tabConstructor

			if storage.inUse {
				instance.delegate = storage
			}
			
			linkedPreparer.prepareInstance(instance, storage: storage)
		}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .tabBar(let x):
				x.value.applyBindings(to: instance.tabBar)
				return nil
			case .items(let x):
				return x.apply(instance, storage) { inst, stor, val in
					let items = val.value.compactMap { stor.viewController(for: $0) }
					inst.setViewControllers(items, animated: val.isAnimated)
				}
			case .customizableItems(let x):
				return x.apply(instance, storage) { inst, stor, val in
					inst.customizableViewControllers = val.compactMap { stor.viewController(for: $0) }
				}
			case .selectItem(let x):
				return x.apply(instance, storage) { inst, stor, val in
					if let vc = stor.viewController(for: val), let index = inst.viewControllers?.index(of: vc) {
						inst.selectedIndex = index
					}
				}
			case .tabConstructor: return nil
			case .didSelect: return nil
			case .willBeginCustomizing: return nil
			case .willEndCustomizing: return nil
			case .didEndCustomizing: return nil
			case .shouldSelect: return nil
			case .supportedInterfaceOrientations: return nil
			case .preferredInterfaceOrientationForPresentation: return nil
			case .interactionControllerForAnimation: return nil
			case .animationControllerForTransition: return nil
			case .inheritedBinding(let b): return linkedPreparer.applyBinding(b, instance: instance, storage: storage)
			}
		}
	}

	open class Storage: ViewController.Storage, UITabBarControllerDelegate {
		open var tabConstructor: ((ItemIdentifier) -> ViewControllerConvertible)?
		open var allItems: [ItemIdentifier: ViewControllerConvertible] = [:]
		
		open override var inUse: Bool { return true }
		
		open func identifier(for viewController: UIViewController) -> ItemIdentifier? {
			return allItems.first(where: { pair -> Bool in
				pair.value.uiViewController() === viewController
			})?.key
		}
		open func viewController(for identifier: ItemIdentifier) -> UIViewController? {
			if let existing = allItems[identifier] {
				return existing.uiViewController()
			}
			if let constructor = tabConstructor {
				let new = constructor(identifier)
				allItems[identifier] = new
				return new.uiViewController()
			}
			return nil
		}
	}
	
	open class Delegate: DynamicDelegate, UITabBarControllerDelegate {
		public required override init() {
			super.init()
		}

		open var didSelect: SignalInput<ItemIdentifier>?
		open func tabBarController(_ tabBarController: UITabBarController, didSelect viewController: UIViewController) {
			if let identifier = (tabBarController.delegate as? Storage)?.identifier(for: viewController) {
				didSelect?.send(value: identifier)
			}
		}

		open var willBeginCustomizing: SignalInput<[ItemIdentifier]>?
		open func tabBarController(_ tabBarController: UITabBarController, willBeginCustomizing viewControllers: [UIViewController]) {
			if let storage = tabBarController.delegate as? Storage {
				willBeginCustomizing?.send(value: viewControllers.compactMap { storage.identifier(for: $0) })
			}
		}

		open var didBeginCustomizing: SignalInput<[ItemIdentifier]>?
		open func tabBarController(_ tabBarController: UITabBarController, didBeginCustomizing viewControllers: [UIViewController]) {
			if let storage = tabBarController.delegate as? Storage {
				didBeginCustomizing?.send(value: viewControllers.compactMap { storage.identifier(for: $0) })
			}
		}

		open var willEndCustomizing: SignalInput<([ItemIdentifier], Bool)>?
		open func tabBarController(_ tabBarController: UITabBarController, willEndCustomizing viewControllers: [UIViewController], changed: Bool) {
			if let storage = tabBarController.delegate as? Storage {
				willEndCustomizing?.send(value: (viewControllers.compactMap { storage.identifier(for: $0) }, changed))
			}
		}

		open var didEndCustomizing: SignalInput<([ItemIdentifier], Bool)>?
		open func tabBarController(_ tabBarController: UITabBarController, didEndCustomizing viewControllers: [UIViewController], changed: Bool) {
			if let storage = tabBarController.delegate as? Storage {
				didEndCustomizing?.send(value: (viewControllers.compactMap { storage.identifier(for: $0) }, changed))
			}
		}
		
		open var shouldSelect: ((ItemIdentifier) -> Bool)?
		open func tabBarController(_ tabBarController: UITabBarController, shouldSelect viewController: UIViewController) -> Bool {
			if let storage = tabBarController.delegate as? Storage, let identifier = storage.identifier(for: viewController) {
				return shouldSelect!(identifier)
			}
			return false
		}
		
		open var supportedInterfaceOrientations: (() -> UIInterfaceOrientationMask)?
		open func tabBarControllerSupportedInterfaceOrientations(_ tabBarController: UITabBarController) -> UIInterfaceOrientationMask {
			return supportedInterfaceOrientations!()
		}
		
		open var preferredInterfaceOrientationForPresentation: (() -> UIInterfaceOrientation)?
		open func tabBarControllerPreferredInterfaceOrientationForPresentation(_ tabBarController: UITabBarController) -> UIInterfaceOrientation {
			return preferredInterfaceOrientationForPresentation!()
		}
		
		open var interactionControllerForAnimation: ((UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?)?
		open func tabBarController(_ tabBarController: UITabBarController, interactionControllerFor animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning? {
			return interactionControllerForAnimation!(animationController)
		}
		
		open var animationControllerForTransition: ((UIViewController, UIViewController) -> UIViewControllerAnimatedTransitioning?)?
		open func tabBarController(_ tabBarController: UITabBarController, animationControllerForTransitionFrom fromVC: UIViewController, to toVC: UIViewController) -> UIViewControllerAnimatedTransitioning? {
			return animationControllerForTransition!(fromVC, toVC)
		}
	}
}

extension BindingName where Binding: TabBarControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` by copying them to here and using the following Xcode-style regex:
	// Find:    case ([^\(]+)\((.+)\)$
	// Replace: public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.$1(v)) }) }
	public static var tabBar: BindingName<Constant<TabBar<Binding.ItemIdentifierType>>, Binding> { return BindingName<Constant<TabBar<Binding.ItemIdentifierType>>, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.tabBar(v)) }) }
	public static var items: BindingName<Dynamic<SetOrAnimate<[Binding.ItemIdentifierType]>>, Binding> { return BindingName<Dynamic<SetOrAnimate<[Binding.ItemIdentifierType]>>, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.items(v)) }) }
	public static var customizableItems: BindingName<Dynamic<Set<Binding.ItemIdentifierType>>, Binding> { return BindingName<Dynamic<Set<Binding.ItemIdentifierType>>, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.customizableItems(v)) }) }
	public static var selectItem: BindingName<Signal<Binding.ItemIdentifierType>, Binding> { return BindingName<Signal<Binding.ItemIdentifierType>, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.selectItem(v)) }) }
	public static var didSelect: BindingName<SignalInput<Binding.ItemIdentifierType>, Binding> { return BindingName<SignalInput<Binding.ItemIdentifierType>, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.didSelect(v)) }) }
	public static var willBeginCustomizing: BindingName<SignalInput<[Binding.ItemIdentifierType]>, Binding> { return BindingName<SignalInput<[Binding.ItemIdentifierType]>, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.willBeginCustomizing(v)) }) }
	public static var willEndCustomizing: BindingName<SignalInput<([Binding.ItemIdentifierType], Bool)>, Binding> { return BindingName<SignalInput<([Binding.ItemIdentifierType], Bool)>, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.willEndCustomizing(v)) }) }
	public static var didEndCustomizing: BindingName<SignalInput<([Binding.ItemIdentifierType], Bool)>, Binding> { return BindingName<SignalInput<([Binding.ItemIdentifierType], Bool)>, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.didEndCustomizing(v)) }) }
	public static var tabConstructor: BindingName<(Binding.ItemIdentifierType) -> ViewControllerConvertible, Binding> { return BindingName<(Binding.ItemIdentifierType) -> ViewControllerConvertible, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.tabConstructor(v)) }) }
	public static var shouldSelect: BindingName<(Binding.ItemIdentifierType) -> Bool, Binding> { return BindingName<(Binding.ItemIdentifierType) -> Bool, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.shouldSelect(v)) }) }
	public static var supportedInterfaceOrientations: BindingName<() -> UIInterfaceOrientationMask, Binding> { return BindingName<() -> UIInterfaceOrientationMask, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.supportedInterfaceOrientations(v)) }) }
	public static var preferredInterfaceOrientationForPresentation: BindingName<() -> UIInterfaceOrientation, Binding> { return BindingName<() -> UIInterfaceOrientation, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.preferredInterfaceOrientationForPresentation(v)) }) }
	public static var interactionControllerForAnimation: BindingName<(UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?, Binding> { return BindingName<(UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning?, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.interactionControllerForAnimation(v)) }) }
	public static var animationControllerForTransition: BindingName<(UIViewController, UIViewController) -> UIViewControllerAnimatedTransitioning?, Binding> { return BindingName<(UIViewController, UIViewController) -> UIViewControllerAnimatedTransitioning?, Binding>({ v in .tabBarControllerBinding(TabBarController<Binding.ItemIdentifierType>.Binding.animationControllerForTransition(v)) }) }
}

public protocol TabBarControllerConvertible {
	func uiTabBarController() -> UITabBarController
}
extension TabBarControllerConvertible {
	public func uiViewController() -> ViewController.Instance { return uiTabBarController() }
}
extension TabBarController.Instance: TabBarControllerConvertible {
	public func uiTabBarController() -> UITabBarController { return self }
}

public protocol TabBarControllerBinding: ViewControllerBinding {
	associatedtype ItemIdentifierType: Hashable
	static func tabBarControllerBinding(_ binding: TabBarController<ItemIdentifierType>.Binding) -> Self
}
extension TabBarControllerBinding {
	public static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return tabBarControllerBinding(.inheritedBinding(binding))
	}
}

public class ImageView: ConstructingBinder, ImageViewConvertible {
	public typealias Instance = UIImageView
	public typealias Inherited = View
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiImageView() -> Instance { return instance() }
	
	public enum Binding: ImageViewBinding {
		public typealias EnclosingBinder = ImageView
		public static func imageViewBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case image(Dynamic<UIImage?>)
		case highlightedImage(Dynamic<UIImage?>)
		case animationImages(Dynamic<[UIImage]?>)
		case highlightedAnimationImages(Dynamic<[UIImage]?>)
		case animationDuration(Dynamic<TimeInterval>)
		case animationRepeatCount(Dynamic<Int>)
		case isHighlighted(Dynamic<Bool>)
		
		// 2. Signal bindings are performed on the object after construction.
		case animating(Signal<Bool>)
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = ImageView
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance {
			return subclass.init(image: initialImage ?? nil, highlightedImage: initialHighlightedImage ?? nil)
		}
		
		var image = InitialSubsequent<UIImage?>()
		var initialImage: UIImage?? = nil
		var highlightedImage = InitialSubsequent<UIImage?>()
		var initialHighlightedImage: UIImage?? = nil
		
		public init() {}
		
		public mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .image(let x):
				image = x.initialSubsequent()
				initialImage = image.initial()
			case .highlightedImage(let x):
				highlightedImage = x.initialSubsequent()
				initialHighlightedImage = highlightedImage.initial()
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .image: return image.subsequent.flatMap { $0.apply(instance, storage) { i, s, v in i.image = v } }
			case .highlightedImage: return highlightedImage.subsequent.flatMap { $0.apply(instance, storage) { i, s, v in i.highlightedImage = v } }
			case .animationImages(let x): return x.apply(instance, storage) { i, s, v in i.animationImages = v }
			case .highlightedAnimationImages(let x): return x.apply(instance, storage) { i, s, v in i.highlightedAnimationImages = v }
			case .animationDuration(let x): return x.apply(instance, storage) { i, s, v in i.animationDuration = v }
			case .animationRepeatCount(let x): return x.apply(instance, storage) { i, s, v in i.animationRepeatCount = v }
			case .isHighlighted(let x): return x.apply(instance, storage) { i, s, v in i.isHighlighted = v }
			case .animating(let x):
				return x.apply(instance, storage) { i, s, v in
					if v && !i.isAnimating {
						i.startAnimating()
					} else if !v && i.isAnimating {
						i.stopAnimating()
					}
				}
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	public typealias Storage = View.Storage
}

extension BindingName where Binding: ImageViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .imageViewBinding(ImageView.Binding.$1(v)) }) }
	public static var image: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .imageViewBinding(ImageView.Binding.image(v)) }) }
	public static var highlightedImage: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .imageViewBinding(ImageView.Binding.highlightedImage(v)) }) }
	public static var animationImages: BindingName<Dynamic<[UIImage]?>, Binding> { return BindingName<Dynamic<[UIImage]?>, Binding>({ v in .imageViewBinding(ImageView.Binding.animationImages(v)) }) }
	public static var highlightedAnimationImages: BindingName<Dynamic<[UIImage]?>, Binding> { return BindingName<Dynamic<[UIImage]?>, Binding>({ v in .imageViewBinding(ImageView.Binding.highlightedAnimationImages(v)) }) }
	public static var animationDuration: BindingName<Dynamic<TimeInterval>, Binding> { return BindingName<Dynamic<TimeInterval>, Binding>({ v in .imageViewBinding(ImageView.Binding.animationDuration(v)) }) }
	public static var animationRepeatCount: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .imageViewBinding(ImageView.Binding.animationRepeatCount(v)) }) }
	public static var isHighlighted: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .imageViewBinding(ImageView.Binding.isHighlighted(v)) }) }
	public static var animating: BindingName<Signal<Bool>, Binding> { return BindingName<Signal<Bool>, Binding>({ v in .imageViewBinding(ImageView.Binding.animating(v)) }) }
}

public protocol ImageViewConvertible: ViewConvertible {
	func uiImageView() -> ImageView.Instance
}
extension ImageViewConvertible {
	public func uiView() -> View.Instance { return uiImageView() }
}
extension ImageView.Instance: ImageViewConvertible {
	public func uiImageView() -> ImageView.Instance { return self }
}

public protocol ImageViewBinding: ViewBinding {
	static func imageViewBinding(_ binding: ImageView.Binding) -> Self
}

extension ImageViewBinding {
	public static func viewBinding(_ binding: View.Binding) -> Self {
		return imageViewBinding(.inheritedBinding(binding))
	}
}

public class AlertController: ConstructingBinder, AlertControllerConvertible {
	public typealias Instance = UIAlertController
	public typealias Inherited = ViewController
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiAlertController() -> Instance { return instance() }
	
	public enum Binding: AlertControllerBinding {
		public typealias EnclosingBinder = AlertController
		public static func alertControllerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case preferredStyle(Constant<UIAlertController.Style>)
		case textFields(Constant<[TextField]>)
		case actions(Constant<[AlertActionConvertible]>)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case message(Dynamic<String?>)
		case preferredActionIndex(Dynamic<Int?>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = AlertController
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance {
			return subclass.init(title: initialTitle, message: initialMessage ?? nil, preferredStyle: preferredStyle)
		}
		
		var title = InitialSubsequent<String>()
		var initialTitle: String? = nil
		var message = InitialSubsequent<String?>()
		var initialMessage: String?? = nil
		var preferredStyle: UIAlertController.Style = .alert
		
		public init() {}
		
		public mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .preferredStyle(let x): preferredStyle = x.value
			case .message(let x):
				message = x.initialSubsequent()
				initialMessage = message.initial()
			case .inheritedBinding(.title(let x)):
				title = x.initialSubsequent()
				initialTitle = title.initial()
			case .inheritedBinding(let s): return linkedPreparer.prepareBinding(s)
			default: break
			}
		}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .preferredStyle: return nil
			case .actions(let x):
				for a in x.value {
					instance.addAction(a.uiAlertAction())
				}
				return nil
			case .textFields(let x):
				for bindings in x.value {
					instance.addTextField { textField in
						bindings.applyBindings(to: textField)
					}
				}
				return nil
			case .message(let x): return x.apply(instance, storage) { i, s, v in i.message = v }
			case .preferredActionIndex(let x):
				return x.apply(instance, storage) { i, s, v in
					i.preferredAction = v.map { i.actions[$0] }
				}
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	public typealias Storage = ViewController.Storage
}

extension BindingName where Binding: AlertControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .alertControllerBinding(AlertController.Binding.$1(v)) }) }
	public static var preferredStyle: BindingName<Constant<UIAlertController.Style>, Binding> { return BindingName<Constant<UIAlertController.Style>, Binding>({ v in .alertControllerBinding(AlertController.Binding.preferredStyle(v)) }) }
	public static var textFields: BindingName<Constant<[TextField]>, Binding> { return BindingName<Constant<[TextField]>, Binding>({ v in .alertControllerBinding(AlertController.Binding.textFields(v)) }) }
	public static var actions: BindingName<Constant<[AlertActionConvertible]>, Binding> { return BindingName<Constant<[AlertActionConvertible]>, Binding>({ v in .alertControllerBinding(AlertController.Binding.actions(v)) }) }
	public static var message: BindingName<Dynamic<String?>, Binding> { return BindingName<Dynamic<String?>, Binding>({ v in .alertControllerBinding(AlertController.Binding.message(v)) }) }
	public static var preferredActionIndex: BindingName<Dynamic<Int?>, Binding> { return BindingName<Dynamic<Int?>, Binding>({ v in .alertControllerBinding(AlertController.Binding.preferredActionIndex(v)) }) }
}

public protocol AlertControllerConvertible: ViewControllerConvertible {
	func uiAlertController() -> AlertController.Instance
}
extension AlertControllerConvertible {
	public func uiViewController() -> ViewController.Instance { return uiAlertController() }
}
extension AlertController.Instance: AlertControllerConvertible {
	public func uiAlertController() -> AlertController.Instance { return self }
}

public protocol AlertControllerBinding: ViewControllerBinding {
	static func alertControllerBinding(_ binding: AlertController.Binding) -> Self
}
extension AlertControllerBinding {
	public static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return alertControllerBinding(.inheritedBinding(binding))
	}
}

#if os(macOS)
	import AppKit
#else
	import UIKit
#endif

public class PageViewController<PageData>: ConstructingBinder, PageViewControllerConvertible {
	public typealias Instance = UIPageViewController
	public typealias Inherited = ViewController
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiPageViewController() -> Instance { return instance() }
	
	public enum Binding: PageViewControllerBinding {
		public typealias PageDataType = PageData
		
		public typealias EnclosingBinder = PageViewController
		public static func pageViewControllerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 0. Static bindings are applied at construction and are subsequently immutable.
		// e.g. case someProperty(Constant<PropertyType>)
		case transitionStyle(Constant<UIPageViewController.TransitionStyle>)
		case navigationOrientation(Constant<UIPageViewController.NavigationOrientation>)
		case spineLocation(Constant<UIPageViewController.SpineLocation>)
		case pageSpacing(Constant<CGFloat>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case pageData(Dynamic<SetAnimatable<[PageData], UIPageViewController.NavigationDirection>>)
		case isDoubleSided(Dynamic<Bool>)

		// 2. Signal bindings are performed on the object after construction.
		// e.g. case someFunction(Signal<FunctionParametersAsTuple>)

		// 3. Action bindings are triggered by the object after construction.
		// e.g. case someAction(SignalInput<CallbackParameters>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case constructPage((PageData) -> ViewControllerConvertible)
		case willTransitionTo(([UIViewController]) -> Void)
		case didFinishAnimating((Bool, [UIViewController], Bool) -> Void)
		case spineLocationFor((UIInterfaceOrientation) -> UIPageViewController.SpineLocation)
		case supportedInterfaceOrientations(() -> UIInterfaceOrientationMask)
		case interfaceOrientationForPresentation(() -> UIInterfaceOrientation)
	}

	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = PageViewController
		public var linkedPreparer = Inherited.Preparer()

		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		public init() {
			self.init(delegateClass: Delegate.self)
		}
		public init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		public let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		var transitionStyle = UIPageViewController.TransitionStyle.scroll
		var navigationOrientation = UIPageViewController.NavigationOrientation.horizontal
		var spineLocation = UIPageViewController.SpineLocation.min
		var pageSpacing = CGFloat(0)
		var pageConstructor: ((PageData) -> ViewControllerConvertible)?
		
		public mutating func prepareBinding(_ binding: PageViewController<PageData>.Binding) {
			switch binding {
			case .constructPage(let x): pageConstructor = x
			case .transitionStyle(let x): transitionStyle = x.value
			case .navigationOrientation(let x): navigationOrientation = x.value
			case .spineLocation(let x): spineLocation = x.value
			case .pageSpacing(let x): pageSpacing = x.value
			case .inheritedBinding(let x): return linkedPreparer.prepareBinding(x)
			case .willTransitionTo(let x):
				let s = #selector(UIPageViewControllerDelegate.pageViewController(_:willTransitionTo:))
				delegate().addSelector(s).willTransitionTo = x
			case .didFinishAnimating(let x):
				let s = #selector(UIPageViewControllerDelegate.pageViewController(_:didFinishAnimating:previousViewControllers:transitionCompleted:))
				delegate().addSelector(s).didFinishAnimating = x
			case .spineLocationFor(let x):
				let s = #selector(UIPageViewControllerDelegate.pageViewController(_:spineLocationFor:))
				delegate().addSelector(s).spineLocationFor = x
			case .supportedInterfaceOrientations(let x):
				let s = #selector(UIPageViewControllerDelegate.pageViewControllerSupportedInterfaceOrientations(_:))
				delegate().addSelector(s).supportedInterfaceOrientations = x
			case .interfaceOrientationForPresentation(let x):
				let s = #selector(UIPageViewControllerDelegate.pageViewControllerPreferredInterfaceOrientationForPresentation(_:))
				delegate().addSelector(s).interfaceOrientationForPresentation = x
			default: break
			}
		}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .pageData(let x):
				return x.apply(instance, storage) { inst, stor, val in
					stor.changePageData(val.value, in: inst, animation: val.animation)
				}
			case .isDoubleSided(let x): return x.apply(instance, storage) { inst, stor, val in inst.isDoubleSided = val }
			case .constructPage: return nil
			case .transitionStyle: return nil
			case .navigationOrientation: return nil
			case .spineLocation: return nil
			case .pageSpacing: return nil
			case .inheritedBinding(let b): return linkedPreparer.applyBinding(b, instance: instance, storage: storage)
			case .willTransitionTo: return nil
			case .didFinishAnimating: return nil
			case .spineLocationFor: return nil
			case .supportedInterfaceOrientations: return nil
			case .interfaceOrientationForPresentation: return nil
			}
		}
	}

	open class Storage: ViewController.Storage, UIPageViewControllerDelegate, UIPageViewControllerDataSource {
		public func pageViewController(_ pageViewController: UIPageViewController, viewControllerBefore viewController: UIViewController) -> UIViewController? {
			if let i = index(of: viewController) {
				return self.viewController(at: i - 1)
			}
			return nil
		}
		
		public func pageViewController(_ pageViewController: UIPageViewController, viewControllerAfter viewController: UIViewController) -> UIViewController? {
			if let i = index(of: viewController) {
				return self.viewController(at: i + 1)
			}
			return nil
		}
		
		open var pageData: [PageData] = []
		open var activeViewControllers: [(Int, Weak<UIViewController>)] = []
		open var pageConstructor: ((PageData) -> ViewControllerConvertible)?
		
		open func changePageData(_ newPageData: [PageData], in pvc: UIPageViewController, animation: UIPageViewController.NavigationDirection?) {
			let indexes = pvc.viewControllers?.compactMap { self.index(of: $0) }.sorted() ?? (newPageData.isEmpty ? [] : [0])
			pageData = newPageData
			activeViewControllers.removeAll()
			let newViewControllers = indexes.compactMap { self.viewController(at: $0) }
			pvc.setViewControllers(newViewControllers, direction: animation ?? .forward, animated: animation != nil, completion: nil)
		}
		
		open func viewController(at: Int) -> UIViewController? {
			guard let constructor = pageConstructor, pageData.indices.contains(at) else { return nil }
			var i = 0
			var match: UIViewController? = nil
			while i < activeViewControllers.count {
				let tuple = activeViewControllers[i]
				if let vc = tuple.1.value {
					if tuple.0 == at {
						match = vc
					}
					i += 1
				} else {
					activeViewControllers.remove(at: i)
				}
			}
			if let m = match {
				return m
			}
			let vc = constructor(pageData[at]).uiViewController()
			activeViewControllers.append((at, Weak(vc)))
			return vc
		}
		
		open func index(of: UIViewController) -> Int? {
			var i = 0
			var match: Int? = nil
			while i < activeViewControllers.count {
				let tuple = activeViewControllers[i]
				if let vc = tuple.1.value {
					if vc === of {
						match = tuple.0
					}
					i += 1
				} else {
					activeViewControllers.remove(at: i)
				}
			}
			return match
		}
	}

	open class Delegate: DynamicDelegate, UIPageViewControllerDelegate {
		public required override init() {
			super.init()
		}
		
		open var willTransitionTo: (([UIViewController]) -> Void)?
		open func pageViewController(_ pageViewController: UIPageViewController, willTransitionTo pendingViewControllers: [UIViewController]) {
			willTransitionTo!(pendingViewControllers)
		}
		
		open var didFinishAnimating: ((Bool, [UIViewController], Bool) -> Void)?
		open func pageViewController(_ pageViewController: UIPageViewController, didFinishAnimating finished: Bool, previousViewControllers: [UIViewController], transitionCompleted completed: Bool) {
			didFinishAnimating!(finished, previousViewControllers, completed)
		}
		
		open var spineLocationFor: ((UIInterfaceOrientation) -> UIPageViewController.SpineLocation)?
		open func pageViewController(_ pageViewController: UIPageViewController, spineLocationFor orientation: UIInterfaceOrientation) -> UIPageViewController.SpineLocation {
			return spineLocationFor!(orientation)
		}
		
		open var supportedInterfaceOrientations: (() -> UIInterfaceOrientationMask)?
		open func pageViewControllerSupportedInterfaceOrientations(_ pageViewController: UIPageViewController) -> UIInterfaceOrientationMask {
			return supportedInterfaceOrientations!()
		}
		
		open var interfaceOrientationForPresentation: (() -> UIInterfaceOrientation)?
		open func pageViewControllerPreferredInterfaceOrientationForPresentation(_ pageViewController: UIPageViewController) -> UIInterfaceOrientation {
			return interfaceOrientationForPresentation!()
		}
	}
}

extension BindingName where Binding: PageViewControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` by copying them to here and using the following Xcode-style regex:
	// Find:    case ([^\(]+)\((.+)\)$
	// Replace: public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.$1(v)) }) }
	public static var transitionStyle: BindingName<Constant<UIPageViewController.TransitionStyle>, Binding> { return BindingName<Constant<UIPageViewController.TransitionStyle>, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.transitionStyle(v)) }) }
	public static var navigationOrientation: BindingName<Constant<UIPageViewController.NavigationOrientation>, Binding> { return BindingName<Constant<UIPageViewController.NavigationOrientation>, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.navigationOrientation(v)) }) }
	public static var spineLocation: BindingName<Constant<UIPageViewController.SpineLocation>, Binding> { return BindingName<Constant<UIPageViewController.SpineLocation>, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.spineLocation(v)) }) }
	public static var pageSpacing: BindingName<Constant<CGFloat>, Binding> { return BindingName<Constant<CGFloat>, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.pageSpacing(v)) }) }
	public static var pageData: BindingName<Dynamic<SetAnimatable<[Binding.PageDataType], UIPageViewController.NavigationDirection>>, Binding> { return BindingName<Dynamic<SetAnimatable<[Binding.PageDataType], UIPageViewController.NavigationDirection>>, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.pageData(v)) }) }
	public static var isDoubleSided: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.isDoubleSided(v)) }) }
	public static var constructPage: BindingName<(Binding.PageDataType) -> ViewControllerConvertible, Binding> { return BindingName<(Binding.PageDataType) -> ViewControllerConvertible, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.constructPage(v)) }) }
	public static var willTransitionTo: BindingName<([UIViewController]) -> Void, Binding> { return BindingName<([UIViewController]) -> Void, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.willTransitionTo(v)) }) }
	public static var didFinishAnimating: BindingName<(Bool, [UIViewController], Bool) -> Void, Binding> { return BindingName<(Bool, [UIViewController], Bool) -> Void, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.didFinishAnimating(v)) }) }
	public static var spineLocationFor: BindingName<(UIInterfaceOrientation) -> UIPageViewController.SpineLocation, Binding> { return BindingName<(UIInterfaceOrientation) -> UIPageViewController.SpineLocation, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.spineLocationFor(v)) }) }
	public static var supportedInterfaceOrientations: BindingName<() -> UIInterfaceOrientationMask, Binding> { return BindingName<() -> UIInterfaceOrientationMask, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.supportedInterfaceOrientations(v)) }) }
	public static var interfaceOrientationForPresentation: BindingName<() -> UIInterfaceOrientation, Binding> { return BindingName<() -> UIInterfaceOrientation, Binding>({ v in .pageViewControllerBinding(PageViewController.Binding.interfaceOrientationForPresentation(v)) }) }
}

public protocol PageViewControllerConvertible: ViewControllerConvertible {
	func uiPageViewController() -> UIPageViewController
}
extension PageViewControllerConvertible {
	public func uiViewController() -> ViewController.Instance { return uiPageViewController() }
}
extension PageViewController.Instance: PageViewControllerConvertible {
	public func uiPageViewController() -> UIPageViewController { return self }
}

public protocol PageViewControllerBinding: ViewControllerBinding {
	associatedtype PageDataType
	static func pageViewControllerBinding(_ binding: PageViewController<PageDataType>.Binding) -> Self
}
extension PageViewControllerBinding {
	public static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return pageViewControllerBinding(.inheritedBinding(binding))
	}
}

public class TableViewCell: Binder, TableViewCellConvertible {
	public typealias Instance = UITableViewCell
	public typealias Inherited = View
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func construct(reuseIdentifier: String?, additional: ((Instance) -> Lifetime?)? = nil) -> UITableViewCell {
		return binderConstruct(
			additional: additional,
			storageConstructor: { prep, params, i in prep.constructStorage() },
			instanceConstructor: { prep, params in prep.constructInstance(reuseIdentifier: reuseIdentifier, subclass: params.subclass) },
			combine: embedStorageIfInUse,
			output: { i, s in i })
	}
	public func uiTableViewCell(reuseIdentifier: String?) -> UITableViewCell {
		return construct(reuseIdentifier: reuseIdentifier)
	}
	
	public enum Binding: TableViewCellBinding {
		public typealias EnclosingBinder = TableViewCell
		public static func tableViewCellBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case cellStyle(Constant<UITableViewCell.CellStyle>)
		case textLabel(Constant<Label>)
		case detailLabel(Constant<Label>)
		case imageView(Constant<ImageView>)
		case contentView(Constant<View>)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case backgroundView(Dynamic<ViewConvertible?>)
		case selectedBackgroundView(Dynamic<ViewConvertible?>)
		case multipleSelectionBackgroundView(Dynamic<ViewConvertible?>)
		case accessoryType(Dynamic<UITableViewCell.AccessoryType>)
		case accessoryView(Dynamic<ViewConvertible>)
		case editingAccessoryType(Dynamic<UITableViewCell.AccessoryType>)
		case editingAccessoryView(Dynamic<ViewConvertible>)
		case isSelected(Dynamic<SetOrAnimate<Bool>>)
		case isHighlighted(Dynamic<SetOrAnimate<Bool>>)
		case isEditing(Dynamic<SetOrAnimate<Bool>>)
		case showsReorderControl(Dynamic<Bool>)
		case indentationLevel(Dynamic<Int>)
		case indentationWidth(Dynamic<CGFloat>)
		case shouldIndentWhileEditing(Dynamic<Bool>)
		case separatorInset(Dynamic<UIEdgeInsets>)
		case focusStyle(Dynamic<UITableViewCell.FocusStyle>)
		
		//	2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = TableViewCell
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init(style: cellStyle, reuseIdentifier: nil) }
		public func constructInstance(reuseIdentifier: String?, subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init(style: cellStyle, reuseIdentifier: reuseIdentifier) }
		
		public init() {}
		
		var cellStyle: UITableViewCell.CellStyle = .default
		
		public mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .cellStyle(let x): cellStyle = x.value
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .cellStyle: return nil
			case .textLabel(let x):
				if let l = instance.textLabel {
					x.value.applyBindings(to: l)
				}
				return nil
			case .detailLabel(let x):
				if let l = instance.detailTextLabel {
					x.value.applyBindings(to: l)
				}
				return nil
			case .imageView(let x):
				if let l = instance.imageView {
					x.value.applyBindings(to: l)
				}
				return nil
			case .contentView(let x):
				x.value.applyBindings(to: instance.contentView)
				return nil
			case .backgroundView(let x): return x.apply(instance, storage) { i, s, v in i.backgroundView = v?.uiView() }
			case .selectedBackgroundView(let x): return x.apply(instance, storage) { i, s, v in i.selectedBackgroundView = v?.uiView() }
			case .multipleSelectionBackgroundView(let x): return x.apply(instance, storage) { i, s, v in i.multipleSelectionBackgroundView = v?.uiView() }
			case .accessoryType(let x): return x.apply(instance, storage) { i, s, v in i.accessoryType = v }
			case .accessoryView(let x): return x.apply(instance, storage) { i, s, v in i.accessoryView = v.uiView() }
			case .editingAccessoryType(let x): return x.apply(instance, storage) { i, s, v in i.editingAccessoryType = v }
			case .editingAccessoryView(let x): return x.apply(instance, storage) { i, s, v in i.editingAccessoryView = v.uiView() }
			case .isSelected(let x): return x.apply(instance, storage) { i, s, v in i.setSelected(v.value, animated: v.isAnimated) }
			case .isHighlighted(let x): return x.apply(instance, storage) { i, s, v in i.setHighlighted(v.value, animated: v.isAnimated) }
			case .isEditing(let x): return x.apply(instance, storage) { i, s, v in i.setEditing(v.value, animated: v.isAnimated) }
			case .showsReorderControl(let x): return x.apply(instance, storage) { i, s, v in i.showsReorderControl = v }
			case .indentationLevel(let x): return x.apply(instance, storage) { i, s, v in i.indentationLevel = v }
			case .indentationWidth(let x): return x.apply(instance, storage) { i, s, v in i.indentationWidth = v }
			case .shouldIndentWhileEditing(let x): return x.apply(instance, storage) { i, s, v in i.shouldIndentWhileEditing = v }
			case .separatorInset(let x): return x.apply(instance, storage) { i, s, v in i.separatorInset = v }
			case .focusStyle(let x): return x.apply(instance, storage) { i, s, v in i.focusStyle = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	public typealias Storage = View.Storage
}

extension BindingName where Binding: TableViewCellBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.$1(v)) }) }
	public static var cellStyle: BindingName<Constant<UITableViewCell.CellStyle>, Binding> { return BindingName<Constant<UITableViewCell.CellStyle>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.cellStyle(v)) }) }
	public static var textLabel: BindingName<Constant<Label>, Binding> { return BindingName<Constant<Label>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.textLabel(v)) }) }
	public static var detailLabel: BindingName<Constant<Label>, Binding> { return BindingName<Constant<Label>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.detailLabel(v)) }) }
	public static var imageView: BindingName<Constant<ImageView>, Binding> { return BindingName<Constant<ImageView>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.imageView(v)) }) }
	public static var contentView: BindingName<Constant<View>, Binding> { return BindingName<Constant<View>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.contentView(v)) }) }
	public static var backgroundView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.backgroundView(v)) }) }
	public static var selectedBackgroundView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.selectedBackgroundView(v)) }) }
	public static var multipleSelectionBackgroundView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.multipleSelectionBackgroundView(v)) }) }
	public static var accessoryType: BindingName<Dynamic<UITableViewCell.AccessoryType>, Binding> { return BindingName<Dynamic<UITableViewCell.AccessoryType>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.accessoryType(v)) }) }
	public static var accessoryView: BindingName<Dynamic<ViewConvertible>, Binding> { return BindingName<Dynamic<ViewConvertible>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.accessoryView(v)) }) }
	public static var editingAccessoryType: BindingName<Dynamic<UITableViewCell.AccessoryType>, Binding> { return BindingName<Dynamic<UITableViewCell.AccessoryType>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.editingAccessoryType(v)) }) }
	public static var editingAccessoryView: BindingName<Dynamic<ViewConvertible>, Binding> { return BindingName<Dynamic<ViewConvertible>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.editingAccessoryView(v)) }) }
	public static var isSelected: BindingName<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingName<Dynamic<SetOrAnimate<Bool>>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.isSelected(v)) }) }
	public static var isHighlighted: BindingName<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingName<Dynamic<SetOrAnimate<Bool>>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.isHighlighted(v)) }) }
	public static var isEditing: BindingName<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingName<Dynamic<SetOrAnimate<Bool>>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.isEditing(v)) }) }
	public static var showsReorderControl: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.showsReorderControl(v)) }) }
	public static var indentationLevel: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.indentationLevel(v)) }) }
	public static var indentationWidth: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.indentationWidth(v)) }) }
	public static var shouldIndentWhileEditing: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.shouldIndentWhileEditing(v)) }) }
	public static var separatorInset: BindingName<Dynamic<UIEdgeInsets>, Binding> { return BindingName<Dynamic<UIEdgeInsets>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.separatorInset(v)) }) }
	public static var focusStyle: BindingName<Dynamic<UITableViewCell.FocusStyle>, Binding> { return BindingName<Dynamic<UITableViewCell.FocusStyle>, Binding>({ v in .tableViewCellBinding(TableViewCell.Binding.focusStyle(v)) }) }
}

public protocol TableViewCellConvertible: ViewConvertible {
	func uiTableViewCell(reuseIdentifier: String?) -> UITableViewCell
}
extension TableViewCellConvertible {
	public func uiView() -> UIView { return uiTableViewCell(reuseIdentifier: nil) }
}
extension UITableViewCell: TableViewCellConvertible {
	public func uiTableViewCell(reuseIdentifier: String?) -> UITableViewCell {
		return self
	}
}

public protocol TableViewCellBinding: ViewBinding {
	static func tableViewCellBinding(_ binding: TableViewCell.Binding) -> Self
}
extension TableViewCellBinding {
	public static func viewBinding(_ binding: View.Binding) -> Self {
		return tableViewCellBinding(.inheritedBinding(binding))
	}
}

public class TabBarItem: ConstructingBinder, TabBarItemConvertible {
	public typealias Instance = UITabBarItem
	public typealias Inherited = BarItem
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiTabBarItem() -> Instance { return instance() }
	
	public enum Binding: TabBarItemBinding {
		public typealias EnclosingBinder = TabBarItem
		public static func tabBarItemBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case systemItem(Constant<UITabBarItem.SystemItem?>)

		//	1. Value bindings may be applied at construction and may subsequently change.
		case selectedImage(Dynamic<UIImage?>)
		case titlePositionAdjustment(Dynamic<UIOffset>)
		case badgeValue(Dynamic<String?>)
		@available(iOS 10.0, *)
		case badgeColor(Dynamic<UIColor?>)
		@available(iOS 10.0, *)
		case badgeTextAttributes(Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key : Any]?>>)
		
		//	2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = TabBarItem
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance {
			let x: UITabBarItem
			if let si = systemItem {
				x = subclass.init(tabBarSystemItem: si, tag: tagInitial ?? 0)
			} else if let si = selectedImageInitial {
				x = subclass.init(title: titleInitial ?? nil, image: imageInitial ?? nil, selectedImage: si)
			} else {
				x = subclass.init(title: titleInitial ?? nil, image: imageInitial ?? nil, tag: tagInitial ?? 0)
			}
			return x
		}
		
		public var systemItem: UITabBarItem.SystemItem?
		public var title = InitialSubsequent<String>()
		public var titleInitial: String? = nil
		public var image = InitialSubsequent<UIImage?>()
		public var imageInitial: UIImage?? = nil
		public var selectedImage = InitialSubsequent<UIImage?>()
		public var selectedImageInitial: UIImage?? = nil
		public var tag = InitialSubsequent<Int>()
		public var tagInitial: Int? = nil
		
		public init() {}
		
		public mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .systemItem(let x): systemItem = x.value
			case .selectedImage(let x):
				selectedImage = x.initialSubsequent()
				selectedImageInitial = selectedImage.initial()
			case .inheritedBinding(.tag(let x)):
				tag = x.initialSubsequent()
				tagInitial = tag.initial()
			case .inheritedBinding(.image(let x)):
				image = x.initialSubsequent()
				imageInitial = image.initial()
			case .inheritedBinding(.title(let x)):
				title = x.initialSubsequent()
				titleInitial = title.initial()
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .badgeTextAttributes(let x):
				if #available(iOS 10.0, *) {
					var previous: ScopedValues<UIControl.State, [NSAttributedString.Key : Any]?>? = nil
					return x.apply(instance, storage) { i, s, v in
						if let p = previous {
							for c in p.pairs {
								i.setBadgeTextAttributes(nil, for: c.0)
							}
						}
						previous = v
						for c in v.pairs {
							i.setBadgeTextAttributes(c.1, for: c.0)
						}
					}
				} else {
					return nil
				}
			case .titlePositionAdjustment(let x): return x.apply(instance, storage) { i, s, v in i.titlePositionAdjustment = v }
			case .badgeValue(let x): return x.apply(instance, storage) { i, s, v in i.badgeValue = v }
			case .badgeColor(let x):
				return x.apply(instance, storage) { i, s, v in
					if #available(iOS 10.0, *) {
						i.badgeColor = v
					}
				}
			case .systemItem: return nil
			case .selectedImage: return selectedImage.resume()?.apply(instance, storage) { i, s, v in i.selectedImage = v }
			case .inheritedBinding(.tag): return tag.resume()?.apply(instance, storage) { i, s, v in i.tag = v }
			case .inheritedBinding(.image): return image.resume()?.apply(instance, storage) { i, s, v in i.image = v }
			case .inheritedBinding(.title): return title.resume()?.apply(instance, storage) { i, s, v in i.title = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	public typealias Storage = BarItem.Storage
}

extension BindingName where Binding: TabBarItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .tabBarItemBinding(TabBarItem.Binding.$1(v)) }) }
	public static var selectedImage: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .tabBarItemBinding(TabBarItem.Binding.selectedImage(v)) }) }
	public static var titlePositionAdjustment: BindingName<Dynamic<UIOffset>, Binding> { return BindingName<Dynamic<UIOffset>, Binding>({ v in .tabBarItemBinding(TabBarItem.Binding.titlePositionAdjustment(v)) }) }
	public static var badgeValue: BindingName<Dynamic<String?>, Binding> { return BindingName<Dynamic<String?>, Binding>({ v in .tabBarItemBinding(TabBarItem.Binding.badgeValue(v)) }) }
	@available(iOS 10.0, *)
	public static var badgeColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .tabBarItemBinding(TabBarItem.Binding.badgeColor(v)) }) }
	@available(iOS 10.0, *)
	public static var badgeTextAttributes: BindingName<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key : Any]?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key : Any]?>>, Binding>({ v in .tabBarItemBinding(TabBarItem.Binding.badgeTextAttributes(v)) }) }
}

public protocol TabBarItemConvertible: BarItemConvertible {
	func uiTabBarItem() -> TabBarItem.Instance
}
extension TabBarItemConvertible {
	public func uiBarItem() -> BarItem.Instance { return uiTabBarItem() }
}
extension TabBarItem.Instance: TabBarItemConvertible {
	public func uiTabBarItem() -> TabBarItem.Instance { return self }
}

public protocol TabBarItemBinding: BarItemBinding {
	static func tabBarItemBinding(_ binding: TabBarItem.Binding) -> Self
}
extension TabBarItemBinding {
	public static func barItemBinding(_ binding: BarItem.Binding) -> Self {
		return tabBarItemBinding(.inheritedBinding(binding))
	}
}

public class NavigationBar: ConstructingBinder, NavigationBarConvertible {
	public typealias Instance = UINavigationBar
	public typealias Inherited = View
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiNavigationBar() -> Instance { return instance() }
	
	public enum Binding: NavigationBarBinding {
		public typealias EnclosingBinder = NavigationBar
		public static func navigationBarBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case items(Dynamic<SetOrAnimate<[NavigationItemConvertible]>>)
		case backIndicatorImage(Dynamic<UIImage?>)
		case backIndicatorTransitionMaskImage(Dynamic<UIImage?>)
		case barStyle(Dynamic<UIBarStyle>)
		case barTintColor(Dynamic<UIColor?>)
		case shadowImage(Dynamic<UIImage?>)
		case tintColor(Dynamic<UIColor?>)
		case isTranslucent(Dynamic<Bool>)
		case titleTextAttributes(Dynamic<[NSAttributedString.Key: Any]>)
		case titleVerticalPositionAdjustment(Dynamic<ScopedValues<UIBarMetrics, CGFloat>>)
		case backgroundImage(Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		case didPush(SignalInput<UINavigationItem>)
		case didPop(SignalInput<UINavigationItem>)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case shouldPush((UINavigationBar, UINavigationItem) -> Bool)
		case shouldPop((UINavigationBar, UINavigationItem) -> Bool)
		case position((UIBarPositioning) -> UIBarPosition)
	}

	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = NavigationBar
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		public init() {
			self.init(delegateClass: Delegate.self)
		}
		public init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		public let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		public mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .shouldPush(let x):
				let s = #selector(UINavigationBarDelegate.navigationBar(_:shouldPush:))
				delegate().addSelector(s).shouldPush = x
			case .shouldPop(let x):
				let s = #selector(UINavigationBarDelegate.navigationBar(_:shouldPop:))
				delegate().addSelector(s).shouldPop = x
			case .position(let x):
				let s = #selector(UINavigationBarDelegate.position(for:))
				delegate().addSelector(s).position = x
			case .didPush(let x):
				let s = #selector(UINavigationBarDelegate.navigationBar(_:didPush:))
				delegate().addSelector(s).didPush = x
			case .didPop(let x):
				let s = #selector(UINavigationBarDelegate.navigationBar(_:didPop:))
				delegate().addSelector(s).didPop = x
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		public mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			// Don't steal the delegate from the navigation controller
			if possibleDelegate != nil {
				precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
				storage.dynamicDelegate = possibleDelegate
				instance.delegate = storage
			}
			
			linkedPreparer.prepareInstance(instance, storage: storage)
		}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .backgroundImage(let x):
				var previous: ScopedValues<PositionAndMetrics, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for conditions in p.pairs {
							if conditions.value != nil {
								i.setBackgroundImage(nil, for: conditions.scope.barPosition, barMetrics: conditions.scope.barMetrics)
							}
						}
					}
					previous = v
					for conditions in v.pairs {
						if let image = conditions.value {
							i.setBackgroundImage(image, for: conditions.scope.barPosition, barMetrics: conditions.scope.barMetrics)
						}
					}
				}
			case .titleVerticalPositionAdjustment(let x):
				var previous: ScopedValues<UIBarMetrics, CGFloat>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setTitleVerticalPositionAdjustment(0, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setTitleVerticalPositionAdjustment(c.1, for: c.0)
					}
				}
			case .items(let x): return x.apply(instance, storage) { i, s, v in i.setItems(v.value.map { $0.uiNavigationItem() }, animated: v.isAnimated) }
			case .backIndicatorImage(let x): return x.apply(instance, storage) { i, s, v in i.backIndicatorImage = v }
			case .backIndicatorTransitionMaskImage(let x): return x.apply(instance, storage) { i, s, v in i.backIndicatorTransitionMaskImage = v }
			case .barStyle(let x): return x.apply(instance, storage) { i, s, v in i.barStyle = v }
			case .barTintColor(let x): return x.apply(instance, storage) { i, s, v in i.barTintColor = v }
			case .shadowImage(let x): return x.apply(instance, storage) { i, s, v in i.shadowImage = v }
			case .tintColor(let x): return x.apply(instance, storage) { i, s, v in i.tintColor = v }
			case .isTranslucent(let x): return x.apply(instance, storage) { i, s, v in i.isTranslucent = v }
			case .titleTextAttributes(let x):
				return x.apply(instance, storage) { i, s, v in
					i.titleTextAttributes = v
				}
			case .didPush: return nil
			case .didPop: return nil
			case .shouldPush: return nil
			case .shouldPop: return nil
			case .position: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}

	open class Storage: View.Storage, UINavigationBarDelegate {}

	open class Delegate: DynamicDelegate, UINavigationBarDelegate {
		public required override init() {
			super.init()
		}
		
		open var shouldPop: ((_ navigationBar: UINavigationBar, _ item: UINavigationItem) -> Bool)?
		open func navigationBar(_ navigationBar: UINavigationBar, shouldPop item: UINavigationItem) -> Bool {
			return shouldPop!(navigationBar, item)
		}
		
		open var shouldPush: ((_ navigationBar: UINavigationBar, _ item: UINavigationItem) -> Bool)?
		open func navigationBar(_ navigationBar: UINavigationBar, shouldPush item: UINavigationItem) -> Bool {
			return shouldPush!(navigationBar, item)
		}
		
		open var didPop: SignalInput<UINavigationItem>?
		open func navigationBar(_ navigationBar: UINavigationBar, didPop item: UINavigationItem) {
			didPop!.send(value: item)
		}
		
		open var didPush: SignalInput<UINavigationItem>?
		open func navigationBar(_ navigationBar: UINavigationBar, didPush item: UINavigationItem) {
			didPush!.send(value: item)
		}
		
		open var position: ((UIBarPositioning) -> UIBarPosition)?
		open func position(for bar: UIBarPositioning) -> UIBarPosition {
			return position!(bar)
		}
	}
}

extension BindingName where Binding: NavigationBarBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.$1(v)) }) }
	public static var items: BindingName<Dynamic<SetOrAnimate<[NavigationItemConvertible]>>, Binding> { return BindingName<Dynamic<SetOrAnimate<[NavigationItemConvertible]>>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.items(v)) }) }
	public static var backIndicatorImage: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.backIndicatorImage(v)) }) }
	public static var backIndicatorTransitionMaskImage: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.backIndicatorTransitionMaskImage(v)) }) }
	public static var barStyle: BindingName<Dynamic<UIBarStyle>, Binding> { return BindingName<Dynamic<UIBarStyle>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.barStyle(v)) }) }
	public static var barTintColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.barTintColor(v)) }) }
	public static var shadowImage: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.shadowImage(v)) }) }
	public static var tintColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.tintColor(v)) }) }
	public static var isTranslucent: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.isTranslucent(v)) }) }
	public static var titleTextAttributes: BindingName<Dynamic<[NSAttributedString.Key: Any]>, Binding> { return BindingName<Dynamic<[NSAttributedString.Key: Any]>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.titleTextAttributes(v)) }) }
	public static var titleVerticalPositionAdjustment: BindingName<Dynamic<ScopedValues<UIBarMetrics, CGFloat>>, Binding> { return BindingName<Dynamic<ScopedValues<UIBarMetrics, CGFloat>>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.titleVerticalPositionAdjustment(v)) }) }
	public static var backgroundImage: BindingName<Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.backgroundImage(v)) }) }
	public static var didPush: BindingName<SignalInput<UINavigationItem>, Binding> { return BindingName<SignalInput<UINavigationItem>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.didPush(v)) }) }
	public static var didPop: BindingName<SignalInput<UINavigationItem>, Binding> { return BindingName<SignalInput<UINavigationItem>, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.didPop(v)) }) }
	public static var shouldPush: BindingName<(UINavigationBar, UINavigationItem) -> Bool, Binding> { return BindingName<(UINavigationBar, UINavigationItem) -> Bool, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.shouldPush(v)) }) }
	public static var shouldPop: BindingName<(UINavigationBar, UINavigationItem) -> Bool, Binding> { return BindingName<(UINavigationBar, UINavigationItem) -> Bool, Binding>({ v in .navigationBarBinding(NavigationBar.Binding.shouldPop(v)) }) }
}

public protocol NavigationBarConvertible: ViewConvertible {
	func uiNavigationBar() -> NavigationBar.Instance
}
extension NavigationBarConvertible {
	public func uiView() -> View.Instance { return uiNavigationBar() }
}
extension NavigationBar.Instance: NavigationBarConvertible {
	public func uiNavigationBar() -> NavigationBar.Instance { return self }
}

public protocol NavigationBarBinding: ViewBinding {
	static func navigationBarBinding(_ binding: NavigationBar.Binding) -> Self
}
extension NavigationBarBinding {
	public static func viewBinding(_ binding: View.Binding) -> Self {
		return navigationBarBinding(.inheritedBinding(binding))
	}
}

public struct PositionAndMetrics {
	public let barPosition: UIBarPosition
	public let barMetrics: UIBarMetrics
	public init(position: UIBarPosition = .any, metrics: UIBarMetrics = .default) {
		self.barPosition = position
		self.barMetrics = metrics
	}
}

extension ScopedValues where Scope == PositionAndMetrics {
	public static func any(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: PositionAndMetrics(position: .any, metrics: metrics))
	}
	public static func bottom(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: PositionAndMetrics(position: .bottom, metrics: metrics))
	}
	public static func top(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: PositionAndMetrics(position: .top, metrics: metrics))
	}
	public static func topAttached(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: PositionAndMetrics(position: .topAttached, metrics: metrics))
	}
}

public class LongPressGestureRecognizer: ConstructingBinder, LongPressGestureRecognizerConvertible {
	public typealias Instance = UILongPressGestureRecognizer
	public typealias Inherited = GestureRecognizer
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiLongPressGestureRecognizer() -> Instance { return instance() }
	
	public enum Binding: LongPressGestureRecognizerBinding {
		public typealias EnclosingBinder = LongPressGestureRecognizer
		public static func longPressGestureRecognizerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case minimumPressDuration(Dynamic<CFTimeInterval>)
		case numberOfTouchesRequired(Dynamic<Int>)
		case numberOfTapsRequired(Dynamic<Int>)
		case allowableMovement(Dynamic<CGFloat>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = LongPressGestureRecognizer
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		public init() {}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .minimumPressDuration(let x): return x.apply(instance, storage) { i, s, v in i.minimumPressDuration = v }
			case .numberOfTouchesRequired(let x): return x.apply(instance, storage) { i, s, v in i.numberOfTouchesRequired = v }
			case .numberOfTapsRequired(let x): return x.apply(instance, storage) { i, s, v in i.numberOfTapsRequired = v }
			case .allowableMovement(let x): return x.apply(instance, storage) { i, s, v in i.allowableMovement = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	public typealias Storage = GestureRecognizer.Storage
}

extension BindingName where Binding: LongPressGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .longPressGestureRecognizerBinding(LongPressGestureRecognizer.Binding.$1(v)) }) }
	public static var minimumPressDuration: BindingName<Dynamic<CFTimeInterval>, Binding> { return BindingName<Dynamic<CFTimeInterval>, Binding>({ v in .longPressGestureRecognizerBinding(LongPressGestureRecognizer.Binding.minimumPressDuration(v)) }) }
	public static var numberOfTouchesRequired: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .longPressGestureRecognizerBinding(LongPressGestureRecognizer.Binding.numberOfTouchesRequired(v)) }) }
	public static var numberOfTapsRequired: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .longPressGestureRecognizerBinding(LongPressGestureRecognizer.Binding.numberOfTapsRequired(v)) }) }
	public static var allowableMovement: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .longPressGestureRecognizerBinding(LongPressGestureRecognizer.Binding.allowableMovement(v)) }) }
}

public protocol LongPressGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiLongPressGestureRecognizer() -> LongPressGestureRecognizer.Instance
}
extension LongPressGestureRecognizerConvertible {
	public func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiLongPressGestureRecognizer() }
}
extension LongPressGestureRecognizer.Instance: LongPressGestureRecognizerConvertible {
	public func uiLongPressGestureRecognizer() -> LongPressGestureRecognizer.Instance { return self }
}

public protocol LongPressGestureRecognizerBinding: GestureRecognizerBinding {
	static func longPressGestureRecognizerBinding(_ binding: LongPressGestureRecognizer.Binding) -> Self
}

extension LongPressGestureRecognizerBinding {
	public static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return longPressGestureRecognizerBinding(.inheritedBinding(binding))
	}
}

public class AlertAction: ConstructingBinder, AlertActionConvertible {
	public typealias Instance = UIAlertAction
	public typealias Inherited = BaseBinder
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiAlertAction() -> Instance { return instance() }
	
	public enum Binding: AlertActionBinding {
		public typealias EnclosingBinder = AlertAction
		public static func alertActionBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case title(Constant<String>)
		case style(Constant<UIAlertAction.Style>)

		//	1. Value bindings may be applied at construction and may subsequently change.
		case isEnabled(Dynamic<Bool>)

		//	2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.
		case handler(SignalInput<Void>)

		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}

	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = AlertAction
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance {
			return subclass.init(title: title, style: style, handler: handler.map { h in
				{ _ in h.send(value: ()) }
			})
		}
		
		public var title: String? = nil
		public var style: UIAlertAction.Style = .default
		public var handler: SignalInput<Void>? = nil

		public init() {}
		
		public mutating func prepareBinding(_ binding: AlertAction.Binding) {
			switch binding {
			case .title(let x): title = x.value
			case .style(let x): style = x.value
			case .handler(let x): handler = x
			case .inheritedBinding(let s): return linkedPreparer.prepareBinding(s)
			default: break
			}
		}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .title: return nil
			case .style: return nil
			case .handler: return nil
			case .isEnabled(let x): return x.apply(instance, storage) { i, s, v in i.isEnabled = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: (), storage: ())
			}
		}
		
		public mutating func finalizeInstance(_ instance: Instance, storage: Storage) -> Lifetime? {
			let linkedLifetime = linkedPreparer.finalizeInstance(instance, storage: storage)
			return AggregateLifetime(lifetimes: [linkedLifetime, handler as Optional<Lifetime>].compactMap { $0 })
		}
	}

	public typealias Storage = ObjectBinderStorage
}

extension BindingName where Binding: AlertActionBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .alertActionBinding(AlertAction.Binding.$1(v)) }) }
	public static var title: BindingName<Constant<String>, Binding> { return BindingName<Constant<String>, Binding>({ v in .alertActionBinding(AlertAction.Binding.title(v)) }) }
	public static var style: BindingName<Constant<UIAlertAction.Style>, Binding> { return BindingName<Constant<UIAlertAction.Style>, Binding>({ v in .alertActionBinding(AlertAction.Binding.style(v)) }) }
	public static var handler: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .alertActionBinding(AlertAction.Binding.handler(v)) }) }
	public static var isEnabled: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .alertActionBinding(AlertAction.Binding.isEnabled(v)) }) }
}

public protocol AlertActionConvertible {
	func uiAlertAction() -> AlertAction.Instance
}
extension AlertAction.Instance: AlertActionConvertible {
	public func uiAlertAction() -> AlertAction.Instance { return self }
}

public protocol AlertActionBinding: BaseBinding {
	static func alertActionBinding(_ binding: AlertAction.Binding) -> Self
}
extension AlertActionBinding {
	public static func baseBinding(_ binding: BaseBinder.Binding) -> Self {
		return alertActionBinding(.inheritedBinding(binding))
	}
}

public class Slider: ConstructingBinder, SliderConvertible {
	public typealias Instance = UISlider
	public typealias Inherited = Control
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiSlider() -> Instance { return instance() }
	
	public enum Binding: SliderBinding {
		public typealias EnclosingBinder = Slider
		public static func sliderBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case value(Dynamic<SetOrAnimate<Float>>)
		case maximumValue(Dynamic<Float>)
		case minimumValue(Dynamic<Float>)
		case isContinuous(Dynamic<Bool>)
		case minimumValueImage(Dynamic<UIImage?>)
		case maximumValueImage(Dynamic<UIImage?>)
		case minimumTrackTintColor(Dynamic<UIColor?>)
		case maximumTrackTintColor(Dynamic<UIColor?>)
		case thumbTintColor(Dynamic<UIColor?>)
		case thumbImage(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		case minimumTrackImage(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		case maximumTrackImage(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = Slider
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		public init() {}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .thumbImage(let x):
				var previous: ScopedValues<UIControl.State, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setThumbImage(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setThumbImage(c.1, for: c.0)
					}
				}
			case .minimumTrackImage(let x):
				var previous: ScopedValues<UIControl.State, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setMinimumTrackImage(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setMinimumTrackImage(c.1, for: c.0)
					}
				}
			case .maximumTrackImage(let x):
				var previous: ScopedValues<UIControl.State, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setMaximumTrackImage(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setMaximumTrackImage(c.1, for: c.0)
					}
				}
			case .value(let x): return x.apply(instance, storage) { i, s, v in i.setValue(v.value, animated: v.isAnimated) }
			case .maximumValue(let x): return x.apply(instance, storage) { i, s, v in i.maximumValue = v }
			case .minimumValue(let x): return x.apply(instance, storage) { i, s, v in i.minimumValue = v }
			case .isContinuous(let x): return x.apply(instance, storage) { i, s, v in i.isContinuous = v }
			case .minimumValueImage(let x): return x.apply(instance, storage) { i, s, v in i.minimumValueImage = v }
			case .maximumValueImage(let x): return x.apply(instance, storage) { i, s, v in i.maximumValueImage = v }
			case .minimumTrackTintColor(let x): return x.apply(instance, storage) { i, s, v in i.minimumTrackTintColor = v }
			case .maximumTrackTintColor(let x): return x.apply(instance, storage) { i, s, v in i.maximumTrackTintColor = v }
			case .thumbTintColor(let x): return x.apply(instance, storage) { i, s, v in i.thumbTintColor = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	public typealias Storage = Control.Storage
}

extension BindingName where Binding: SliderBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .sliderBinding(Slider.Binding.$1(v)) }) }
	public static var value: BindingName<Dynamic<SetOrAnimate<Float>>, Binding> { return BindingName<Dynamic<SetOrAnimate<Float>>, Binding>({ v in .sliderBinding(Slider.Binding.value(v)) }) }
	public static var maximumValue: BindingName<Dynamic<Float>, Binding> { return BindingName<Dynamic<Float>, Binding>({ v in .sliderBinding(Slider.Binding.maximumValue(v)) }) }
	public static var minimumValue: BindingName<Dynamic<Float>, Binding> { return BindingName<Dynamic<Float>, Binding>({ v in .sliderBinding(Slider.Binding.minimumValue(v)) }) }
	public static var isContinuous: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .sliderBinding(Slider.Binding.isContinuous(v)) }) }
	public static var minimumValueImage: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .sliderBinding(Slider.Binding.minimumValueImage(v)) }) }
	public static var maximumValueImage: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .sliderBinding(Slider.Binding.maximumValueImage(v)) }) }
	public static var minimumTrackTintColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .sliderBinding(Slider.Binding.minimumTrackTintColor(v)) }) }
	public static var maximumTrackTintColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .sliderBinding(Slider.Binding.maximumTrackTintColor(v)) }) }
	public static var thumbTintColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .sliderBinding(Slider.Binding.thumbTintColor(v)) }) }
	public static var thumbImage: BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding>({ v in .sliderBinding(Slider.Binding.thumbImage(v)) }) }
	public static var minimumTrackImage: BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding>({ v in .sliderBinding(Slider.Binding.minimumTrackImage(v)) }) }
	public static var maximumTrackImage: BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding>({ v in .sliderBinding(Slider.Binding.maximumTrackImage(v)) }) }
}

public protocol SliderConvertible: ControlConvertible {
	func uiSlider() -> Slider.Instance
}
extension SliderConvertible {
	public func uiControl() -> Control.Instance { return uiSlider() }
}
extension Slider.Instance: SliderConvertible {
	public func uiSlider() -> Slider.Instance { return self }
}

public protocol SliderBinding: ControlBinding {
	static func sliderBinding(_ binding: Slider.Binding) -> Self
}
extension SliderBinding {
	public static func controlBinding(_ binding: Control.Binding) -> Self {
		return sliderBinding(.inheritedBinding(binding))
	}
}

public class Window: ConstructingBinder, WindowConvertible {
	public typealias Instance = UIWindow
	public typealias Inherited = View
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiWindow() -> Instance { return instance() }
	
	public enum Binding: WindowBinding {
		public typealias EnclosingBinder = Window
		public static func windowBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case rootViewController(Dynamic<ViewControllerConvertible>)
		case windowLevel(Dynamic<UIWindow.Level>)
		case screen(Dynamic<UIScreen>)
		case frame(Dynamic<CGRect>)
		
		// 2. Signal bindings are performed on the object after construction.
		case makeKey(Signal<Void>)
		
		// 3. Action bindings are triggered by the object after construction.
		case didBecomeVisible(SignalInput<Void>)
		case didBecomeHidden(SignalInput<Void>)
		case didBecomeKey(SignalInput<Void>)
		case didResignKey(SignalInput<Void>)
		case keyboardWillShow(SignalInput<[AnyHashable: Any]?>)
		case keyboardDidShow(SignalInput<[AnyHashable: Any]?>)
		case keyboardWillHide(SignalInput<[AnyHashable: Any]?>)
		case keyboardDidHide(SignalInput<[AnyHashable: Any]?>)
		case keyboardWillChangeFrame(SignalInput<[AnyHashable: Any]?>)
		case keyboardDidChangeFrame(SignalInput<[AnyHashable: Any]?>)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = Window
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		public init() {}

		public var isHidden: InitialSubsequent<Bool>? = nil
		
		public mutating func prepareBinding(_ binding: Window.Binding) {
			switch binding {
			case .inheritedBinding(.isHidden(let x)): isHidden = x.initialSubsequent()
			case .inheritedBinding(let s): linkedPreparer.prepareBinding(s)
			default: break
			}
		}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .frame(let x): return x.apply(instance, storage) { i, s, v in i.frame = v }
			case .rootViewController(let x):
				return x.apply(instance, storage) { i, s, v in
					let rootViewController = v.uiViewController()
					i.rootViewController = rootViewController
					if rootViewController.restorationIdentifier == nil {
						rootViewController.restorationIdentifier = "cwlviews.root"
					}
				}
			case .windowLevel(let x): return x.apply(instance, storage) { i, s, v in i.windowLevel = v }
			case .screen(let x): return x.apply(instance, storage) { i, s, v in i.screen = v }
			case .makeKey(let x): return x.apply(instance, storage) { i, s, v in i.makeKey() }
			case .didBecomeVisible(let x): return Signal.notifications(name: UIWindow.didBecomeVisibleNotification, object: instance).map { notification -> Void in }.cancellableBind(to: x)
			case .didBecomeHidden(let x): return Signal.notifications(name: UIWindow.didBecomeHiddenNotification, object: instance).map { notification -> Void in }.cancellableBind(to: x)
			case .didBecomeKey(let x): return Signal.notifications(name: UIWindow.didBecomeKeyNotification, object: instance).map { notification -> Void in }.cancellableBind(to: x)
			case .didResignKey(let x): return Signal.notifications(name: UIWindow.didResignKeyNotification, object: instance).map { notification -> Void in }.cancellableBind(to: x)
			case .keyboardWillShow(let x): return Signal.notifications(name: UIResponder.keyboardWillShowNotification, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
			case .keyboardDidShow(let x): return Signal.notifications(name: UIResponder.keyboardDidShowNotification, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
			case .keyboardWillHide(let x): return Signal.notifications(name: UIResponder.keyboardWillHideNotification, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
			case .keyboardDidHide(let x): return Signal.notifications(name: UIResponder.keyboardDidHideNotification, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
			case .keyboardWillChangeFrame(let x): return Signal.notifications(name: UIResponder.keyboardWillChangeFrameNotification, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
			case .keyboardDidChangeFrame(let x): return Signal.notifications(name: UIResponder.keyboardDidChangeFrameNotification, object: instance).map { notification -> [AnyHashable: Any]? in notification.userInfo }.cancellableBind(to: x)
			case .inheritedBinding(.isHidden): return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
		
		public mutating func finalizeInstance(_ instance: Instance, storage: View.Storage) -> Lifetime? {
			let lifetime = linkedPreparer.finalizeInstance(instance, storage: storage)
			if let h = isHidden?.resume() {
				if let c2 = linkedPreparer.applyBinding(.isHidden(.dynamic(h)), instance: instance, storage: storage) {
					return lifetime.map { c1 in AggregateLifetime(lifetimes: [c2, c1]) } ?? c2
				}
			}
			return lifetime
		}
	}
	
	public typealias Storage = View.Storage
}

extension BindingName where Binding: WindowBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .windowBinding(Window.Binding.$1(v)) }) }
	public static var frame: BindingName<Dynamic<CGRect>, Binding> { return BindingName<Dynamic<CGRect>, Binding>({ v in .windowBinding(Window.Binding.frame(v)) }) }
	public static var rootViewController: BindingName<Dynamic<ViewControllerConvertible>, Binding> { return BindingName<Dynamic<ViewControllerConvertible>, Binding>({ v in .windowBinding(Window.Binding.rootViewController(v)) }) }
	public static var windowLevel: BindingName<Dynamic<UIWindow.Level>, Binding> { return BindingName<Dynamic<UIWindow.Level>, Binding>({ v in .windowBinding(Window.Binding.windowLevel(v)) }) }
	public static var screen: BindingName<Dynamic<UIScreen>, Binding> { return BindingName<Dynamic<UIScreen>, Binding>({ v in .windowBinding(Window.Binding.screen(v)) }) }
	public static var makeKey: BindingName<Signal<Void>, Binding> { return BindingName<Signal<Void>, Binding>({ v in .windowBinding(Window.Binding.makeKey(v)) }) }
	public static var didBecomeVisible: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .windowBinding(Window.Binding.didBecomeVisible(v)) }) }
	public static var didBecomeHidden: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .windowBinding(Window.Binding.didBecomeHidden(v)) }) }
	public static var didBecomeKey: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .windowBinding(Window.Binding.didBecomeKey(v)) }) }
	public static var didResignKey: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .windowBinding(Window.Binding.didResignKey(v)) }) }
	public static var keyboardWillShow: BindingName<SignalInput<[AnyHashable: Any]?>, Binding> { return BindingName<SignalInput<[AnyHashable: Any]?>, Binding>({ v in .windowBinding(Window.Binding.keyboardWillShow(v)) }) }
	public static var keyboardDidShow: BindingName<SignalInput<[AnyHashable: Any]?>, Binding> { return BindingName<SignalInput<[AnyHashable: Any]?>, Binding>({ v in .windowBinding(Window.Binding.keyboardDidShow(v)) }) }
	public static var keyboardWillHide: BindingName<SignalInput<[AnyHashable: Any]?>, Binding> { return BindingName<SignalInput<[AnyHashable: Any]?>, Binding>({ v in .windowBinding(Window.Binding.keyboardWillHide(v)) }) }
	public static var keyboardDidHide: BindingName<SignalInput<[AnyHashable: Any]?>, Binding> { return BindingName<SignalInput<[AnyHashable: Any]?>, Binding>({ v in .windowBinding(Window.Binding.keyboardDidHide(v)) }) }
	public static var keyboardWillChangeFrame: BindingName<SignalInput<[AnyHashable: Any]?>, Binding> { return BindingName<SignalInput<[AnyHashable: Any]?>, Binding>({ v in .windowBinding(Window.Binding.keyboardWillChangeFrame(v)) }) }
	public static var keyboardDidChangeFrame: BindingName<SignalInput<[AnyHashable: Any]?>, Binding> { return BindingName<SignalInput<[AnyHashable: Any]?>, Binding>({ v in .windowBinding(Window.Binding.keyboardDidChangeFrame(v)) }) }
}

public protocol WindowConvertible: ViewConvertible {
	func uiWindow() -> Window.Instance
}
extension WindowConvertible {
	public func uiView() -> View.Instance { return uiWindow() }
}
extension Window.Instance: WindowConvertible {
	public func uiWindow() -> Window.Instance { return self }
}

public protocol WindowBinding: ViewBinding {
	static func windowBinding(_ binding: Window.Binding) -> Self
}
extension WindowBinding {
	public static func viewBinding(_ binding: View.Binding) -> Self {
		return windowBinding(.inheritedBinding(binding))
	}
}

public class Switch: ConstructingBinder, SwitchConvertible {
	public typealias Instance = UISwitch
	public typealias Inherited = Control
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiSwitch() -> Instance { return instance() }
	
	public enum Binding: SwitchBinding {
		public typealias EnclosingBinder = Switch
		public static func switchBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case isOn(Dynamic<SetOrAnimate<Bool>>)
		case onTintColor(Dynamic<UIColor>)
		case tintColor(Dynamic<UIColor>)
		case thumbTintColor(Dynamic<UIColor>)
		case onImage(Dynamic<UIImage?>)
		case offImage(Dynamic<UIImage?>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = Switch
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		public init() {}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .isOn(let x): return x.apply(instance, storage) { i, s, v in i.setOn(v.value, animated: v.isAnimated) }
			case .onTintColor(let x): return x.apply(instance, storage) { i, s, v in i.onTintColor = v }
			case .tintColor(let x): return x.apply(instance, storage) { i, s, v in i.tintColor = v }
			case .thumbTintColor(let x): return x.apply(instance, storage) { i, s, v in i.thumbTintColor = v }
			case .onImage(let x): return x.apply(instance, storage) { i, s, v in i.onImage = v }
			case .offImage(let x): return x.apply(instance, storage) { i, s, v in i.offImage = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	public typealias Storage = Control.Storage
}

extension BindingName where Binding: SwitchBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .switchBinding(Switch.Binding.$1(v)) }) }
	public static var isOn: BindingName<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingName<Dynamic<SetOrAnimate<Bool>>, Binding>({ v in .switchBinding(Switch.Binding.isOn(v)) }) }
	public static var onTintColor: BindingName<Dynamic<UIColor>, Binding> { return BindingName<Dynamic<UIColor>, Binding>({ v in .switchBinding(Switch.Binding.onTintColor(v)) }) }
	public static var tintColor: BindingName<Dynamic<UIColor>, Binding> { return BindingName<Dynamic<UIColor>, Binding>({ v in .switchBinding(Switch.Binding.tintColor(v)) }) }
	public static var thumbTintColor: BindingName<Dynamic<UIColor>, Binding> { return BindingName<Dynamic<UIColor>, Binding>({ v in .switchBinding(Switch.Binding.thumbTintColor(v)) }) }
	public static var onImage: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .switchBinding(Switch.Binding.onImage(v)) }) }
	public static var offImage: BindingName<Dynamic<UIImage?>, Binding> { return BindingName<Dynamic<UIImage?>, Binding>({ v in .switchBinding(Switch.Binding.offImage(v)) }) }
}

public protocol SwitchConvertible: ControlConvertible {
	func uiSwitch() -> Switch.Instance
}
extension SwitchConvertible {
	public func uiControl() -> Control.Instance { return uiSwitch() }
}
extension Switch.Instance: SwitchConvertible {
	public func uiSwitch() -> Switch.Instance { return self }
}

public protocol SwitchBinding: ControlBinding {
	static func switchBinding(_ binding: Switch.Binding) -> Self
}
extension SwitchBinding {
	public static func controlBinding(_ binding: Control.Binding) -> Self {
		return switchBinding(.inheritedBinding(binding))
	}
}


public class PanGestureRecognizer: ConstructingBinder, PanGestureRecognizerConvertible {
	public typealias Instance = UIPanGestureRecognizer
	public typealias Inherited = GestureRecognizer
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiPanGestureRecognizer() -> Instance { return instance() }
	
	public enum Binding: PanGestureRecognizerBinding {
		public typealias EnclosingBinder = PanGestureRecognizer
		public static func panGestureRecognizerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case maximumNumberOfTouches(Dynamic<Int>)
		case minimumNumberOfTouches(Dynamic<Int>)
		case translation(Dynamic<CGPoint>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = PanGestureRecognizer
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		public init() {}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .maximumNumberOfTouches(let x): return x.apply(instance, storage) { i, s, v in i.maximumNumberOfTouches = v }
			case .minimumNumberOfTouches(let x): return x.apply(instance, storage) { i, s, v in i.minimumNumberOfTouches = v }
			case .translation(let x): return x.apply(instance, storage) { i, s, v in i.setTranslation(v, in: nil) }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	public typealias Storage = GestureRecognizer.Storage
}

extension BindingName where Binding: PanGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .panGestureRecognizerBinding(PanGestureRecognizer.Binding.$1(v)) }) }
	public static var maximumNumberOfTouches: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .panGestureRecognizerBinding(PanGestureRecognizer.Binding.maximumNumberOfTouches(v)) }) }
	public static var minimumNumberOfTouches: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .panGestureRecognizerBinding(PanGestureRecognizer.Binding.minimumNumberOfTouches(v)) }) }
	public static var translation: BindingName<Dynamic<CGPoint>, Binding> { return BindingName<Dynamic<CGPoint>, Binding>({ v in .panGestureRecognizerBinding(PanGestureRecognizer.Binding.translation(v)) }) }
}

public protocol PanGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiPanGestureRecognizer() -> PanGestureRecognizer.Instance
}
extension PanGestureRecognizerConvertible {
	public func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiPanGestureRecognizer() }
}
extension PanGestureRecognizer.Instance: PanGestureRecognizerConvertible {
	public func uiPanGestureRecognizer() -> PanGestureRecognizer.Instance { return self }
}

public protocol PanGestureRecognizerBinding: GestureRecognizerBinding {
	static func panGestureRecognizerBinding(_ binding: PanGestureRecognizer.Binding) -> Self
}
extension PanGestureRecognizerBinding {
	public static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return panGestureRecognizerBinding(.inheritedBinding(binding))
	}
}

public class SplitViewController: ConstructingBinder, SplitViewControllerConvertible {
	public typealias Instance = UISplitViewController
	public typealias Inherited = ViewController
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiSplitViewController() -> Instance { return instance() }
	
	public enum Binding: SplitViewControllerBinding {
		public typealias EnclosingBinder = SplitViewController
		public static func splitViewControllerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case primaryViewController(Dynamic<ViewControllerConvertible>)
		case secondaryViewController(Dynamic<ViewControllerConvertible>)
		case presentsWithGesture(Dynamic<Bool>)
		case preferredDisplayMode(Dynamic<UISplitViewController.DisplayMode>)
		case preferredPrimaryColumnWidthFraction(Dynamic<CGFloat>)
		case minimumPrimaryColumnWidth(Dynamic<CGFloat>)
		case maximumPrimaryColumnWidth(Dynamic<CGFloat>)
		case shouldShowSecondary(Dynamic<Bool>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.
		case displayModeButton(SignalInput<BarButtonItemConvertible?>)
		case willChangeDisplayMode(SignalInput<UISplitViewController.DisplayMode>)
		case dismissedSecondary(SignalInput<Void>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case targetDisplayModeForAction((UISplitViewController) -> UISplitViewController.DisplayMode)
		case preferredInterfaceOrientation((UISplitViewController) -> UIInterfaceOrientation)
		case supportedInterfaceOrientations((UISplitViewController) -> UIInterfaceOrientationMask)
		case primaryViewControllerForCollapsing((UISplitViewController) -> UIViewController?)
		case collapseSecondary((UISplitViewController, _ secondaryViewController: UIViewController, _ ontoPrimaryViewController: UIViewController) -> Bool)
		case primaryViewControllerForExpanding((UISplitViewController) -> UIViewController?)
		case separateSecondary((UISplitViewController, _ fromPrimaryViewController: UIViewController) -> UIViewController?)
		case showPrimaryViewController((UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool)
		case showSecondaryViewController((UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool)
	}

	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = SplitViewController
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init(nibName: nil, bundle: nil) }

		public init() {
			self.init(delegateClass: Delegate.self)
		}
		public init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		public let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}

		public var primary = InitialSubsequent<ViewControllerConvertible>()
		public var secondary = InitialSubsequent<ViewControllerConvertible>()

		public mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .primaryViewController(let x): primary = x.initialSubsequent()
			case .secondaryViewController(let x): secondary = x.initialSubsequent()
			case .willChangeDisplayMode(let x):
				let s = #selector(UISplitViewControllerDelegate.splitViewController(_:willChangeTo:))
				delegate().addSelector(s).willChangeDisplayMode = x
			case .targetDisplayModeForAction(let x):
				let s = #selector(UISplitViewControllerDelegate.targetDisplayModeForAction(in:))
				delegate().addSelector(s).targetDisplayMode = x
			case .preferredInterfaceOrientation(let x):
				let s = #selector(UISplitViewControllerDelegate.splitViewControllerPreferredInterfaceOrientationForPresentation(_:))
				delegate().addSelector(s).preferredInterfaceOrientation = x
			case .supportedInterfaceOrientations(let x):
				let s = #selector(UISplitViewControllerDelegate.splitViewControllerSupportedInterfaceOrientations(_:))
				delegate().addSelector(s).supportedInterfaceOrientations = x
			case .primaryViewControllerForCollapsing(let x):
				let s = #selector(UISplitViewControllerDelegate.primaryViewController(forCollapsing:))
				delegate().addSelector(s).primaryViewControllerForCollapsing = x
			case .primaryViewControllerForExpanding(let x):
				let s = #selector(UISplitViewControllerDelegate.primaryViewController(forExpanding:))
				delegate().addSelector(s).primaryViewControllerForExpanding = x
			case .showPrimaryViewController(let x):
				let s = #selector(UISplitViewControllerDelegate.splitViewController(_:show:sender:))
				delegate().addSelector(s).showPrimaryViewController = x
			case .showSecondaryViewController(let x):
				let s = #selector(UISplitViewControllerDelegate.splitViewController(_:showDetail:sender:))
				delegate().addSelector(s).showSecondaryViewController = x
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		public mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
			storage.dynamicDelegate = possibleDelegate
			if storage.inUse {
				instance.delegate = storage
			}

			storage.secondaryViewController = secondary.initial()?.uiViewController()
			instance.viewControllers = [primary.initial()?.uiViewController() ?? UIViewController()]
			
			linkedPreparer.prepareInstance(instance, storage: storage)
		}

		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .primaryViewController: return primary.resume()?.apply(instance, storage) { i, s, v in i.show(v.uiViewController(), sender: nil) }
			case .secondaryViewController:
				return secondary.resume()?.apply(instance, storage) { i, s, v in
					let vc = v.uiViewController()
					s.secondaryViewController = vc
					i.showDetailViewController(vc, sender: nil)
				}
			case .presentsWithGesture(let x): return x.apply(instance, storage) { i, s, v in i.presentsWithGesture = v }
			case .preferredDisplayMode(let x): return x.apply(instance, storage) { i, s, v in i.preferredDisplayMode = v }
			case .preferredPrimaryColumnWidthFraction(let x): return x.apply(instance, storage) { i, s, v in i.preferredPrimaryColumnWidthFraction = v }
			case .minimumPrimaryColumnWidth(let x): return x.apply(instance, storage) { i, s, v in i.minimumPrimaryColumnWidth = v }
			case .maximumPrimaryColumnWidth(let x): return x.apply(instance, storage) { i, s, v in i.maximumPrimaryColumnWidth = v }
			case .displayModeButton(let x):
				storage.displayModeButton = x
				return nil
			case .dismissedSecondary(let x):
				storage.dismissedSecondary = x
				return nil
			case .shouldShowSecondary(let x):
				return x.apply(instance, storage) { i, s, v in
					if v == true && s.shouldShowSecondary == false, let svc = s.secondaryViewController {
						i.showDetailViewController(svc, sender: nil)
					}
					s.shouldShowSecondary = v
				}
			case .willChangeDisplayMode: return nil
			case .targetDisplayModeForAction: return nil
			case .preferredInterfaceOrientation: return nil
			case .supportedInterfaceOrientations: return nil
			case .primaryViewControllerForCollapsing: return nil
			case .collapseSecondary(let x):
				storage.collapseSecondary = x
				return nil
			case .primaryViewControllerForExpanding: return nil
			case .separateSecondary(let x):
				storage.separateSecondary = x
				return nil
			case .showPrimaryViewController: return nil
			case .showSecondaryViewController: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}

		public mutating func finalizeInstance(_ instance: Instance, storage: Storage) -> Lifetime? {
			let lifetime = linkedPreparer.finalizeInstance(instance, storage: storage)
			if !instance.isCollapsed {
				storage.displayModeButton?.send(value: instance.displayModeButtonItem)
			}
			return lifetime
		}
	}

	open class Storage: ViewController.Storage, UISplitViewControllerDelegate {
		open var secondaryViewController: UIViewController? = nil
		open var shouldShowSecondary: Bool = true
		open var displayModeButton: SignalInput<BarButtonItemConvertible?>?
		open var dismissedSecondary: SignalInput<Void>?
		
		open override var inUse: Bool {
			return true
		}
		
		open func collapsedController(_ controller: UINavigationController) {
			if let svc = secondaryViewController, svc === controller {
				dismissedSecondary?.send(value: ())
			}
		}

		open override func viewWillAppear(controller: UIViewController, animated: Bool) {
			if let secondary = secondaryViewController, let splitViewController = controller as? UISplitViewController {
				splitViewController.viewControllers.append(secondary)
			}
			super.viewWillAppear(controller: controller, animated: animated)
		}
		
		open var collapseSecondary: ((UISplitViewController, _ secondaryViewController: UIViewController, _ ontoPrimaryViewController: UIViewController) -> Bool)?
		open func splitViewController(_ splitViewController: UISplitViewController, collapseSecondary secondaryViewController: UIViewController, onto primaryViewController: UIViewController) -> Bool {
			displayModeButton?.send(value: nil)
			return (collapseSecondary?(splitViewController, secondaryViewController, primaryViewController) ?? false) || !shouldShowSecondary
		}
		
		open var separateSecondary: ((UISplitViewController, _ fromPrimaryViewController: UIViewController) -> UIViewController?)?
		open func splitViewController(_ splitViewController: UISplitViewController, separateSecondaryFrom primaryViewController: UIViewController) -> UIViewController? {
			displayModeButton?.send(value: splitViewController.displayModeButtonItem)
			return separateSecondary?(splitViewController, primaryViewController)
		}
	}

	open class Delegate: DynamicDelegate, UISplitViewControllerDelegate {
		public required override init() {
			super.init()
		}
		
		open var willChangeDisplayMode: SignalInput<UISplitViewController.DisplayMode>?
		open func splitViewController(_ svc: UISplitViewController, willChangeTo displayMode: UISplitViewController.DisplayMode) {
			willChangeDisplayMode!.send(value: displayMode)
		}
		
		open var targetDisplayMode: ((UISplitViewController) -> UISplitViewController.DisplayMode)?
		open func targetDisplayModeForAction(in svc: UISplitViewController) -> UISplitViewController.DisplayMode {
			return targetDisplayMode!(svc)
		}
		
		open var preferredInterfaceOrientation: ((UISplitViewController) -> UIInterfaceOrientation)?
		open func splitViewControllerPreferredInterfaceOrientationForPresentation(_ splitViewController: UISplitViewController) -> UIInterfaceOrientation {
			return preferredInterfaceOrientation!(splitViewController)
		}
		
		open var supportedInterfaceOrientations: ((UISplitViewController) -> UIInterfaceOrientationMask)?
		open func splitViewControllerSupportedInterfaceOrientations(_ splitViewController: UISplitViewController) -> UIInterfaceOrientationMask {
			return supportedInterfaceOrientations!(splitViewController)
		}
		
		open var primaryViewControllerForCollapsing: ((UISplitViewController) -> UIViewController?)?
		open func primaryViewController(forCollapsing splitViewController: UISplitViewController) -> UIViewController? {
			return primaryViewControllerForCollapsing!(splitViewController)
		}
		
		open var primaryViewControllerForExpanding: ((UISplitViewController) -> UIViewController?)?
		open func primaryViewController(forExpanding splitViewController: UISplitViewController) -> UIViewController? {
			return primaryViewControllerForExpanding!(splitViewController)
		}
		
		open var showPrimaryViewController: ((UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool)?
		open func splitViewController(_ splitViewController: UISplitViewController, show vc: UIViewController, sender: Any?) -> Bool {
			return showPrimaryViewController!(splitViewController, vc, sender)
		}
		
		open var showSecondaryViewController: ((UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool)?
		open func splitViewController(_ splitViewController: UISplitViewController, showDetail vc: UIViewController, sender: Any?) -> Bool {
			return showSecondaryViewController!(splitViewController, vc, sender)
		}
	}
}

extension BindingName where Binding: SplitViewControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.$1(v)) }) }
	public static var primaryViewController: BindingName<Dynamic<ViewControllerConvertible>, Binding> { return BindingName<Dynamic<ViewControllerConvertible>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.primaryViewController(v)) }) }
	public static var secondaryViewController: BindingName<Dynamic<ViewControllerConvertible>, Binding> { return BindingName<Dynamic<ViewControllerConvertible>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.secondaryViewController(v)) }) }
	public static var presentsWithGesture: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.presentsWithGesture(v)) }) }
	public static var preferredDisplayMode: BindingName<Dynamic<UISplitViewController.DisplayMode>, Binding> { return BindingName<Dynamic<UISplitViewController.DisplayMode>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.preferredDisplayMode(v)) }) }
	public static var preferredPrimaryColumnWidthFraction: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.preferredPrimaryColumnWidthFraction(v)) }) }
	public static var minimumPrimaryColumnWidth: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.minimumPrimaryColumnWidth(v)) }) }
	public static var maximumPrimaryColumnWidth: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.maximumPrimaryColumnWidth(v)) }) }
	public static var shouldShowSecondary: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.shouldShowSecondary(v)) }) }
	public static var displayModeButton: BindingName<SignalInput<BarButtonItemConvertible?>, Binding> { return BindingName<SignalInput<BarButtonItemConvertible?>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.displayModeButton(v)) }) }
	public static var willChangeDisplayMode: BindingName<SignalInput<UISplitViewController.DisplayMode>, Binding> { return BindingName<SignalInput<UISplitViewController.DisplayMode>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.willChangeDisplayMode(v)) }) }
	public static var dismissedSecondary: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.dismissedSecondary(v)) }) }
	public static var targetDisplayModeForAction: BindingName<(UISplitViewController) -> UISplitViewController.DisplayMode, Binding> { return BindingName<(UISplitViewController) -> UISplitViewController.DisplayMode, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.targetDisplayModeForAction(v)) }) }
	public static var preferredInterfaceOrientation: BindingName<(UISplitViewController) -> UIInterfaceOrientation, Binding> { return BindingName<(UISplitViewController) -> UIInterfaceOrientation, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.preferredInterfaceOrientation(v)) }) }
	public static var supportedInterfaceOrientations: BindingName<(UISplitViewController) -> UIInterfaceOrientationMask, Binding> { return BindingName<(UISplitViewController) -> UIInterfaceOrientationMask, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.supportedInterfaceOrientations(v)) }) }
	public static var primaryViewControllerForCollapsing: BindingName<(UISplitViewController) -> UIViewController?, Binding> { return BindingName<(UISplitViewController) -> UIViewController?, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.primaryViewControllerForCollapsing(v)) }) }
	public static var collapseSecondary: BindingName<(UISplitViewController, _ secondaryViewController: UIViewController, _ ontoPrimaryViewController: UIViewController) -> Bool, Binding> { return BindingName<(UISplitViewController, _ secondaryViewController: UIViewController, _ ontoPrimaryViewController: UIViewController) -> Bool, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.collapseSecondary(v)) }) }
	public static var primaryViewControllerForExpanding: BindingName<(UISplitViewController) -> UIViewController?, Binding> { return BindingName<(UISplitViewController) -> UIViewController?, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.primaryViewControllerForExpanding(v)) }) }
	public static var separateSecondary: BindingName<(UISplitViewController, _ fromPrimaryViewController: UIViewController) -> UIViewController?, Binding> { return BindingName<(UISplitViewController, _ fromPrimaryViewController: UIViewController) -> UIViewController?, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.separateSecondary(v)) }) }
	public static var showPrimaryViewController: BindingName<(UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool, Binding> { return BindingName<(UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.showPrimaryViewController(v)) }) }
	public static var showSecondaryViewController: BindingName<(UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool, Binding> { return BindingName<(UISplitViewController, _ show: UIViewController, _ sender: Any?) -> Bool, Binding>({ v in .splitViewControllerBinding(SplitViewController.Binding.showSecondaryViewController(v)) }) }
}

public protocol SplitViewControllerConvertible: ViewControllerConvertible {
	func uiSplitViewController() -> SplitViewController.Instance
}
extension SplitViewControllerConvertible {
	public func uiViewController() -> ViewController.Instance { return uiSplitViewController() }
}
extension SplitViewController.Instance: SplitViewControllerConvertible {
	public func uiSplitViewController() -> SplitViewController.Instance { return self }
}

public protocol SplitViewControllerBinding: ViewControllerBinding {
	static func splitViewControllerBinding(_ binding: SplitViewController.Binding) -> Self
}

extension SplitViewControllerBinding {
	public static func viewControllerBinding(_ binding: ViewController.Binding) -> Self {
		return splitViewControllerBinding(.inheritedBinding(binding))
	}
}

public class TextView: ConstructingBinder, TextViewConvertible {
	public typealias Instance = UITextView
	public typealias Inherited = ScrollView
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiTextView() -> Instance { return instance() }
	
	public enum Binding: TextViewBinding {
		public typealias EnclosingBinder = TextView
		public static func textViewBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case textInputTraits(Constant<TextInputTraits>)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case text(Dynamic<String>)
		case attributedText(Dynamic<NSAttributedString>)
		case font(Dynamic<UIFont?>)
		case textColor(Dynamic<UIColor?>)
		case isEditable(Dynamic<Bool>)
		case allowsEditingTextAttributes(Dynamic<Bool>)
		case dataDetectorTypes(Dynamic<UIDataDetectorTypes>)
		case textAlignment(Dynamic<NSTextAlignment>)
		case typingAttributes(Dynamic<[NSAttributedString.Key: Any]>)
		case linkTextAttributes(Dynamic<[NSAttributedString.Key: Any]>)
		case textContainerInset(Dynamic<UIEdgeInsets>)
		case selectedRange(Dynamic<NSRange>)
		case clearsOnInsertion(Dynamic<Bool>)
		case isSelectable(Dynamic<Bool>)
		case inputView(Dynamic<ViewConvertible?>)
		case inputAccessoryView(Dynamic<ViewConvertible?>)
		
		// 2. Signal bindings are performed on the object after construction.
		case scrollRangeToVisible(Signal<NSRange>)
		
		//	3. Action bindings are triggered by the object after construction.
		case didBeginEditing(SignalInput<UITextView>)
		case didEndEditing(SignalInput<UITextView>)
		case didChange(SignalInput<UITextView>)
		case didChangeSelection(SignalInput<UITextView>)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case shouldBeginEditing((UITextView) -> Bool)
		case shouldEndEditing((UITextView) -> Bool)
		case shouldChangeText((UITextView, NSRange, String) -> Bool)
		@available(iOS 10.0, *)
		case shouldInteractWithAttachment((UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -> Bool)
		@available(iOS 10.0, *)
		case shouldInteractWithURL((UITextView, URL, NSRange, UITextItemInteraction) -> Bool)
	}
	
	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = TextView
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		// Actual delegate construction is handled by the scroll view preparer
		public init() {
			self.init(delegateClass: Delegate.self)
		}
		public init(delegateClass: Delegate.Type) {
			linkedPreparer = Inherited.Preparer(delegateClass: delegateClass)
		}
		var possibleDelegate: Delegate? { return linkedPreparer.possibleDelegate as? Delegate }
		mutating func delegate() -> Delegate { return linkedPreparer.delegate() as! Delegate }
		
		public mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .shouldBeginEditing(let x):
				let s = #selector(UITextViewDelegate.textViewShouldBeginEditing(_:))
				delegate().addSelector(s).shouldBeginEditing = x
			case .shouldEndEditing(let x):
				let s = #selector(UITextViewDelegate.textViewShouldEndEditing(_:))
				delegate().addSelector(s).shouldEndEditing = x
			case .didBeginEditing(let x):
				let s = #selector(UITextViewDelegate.textViewDidBeginEditing(_:))
				delegate().addSelector(s).didBeginEditing = x
			case .didEndEditing(let x):
				let s = #selector(UITextViewDelegate.textViewDidEndEditing(_:))
				delegate().addSelector(s).didEndEditing = x
			case .shouldChangeText(let x):
				let s = #selector(UITextViewDelegate.textView(_:shouldChangeTextIn:replacementText:))
				delegate().addSelector(s).shouldChangeText = x
			case .didChange(let x):
				let s = #selector(UITextViewDelegate.textViewDidChange(_:))
				delegate().addSelector(s).didChange = x
			case .didChangeSelection(let x):
				let s = #selector(UITextViewDelegate.textViewDidChangeSelection(_:))
				delegate().addSelector(s).didChangeSelection = x
			case .shouldInteractWithAttachment(let x):
				if #available(iOS 10.0, *) {
					let s = #selector(UITextViewDelegate.textView(_:shouldInteractWith:in:interaction:) as ((UITextViewDelegate) -> (UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -> Bool)?)
					delegate().addSelector(s).shouldInteractWithAttachment = x
				}
			case .shouldInteractWithURL(let x):
				if #available(iOS 10.0, *) {
					let s = #selector(UITextViewDelegate.textView(_:shouldInteractWith:in:interaction:) as ((UITextViewDelegate) -> (UITextView, URL, NSRange, UITextItemInteraction) -> Bool)?)
					delegate().addSelector(s).shouldInteractWithAttachment = x
				}
			case .inheritedBinding(let preceeding): linkedPreparer.prepareBinding(preceeding)
			default: break
			}
		}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .textInputTraits(let x):
				return AggregateLifetime(lifetimes: x.value.bindings.lazy.compactMap { trait in
					switch trait {
					case .autocapitalizationType(let y): return y.apply(instance, storage) { i, s, v in i.autocapitalizationType = v }
					case .autocorrectionType(let y): return y.apply(instance, storage) { i, s, v in i.autocorrectionType = v }
					case .spellCheckingType(let y): return y.apply(instance, storage) { i, s, v in i.spellCheckingType = v }
					case .enablesReturnKeyAutomatically(let y): return y.apply(instance, storage) { i, s, v in i.enablesReturnKeyAutomatically = v }
					case .keyboardAppearance(let y): return y.apply(instance, storage) { i, s, v in i.keyboardAppearance = v }
					case .keyboardType(let y): return y.apply(instance, storage) { i, s, v in i.keyboardType = v }
					case .returnKeyType(let y): return y.apply(instance, storage) { i, s, v in i.returnKeyType = v }
					case .isSecureTextEntry(let y): return y.apply(instance, storage) { i, s, v in i.isSecureTextEntry = v }
					case .textContentType(let y):
						return y.apply(instance, storage) { i, s, v in
							if #available(iOS 10.0, *) {
								i.textContentType = v
							}
						}
					case .smartDashesType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartDashesType = v
							}
						}
					case .smartQuotesType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartQuotesType = v
							}
						}
					case .smartInsertDeleteType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartInsertDeleteType = v
							}
						}
					}
				})
			case .text(let x): return x.apply(instance, storage) { i, s, v in i.text = v }
			case .attributedText(let x): return x.apply(instance, storage) { i, s, v in i.attributedText = v }
			case .font(let x): return x.apply(instance, storage) { i, s, v in i.font = v }
			case .textColor(let x): return x.apply(instance, storage) { i, s, v in i.textColor = v }
			case .isEditable(let x): return x.apply(instance, storage) { i, s, v in i.isEditable = v }
			case .allowsEditingTextAttributes(let x): return x.apply(instance, storage) { i, s, v in i.allowsEditingTextAttributes = v }
			case .dataDetectorTypes(let x): return x.apply(instance, storage) { i, s, v in i.dataDetectorTypes = v }
			case .textAlignment(let x): return x.apply(instance, storage) { i, s, v in i.textAlignment = v }
			case .typingAttributes(let x): return x.apply(instance, storage) { i, s, v in i.typingAttributes = v }
			case .linkTextAttributes(let x): return x.apply(instance, storage) { i, s, v in i.linkTextAttributes = v }
			case .textContainerInset(let x): return x.apply(instance, storage) { i, s, v in i.textContainerInset = v }
			case .selectedRange(let x): return x.apply(instance, storage) { i, s, v in i.selectedRange = v }
			case .clearsOnInsertion(let x): return x.apply(instance, storage) { i, s, v in i.clearsOnInsertion = v }
			case .isSelectable(let x): return x.apply(instance, storage) { i, s, v in i.isSelectable = v }
			case .inputView(let x): return x.apply(instance, storage) { i, s, v in i.inputView = v?.uiView() }
			case .inputAccessoryView(let x): return x.apply(instance, storage) { i, s, v in i.inputAccessoryView = v?.uiView() }
			case .scrollRangeToVisible(let x): return x.apply(instance, storage) { i, s, v in i.scrollRangeToVisible(v) }
			case .shouldBeginEditing: return nil
			case .didBeginEditing: return nil
			case .shouldEndEditing: return nil
			case .didEndEditing: return nil
			case .shouldChangeText: return nil
			case .didChange: return nil
			case .didChangeSelection: return nil
			case .shouldInteractWithAttachment: return nil
			case .shouldInteractWithURL: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	open class Storage: ScrollView.Storage, UITextViewDelegate {}
	
	open class Delegate: ScrollView.Delegate, UITextViewDelegate {
		public required init() {
			super.init()
		}
		
		open var shouldBeginEditing: ((UITextView) -> Bool)?
		open func textViewShouldBeginEditing(_ textView: UITextView) -> Bool {
			return shouldBeginEditing!(textView)
		}
		
		open var shouldEndEditing: ((UITextView) -> Bool)?
		open func textViewShouldEndEditing(_ textView: UITextView) -> Bool {
			return shouldEndEditing!(textView)
		}
		
		open var didBeginEditing: SignalInput<UITextView>?
		open func textViewDidBeginEditing(_ textView: UITextView) {
			didBeginEditing!.send(value: textView)
		}
		
		open var didEndEditing: SignalInput<UITextView>?
		open func textViewDidEndEditing(_ textView: UITextView) {
			didEndEditing!.send(value: textView)
		}
		
		open var shouldChangeText: ((UITextView, NSRange, String) -> Bool)?
		open func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
			return shouldChangeText!(textView, range, text)
		}
		
		open var didChange: SignalInput<UITextView>?
		open func textViewDidChange(_ textView: UITextView) {
			didChange!.send(value: textView)
		}
		
		open var didChangeSelection: SignalInput<UITextView>?
		open func textViewDidChangeSelection(_ textView: UITextView) {
			didChangeSelection!.send(value: textView)
		}
		
		open var shouldInteractWithAttachment: Any?
		@available(iOS 10.0, *)
		open func textView(_ textView: UITextView, shouldInteractWith textAttachment: NSTextAttachment, in characterRange: NSRange, interaction: UITextItemInteraction) -> Bool {
			return (shouldInteractWithAttachment as! (UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -> Bool)(textView, textAttachment, characterRange, interaction)
		}
		
		open var shouldInteractWithURL: Any?
		@available(iOS 10.0, *)
		open func textView(_ textView: UITextView, shouldInteractWith url: URL, in characterRange: NSRange, interaction: UITextItemInteraction) -> Bool {
			return (shouldInteractWithAttachment as! (UITextView, URL, NSRange, UITextItemInteraction) -> Bool)(textView, url, characterRange, interaction)
		}
	}
}

extension BindingName where Binding: TextViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .textViewBinding(TextView.Binding.$1(v)) }) }
	public static var textInputTraits: BindingName<Constant<TextInputTraits>, Binding> { return BindingName<Constant<TextInputTraits>, Binding>({ v in .textViewBinding(TextView.Binding.textInputTraits(v)) }) }
	public static var text: BindingName<Dynamic<String>, Binding> { return BindingName<Dynamic<String>, Binding>({ v in .textViewBinding(TextView.Binding.text(v)) }) }
	public static var attributedText: BindingName<Dynamic<NSAttributedString>, Binding> { return BindingName<Dynamic<NSAttributedString>, Binding>({ v in .textViewBinding(TextView.Binding.attributedText(v)) }) }
	public static var font: BindingName<Dynamic<UIFont?>, Binding> { return BindingName<Dynamic<UIFont?>, Binding>({ v in .textViewBinding(TextView.Binding.font(v)) }) }
	public static var textColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .textViewBinding(TextView.Binding.textColor(v)) }) }
	public static var isEditable: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .textViewBinding(TextView.Binding.isEditable(v)) }) }
	public static var allowsEditingTextAttributes: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .textViewBinding(TextView.Binding.allowsEditingTextAttributes(v)) }) }
	public static var dataDetectorTypes: BindingName<Dynamic<UIDataDetectorTypes>, Binding> { return BindingName<Dynamic<UIDataDetectorTypes>, Binding>({ v in .textViewBinding(TextView.Binding.dataDetectorTypes(v)) }) }
	public static var textAlignment: BindingName<Dynamic<NSTextAlignment>, Binding> { return BindingName<Dynamic<NSTextAlignment>, Binding>({ v in .textViewBinding(TextView.Binding.textAlignment(v)) }) }
	public static var typingAttributes: BindingName<Dynamic<[NSAttributedString.Key: Any]>, Binding> { return BindingName<Dynamic<[NSAttributedString.Key: Any]>, Binding>({ v in .textViewBinding(TextView.Binding.typingAttributes(v)) }) }
	public static var linkTextAttributes: BindingName<Dynamic<[NSAttributedString.Key: Any]>, Binding> { return BindingName<Dynamic<[NSAttributedString.Key: Any]>, Binding>({ v in .textViewBinding(TextView.Binding.linkTextAttributes(v)) }) }
	public static var textContainerInset: BindingName<Dynamic<UIEdgeInsets>, Binding> { return BindingName<Dynamic<UIEdgeInsets>, Binding>({ v in .textViewBinding(TextView.Binding.textContainerInset(v)) }) }
	public static var selectedRange: BindingName<Dynamic<NSRange>, Binding> { return BindingName<Dynamic<NSRange>, Binding>({ v in .textViewBinding(TextView.Binding.selectedRange(v)) }) }
	public static var clearsOnInsertion: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .textViewBinding(TextView.Binding.clearsOnInsertion(v)) }) }
	public static var isSelectable: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .textViewBinding(TextView.Binding.isSelectable(v)) }) }
	public static var inputView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .textViewBinding(TextView.Binding.inputView(v)) }) }
	public static var inputAccessoryView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .textViewBinding(TextView.Binding.inputAccessoryView(v)) }) }
	public static var scrollRangeToVisible: BindingName<Signal<NSRange>, Binding> { return BindingName<Signal<NSRange>, Binding>({ v in .textViewBinding(TextView.Binding.scrollRangeToVisible(v)) }) }
	public static var didBeginEditing: BindingName<SignalInput<UITextView>, Binding> { return BindingName<SignalInput<UITextView>, Binding>({ v in .textViewBinding(TextView.Binding.didBeginEditing(v)) }) }
	public static var didEndEditing: BindingName<SignalInput<UITextView>, Binding> { return BindingName<SignalInput<UITextView>, Binding>({ v in .textViewBinding(TextView.Binding.didEndEditing(v)) }) }
	public static var didChange: BindingName<SignalInput<UITextView>, Binding> { return BindingName<SignalInput<UITextView>, Binding>({ v in .textViewBinding(TextView.Binding.didChange(v)) }) }
	public static var didChangeSelection: BindingName<SignalInput<UITextView>, Binding> { return BindingName<SignalInput<UITextView>, Binding>({ v in .textViewBinding(TextView.Binding.didChangeSelection(v)) }) }
	public static var shouldBeginEditing: BindingName<(UITextView) -> Bool, Binding> { return BindingName<(UITextView) -> Bool, Binding>({ v in .textViewBinding(TextView.Binding.shouldBeginEditing(v)) }) }
	public static var shouldEndEditing: BindingName<(UITextView) -> Bool, Binding> { return BindingName<(UITextView) -> Bool, Binding>({ v in .textViewBinding(TextView.Binding.shouldEndEditing(v)) }) }
	public static var shouldChangeText: BindingName<(UITextView, NSRange, String) -> Bool, Binding> { return BindingName<(UITextView, NSRange, String) -> Bool, Binding>({ v in .textViewBinding(TextView.Binding.shouldChangeText(v)) }) }
	@available(iOS 10.0, *)
	public static var shouldInteractWithAttachment: BindingName<(UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -> Bool, Binding> { return BindingName<(UITextView, NSTextAttachment, NSRange, UITextItemInteraction) -> Bool, Binding>({ v in .textViewBinding(TextView.Binding.shouldInteractWithAttachment(v)) }) }
	@available(iOS 10.0, *)
	public static var shouldInteractWithURL: BindingName<(UITextView, URL, NSRange, UITextItemInteraction) -> Bool, Binding> { return BindingName<(UITextView, URL, NSRange, UITextItemInteraction) -> Bool, Binding>({ v in .textViewBinding(TextView.Binding.shouldInteractWithURL(v)) }) }
}

public protocol TextViewConvertible: ScrollViewConvertible {
	func uiTextView() -> TextView.Instance
}
extension TextViewConvertible {
	public func uiScrollView() -> ScrollView.Instance { return uiTextView() }
}
extension TextView.Instance: TextViewConvertible {
	public func uiTextView() -> TextView.Instance { return self }
}

public protocol TextViewBinding: ScrollViewBinding {
	static func textViewBinding(_ binding: TextView.Binding) -> Self
}
extension TextViewBinding {
	public static func scrollViewBinding(_ binding: ScrollView.Binding) -> Self {
		return textViewBinding(.inheritedBinding(binding))
	}
}

public class PinchGestureRecognizer: ConstructingBinder, PinchGestureRecognizerConvertible {
	public typealias Instance = UIPinchGestureRecognizer
	public typealias Inherited = GestureRecognizer
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiPinchGestureRecognizer() -> Instance { return instance() }
	
	public enum Binding: PinchGestureRecognizerBinding {
		public typealias EnclosingBinder = PinchGestureRecognizer
		public static func pinchGestureRecognizerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case scale(Dynamic<CGFloat>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = PinchGestureRecognizer
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		public init() {}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .scale(let x): return x.apply(instance, storage) { i, s, v in i.scale = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	public typealias Storage = GestureRecognizer.Storage
}

extension BindingName where Binding: PinchGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .pinchGestureRecognizerBinding(PinchGestureRecognizer.Binding.$1(v)) }) }
	public static var scale: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .pinchGestureRecognizerBinding(PinchGestureRecognizer.Binding.scale(v)) }) }
}

public protocol PinchGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiPinchGestureRecognizer() -> PinchGestureRecognizer.Instance
}
extension PinchGestureRecognizerConvertible {
	public func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiPinchGestureRecognizer() }
}
extension PinchGestureRecognizer.Instance: PinchGestureRecognizerConvertible {
	public func uiPinchGestureRecognizer() -> PinchGestureRecognizer.Instance { return self }
}

public protocol PinchGestureRecognizerBinding: GestureRecognizerBinding {
	static func pinchGestureRecognizerBinding(_ binding: PinchGestureRecognizer.Binding) -> Self
}
extension PinchGestureRecognizerBinding {
	public static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return pinchGestureRecognizerBinding(.inheritedBinding(binding))
	}
}

public class ScrollView: ConstructingBinder, ScrollViewConvertible {
	public typealias Instance = UIScrollView
	public typealias Inherited = View
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiScrollView() -> Instance { return instance() }
	
	public enum Binding: ScrollViewBinding {
		public typealias EnclosingBinder = ScrollView
		public static func scrollViewBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case panGestureRecognizerStyles(Constant<PanGestureRecognizer>)
		case pinchGestureRecognizerStyles(Constant<PinchGestureRecognizer>)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case contentOffset(Dynamic<SetOrAnimate<CGPoint>>)
		case contentSize(Dynamic<CGSize>)
		case contentInset(Dynamic<UIEdgeInsets>)
		case contentInsetAdjustmentBehavior(Dynamic<UIScrollView.ContentInsetAdjustmentBehavior>)
		case isScrollEnabled(Dynamic<Bool>)
		case isDirectionalLockEnabled(Dynamic<Bool>)
		case scrollsToTop(Dynamic<Bool>)
		case isPagingEnabled(Dynamic<Bool>)
		case bounces(Dynamic<Bool>)
		case alwaysBounceVertical(Dynamic<Bool>)
		case alwaysBounceHorizontal(Dynamic<Bool>)
		case canCancelContentTouches(Dynamic<Bool>)
		case delaysContentTouches(Dynamic<Bool>)
		case decelerationRate(Dynamic<UIScrollView.DecelerationRate>)
		case indicatorStyle(Dynamic<UIScrollView.IndicatorStyle>)
		case scrollIndicatorInsets(Dynamic<UIEdgeInsets>)
		case showsHorizontalScrollIndicator(Dynamic<Bool>)
		case showsVerticalScrollIndicator(Dynamic<Bool>)
		case zoomScale(Dynamic<CGFloat>)
		case maximumZoomScale(Dynamic<CGFloat>)
		case minimumZoomScale(Dynamic<CGFloat>)
		case bouncesZoom(Dynamic<Bool>)
		@available(iOS 10.0, *) case refreshControl(Dynamic<UIRefreshControl?>)
		
		// 2. Signal bindings are performed on the object after construction.
		case scrollRectToVisible(Signal<(rect: CGRect, animated: Bool)>)
		case zoom(Signal<(rect: CGRect, animated: Bool)>)
		case flashScrollIndicators(Signal<Void>)
		
		// 3. Action bindings are triggered by the object after construction.
		case userDidScroll(SignalInput<CGPoint>)
		case didScroll(SignalInput<CGPoint>)
		case didZoom(SignalInput<CGFloat>)
		case willBeginDragging(SignalInput<CGPoint>)
		case didEndDragging(SignalInput<(CGPoint, Bool)>)
		case didScrollToTop(SignalInput<Void>)
		case willBeginDecelerating(SignalInput<Void>)
		case didEndDecelerating(SignalInput<CGPoint>)
		case willBeginZooming(SignalInput<CGFloat>)
		case didEndZooming(SignalInput<CGFloat>)
		case didEndScrollingAnimation(SignalInput<CGPoint>)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case willEndDragging((_ scrollView: UIScrollView, _ velocity: CGPoint, _ targetContentOffset: UnsafeMutablePointer<CGPoint>) -> Void)
		case shouldScrollToTop((_ scrollView: UIScrollView) -> Bool)
		case viewForZooming((_ scrollView: UIScrollView) -> UIView?)
	}
	
	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = ScrollView
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		public init() {
			self.init(delegateClass: Delegate.self)
		}
		public init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		public let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		public mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .userDidScroll(let x):
				let s1 = #selector(UIScrollViewDelegate.scrollViewDidScrollToTop(_:))
				let s2 = #selector(UIScrollViewDelegate.scrollViewDidEndDragging(_:willDecelerate:))
				let s3 = #selector(UIScrollViewDelegate.scrollViewDidEndDecelerating(_:))
				delegate().addSelector(s1).userDidScroll = x
				_ = delegate().addSelector(s2)
				_ = delegate().addSelector(s3)
			case .didScroll(let x):
				let s = #selector(UIScrollViewDelegate.scrollViewDidScroll(_:))
				delegate().addSelector(s).didScroll = x
			case .didZoom(let x):
				let s = #selector(UIScrollViewDelegate.scrollViewDidZoom(_:))
				delegate().addSelector(s).didZoom = x
			case .willBeginDragging(let x):
				let s = #selector(UIScrollViewDelegate.scrollViewWillBeginDragging(_:))
				delegate().addSelector(s).willBeginDragging = x
			case .didEndDragging(let x):
				let s = #selector(UIScrollViewDelegate.scrollViewDidEndDragging(_:willDecelerate:))
				delegate().addSelector(s).didEndDragging = x
			case .didScrollToTop(let x):
				let s = #selector(UIScrollViewDelegate.scrollViewDidScrollToTop(_:))
				delegate().addSelector(s).didScrollToTop = x
			case .willBeginDecelerating(let x):
				let s = #selector(UIScrollViewDelegate.scrollViewWillBeginDecelerating(_:))
				delegate().addSelector(s).willBeginDecelerating = x
			case .didEndDecelerating(let x):
				let s = #selector(UIScrollViewDelegate.scrollViewDidEndDecelerating(_:))
				delegate().addSelector(s).didEndDecelerating = x
			case .willBeginZooming(let x):
				let s = #selector(UIScrollViewDelegate.scrollViewWillBeginZooming(_:with:))
				delegate().addSelector(s).willBeginZooming = x
			case .didEndZooming(let x):
				let s = #selector(UIScrollViewDelegate.scrollViewDidEndZooming(_:with:atScale:))
				delegate().addSelector(s).didEndZooming = x
			case .didEndScrollingAnimation(let x):
				let s = #selector(UIScrollViewDelegate.scrollViewDidEndScrollingAnimation(_:))
				delegate().addSelector(s).didEndScrollingAnimation = x
			case .willEndDragging(let x):
				let s = #selector(UIScrollViewDelegate.scrollViewWillEndDragging(_:withVelocity:targetContentOffset:))
				delegate().addSelector(s).willEndDragging = x
			case .shouldScrollToTop(let x):
				let s = #selector(UIScrollViewDelegate.scrollViewShouldScrollToTop(_:))
				delegate().addSelector(s).shouldScrollToTop = x
			case .viewForZooming(let x):
				let s = #selector(UIScrollViewDelegate.viewForZooming(in:))
				delegate().addSelector(s).forZooming = x
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		public mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
			storage.dynamicDelegate = possibleDelegate
			if storage.inUse {
				instance.delegate = storage
			}
			
			linkedPreparer.prepareInstance(instance, storage: storage)
		}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .panGestureRecognizerStyles(let x):
				x.value.applyBindings(to: instance.panGestureRecognizer)
				return nil
			case .pinchGestureRecognizerStyles(let x):
				if let pgr = instance.pinchGestureRecognizer {
					x.value.applyBindings(to: pgr)
				}
				return nil
			case .contentOffset(let x): return x.apply(instance, storage) { i, s, v in i.setContentOffset(v.value, animated: v.isAnimated) }
			case .contentSize(let x): return x.apply(instance, storage) { i, s, v in i.contentSize = v }
			case .contentInset(let x): return x.apply(instance, storage) { i, s, v in i.contentInset = v }
			case .contentInsetAdjustmentBehavior(let x): return x.apply(instance, storage) { i, s, v in i.contentInsetAdjustmentBehavior = v }
			case .isScrollEnabled(let x): return x.apply(instance, storage) { i, s, v in i.isScrollEnabled = v }
			case .isDirectionalLockEnabled(let x): return x.apply(instance, storage) { i, s, v in i.isDirectionalLockEnabled = v }
			case .scrollsToTop(let x): return x.apply(instance, storage) { i, s, v in i.scrollsToTop = v }
			case .isPagingEnabled(let x): return x.apply(instance, storage) { i, s, v in i.isPagingEnabled = v }
			case .bounces(let x): return x.apply(instance, storage) { i, s, v in i.bounces = v }
			case .alwaysBounceVertical(let x): return x.apply(instance, storage) { i, s, v in i.alwaysBounceVertical = v }
			case .alwaysBounceHorizontal(let x): return x.apply(instance, storage) { i, s, v in i.alwaysBounceHorizontal = v }
			case .canCancelContentTouches(let x): return x.apply(instance, storage) { i, s, v in i.canCancelContentTouches = v }
			case .delaysContentTouches(let x): return x.apply(instance, storage) { i, s, v in i.delaysContentTouches = v }
			case .decelerationRate(let x): return x.apply(instance, storage) { i, s, v in i.decelerationRate = v }
			case .indicatorStyle(let x): return x.apply(instance, storage) { i, s, v in i.indicatorStyle = v }
			case .scrollIndicatorInsets(let x): return x.apply(instance, storage) { i, s, v in i.scrollIndicatorInsets = v }
			case .showsHorizontalScrollIndicator(let x): return x.apply(instance, storage) { i, s, v in i.showsHorizontalScrollIndicator = v }
			case .showsVerticalScrollIndicator(let x): return x.apply(instance, storage) { i, s, v in i.showsVerticalScrollIndicator = v }
			case .zoomScale(let x): return x.apply(instance, storage) { i, s, v in i.zoomScale = v }
			case .maximumZoomScale(let x): return x.apply(instance, storage) { i, s, v in i.maximumZoomScale = v }
			case .minimumZoomScale(let x): return x.apply(instance, storage) { i, s, v in i.minimumZoomScale = v }
			case .bouncesZoom(let x): return x.apply(instance, storage) { i, s, v in i.bouncesZoom = v }
			case .refreshControl(let x):
				return x.apply(instance, storage) { i, s, v in
					if #available(iOS 10.0, *) {
						i.refreshControl = v
					}
				}
			case .scrollRectToVisible(let x): return x.apply(instance, storage) { i, s, v in i.scrollRectToVisible(v.rect, animated: v.animated) }
			case .zoom(let x): return x.apply(instance, storage) { i, s, v in i.zoom(to: v.rect, animated: v.animated) }
			case .flashScrollIndicators(let x): return x.apply(instance, storage) { i, s, v in i.flashScrollIndicators() }
			case .userDidScroll: return nil
			case .didScroll: return nil
			case .didZoom: return nil
			case .willBeginDragging: return nil
			case .didEndDragging: return nil
			case .didScrollToTop: return nil
			case .willBeginDecelerating: return nil
			case .didEndDecelerating: return nil
			case .willBeginZooming: return nil
			case .didEndZooming: return nil
			case .didEndScrollingAnimation: return nil
			case .willEndDragging: return nil
			case .shouldScrollToTop: return nil
			case .viewForZooming: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	open class Storage: View.Storage, UIScrollViewDelegate {}
	
	open class Delegate: DynamicDelegate, UIScrollViewDelegate {
		public required override init() {
			super.init()
		}
		
		open var userDidScroll: SignalInput<CGPoint>?
		
		open var didEndDragging: SignalInput<(CGPoint, Bool)>?
		open func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) {
			if !decelerate {
				userDidScroll?.send(value: scrollView.contentOffset)
			}
			didEndDragging?.send(value: (scrollView.contentOffset, decelerate))
		}
		
		open var didScrollToTop: SignalInput<Void>?
		open func scrollViewDidScrollToTop(_ scrollView: UIScrollView) {
			userDidScroll?.send(value: scrollView.contentOffset)
			didScrollToTop!.send(value: ())
		}
		
		open var didEndDecelerating: SignalInput<CGPoint>?
		open func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {
			userDidScroll?.send(value: scrollView.contentOffset)
			didEndDecelerating?.send(value: scrollView.contentOffset)
		}
		
		open var didScroll: SignalInput<CGPoint>?
		open func scrollViewDidScroll(_ scrollView: UIScrollView) {
			didScroll?.send(value: scrollView.contentOffset)
		}
		
		open var didZoom: SignalInput<CGFloat>?
		open func scrollViewDidZoom(_ scrollView: UIScrollView) {
			didZoom!.send(value: scrollView.zoomScale)
		}
		
		open var willBeginDragging: SignalInput<CGPoint>?
		open func scrollViewWillBeginDragging(_ scrollView: UIScrollView) {
			willBeginDragging!.send(value: scrollView.contentOffset)
		}
		
		open var willBeginDecelerating: SignalInput<Void>?
		open func scrollViewWillBeginDecelerating(_ scrollView: UIScrollView) {
			willBeginDecelerating!.send(value: ())
		}
		
		open var willBeginZooming: SignalInput<CGFloat>?
		open func scrollViewWillBeginZooming(_ scrollView: UIScrollView, with view: UIView?) {
			willBeginZooming!.send(value: scrollView.contentScaleFactor)
		}
		
		open var didEndZooming: SignalInput<CGFloat>?
		open func scrollViewDidEndZooming(_ scrollView: UIScrollView, with view: UIView?, atScale scale: CGFloat) {
			didEndZooming!.send(value: scale)
		}
		
		open var didEndScrollingAnimation: SignalInput<CGPoint>?
		open func scrollViewDidEndScrollingAnimation(_ scrollView: UIScrollView) {
			didEndScrollingAnimation!.send(value: scrollView.contentOffset)
		}
		
		open var willEndDragging: ((_ scrollView: UIScrollView, _ velocity: CGPoint, _ targetContentOffset: UnsafeMutablePointer<CGPoint>) -> Void)?
		open func scrollViewWillEndDragging(_ scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer<CGPoint>) {
			willEndDragging!(scrollView, velocity, targetContentOffset)
		}
		
		open var shouldScrollToTop: ((_ scrollView: UIScrollView) -> Bool)?
		open func scrollViewShouldScrollToTop(_ scrollView: UIScrollView) -> Bool {
			return shouldScrollToTop!(scrollView)
		}
		
		open var forZooming: ((_ scrollView: UIScrollView) -> UIView?)?
		open func viewForZooming(in scrollView: UIScrollView) -> UIView? {
			return forZooming!(scrollView)
		}
	}
}

extension BindingName where Binding: ScrollViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .scrollViewBinding(ScrollView.Binding.$1(v)) }) }
	public static var panGestureRecognizerStyles: BindingName<Constant<PanGestureRecognizer>, Binding> { return BindingName<Constant<PanGestureRecognizer>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.panGestureRecognizerStyles(v)) }) }
	public static var pinchGestureRecognizerStyles: BindingName<Constant<PinchGestureRecognizer>, Binding> { return BindingName<Constant<PinchGestureRecognizer>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.pinchGestureRecognizerStyles(v)) }) }
	public static var contentOffset: BindingName<Dynamic<SetOrAnimate<CGPoint>>, Binding> { return BindingName<Dynamic<SetOrAnimate<CGPoint>>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.contentOffset(v)) }) }
	public static var contentSize: BindingName<Dynamic<CGSize>, Binding> { return BindingName<Dynamic<CGSize>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.contentSize(v)) }) }
	public static var contentInset: BindingName<Dynamic<UIEdgeInsets>, Binding> { return BindingName<Dynamic<UIEdgeInsets>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.contentInset(v)) }) }
	public static var isScrollEnabled: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.isScrollEnabled(v)) }) }
	public static var isDirectionalLockEnabled: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.isDirectionalLockEnabled(v)) }) }
	public static var scrollsToTop: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.scrollsToTop(v)) }) }
	public static var isPagingEnabled: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.isPagingEnabled(v)) }) }
	public static var bounces: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.bounces(v)) }) }
	public static var alwaysBounceVertical: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.alwaysBounceVertical(v)) }) }
	public static var alwaysBounceHorizontal: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.alwaysBounceHorizontal(v)) }) }
	public static var canCancelContentTouches: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.canCancelContentTouches(v)) }) }
	public static var delaysContentTouches: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.delaysContentTouches(v)) }) }
	public static var decelerationRate: BindingName<Dynamic<UIScrollView.DecelerationRate>, Binding> { return BindingName<Dynamic<UIScrollView.DecelerationRate>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.decelerationRate(v)) }) }
	public static var indicatorStyle: BindingName<Dynamic<UIScrollView.IndicatorStyle>, Binding> { return BindingName<Dynamic<UIScrollView.IndicatorStyle>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.indicatorStyle(v)) }) }
	public static var scrollIndicatorInsets: BindingName<Dynamic<UIEdgeInsets>, Binding> { return BindingName<Dynamic<UIEdgeInsets>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.scrollIndicatorInsets(v)) }) }
	public static var showsHorizontalScrollIndicator: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.showsHorizontalScrollIndicator(v)) }) }
	public static var showsVerticalScrollIndicator: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.showsVerticalScrollIndicator(v)) }) }
	public static var zoomScale: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.zoomScale(v)) }) }
	public static var maximumZoomScale: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.maximumZoomScale(v)) }) }
	public static var minimumZoomScale: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.minimumZoomScale(v)) }) }
	public static var bouncesZoom: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.bouncesZoom(v)) }) }
	@available(iOS 10.0, *) public static var refreshControl: BindingName<Dynamic<UIRefreshControl?>, Binding> { return BindingName<Dynamic<UIRefreshControl?>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.refreshControl(v)) }) }
	public static var scrollRectToVisible: BindingName<Signal<(rect: CGRect, animated: Bool)>, Binding> { return BindingName<Signal<(rect: CGRect, animated: Bool)>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.scrollRectToVisible(v)) }) }
	public static var zoom: BindingName<Signal<(rect: CGRect, animated: Bool)>, Binding> { return BindingName<Signal<(rect: CGRect, animated: Bool)>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.zoom(v)) }) }
	public static var flashScrollIndicators: BindingName<Signal<Void>, Binding> { return BindingName<Signal<Void>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.flashScrollIndicators(v)) }) }
	public static var userDidScroll: BindingName<SignalInput<CGPoint>, Binding> { return BindingName<SignalInput<CGPoint>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.userDidScroll(v)) }) }
	public static var didScroll: BindingName<SignalInput<CGPoint>, Binding> { return BindingName<SignalInput<CGPoint>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.didScroll(v)) }) }
	public static var didZoom: BindingName<SignalInput<CGFloat>, Binding> { return BindingName<SignalInput<CGFloat>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.didZoom(v)) }) }
	public static var willBeginDragging: BindingName<SignalInput<CGPoint>, Binding> { return BindingName<SignalInput<CGPoint>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.willBeginDragging(v)) }) }
	public static var didEndDragging: BindingName<SignalInput<(CGPoint, Bool)>, Binding> { return BindingName<SignalInput<(CGPoint, Bool)>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.didEndDragging(v)) }) }
	public static var didScrollToTop: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.didScrollToTop(v)) }) }
	public static var willBeginDecelerating: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.willBeginDecelerating(v)) }) }
	public static var didEndDecelerating: BindingName<SignalInput<CGPoint>, Binding> { return BindingName<SignalInput<CGPoint>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.didEndDecelerating(v)) }) }
	public static var willBeginZooming: BindingName<SignalInput<CGFloat>, Binding> { return BindingName<SignalInput<CGFloat>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.willBeginZooming(v)) }) }
	public static var didEndZooming: BindingName<SignalInput<CGFloat>, Binding> { return BindingName<SignalInput<CGFloat>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.didEndZooming(v)) }) }
	public static var didEndScrollingAnimation: BindingName<SignalInput<CGPoint>, Binding> { return BindingName<SignalInput<CGPoint>, Binding>({ v in .scrollViewBinding(ScrollView.Binding.didEndScrollingAnimation(v)) }) }
	public static var willEndDragging: BindingName<(_ scrollView: UIScrollView, _ velocity: CGPoint, _ targetContentOffset: UnsafeMutablePointer<CGPoint>) -> Void, Binding> { return BindingName<(_ scrollView: UIScrollView, _ velocity: CGPoint, _ targetContentOffset: UnsafeMutablePointer<CGPoint>) -> Void, Binding>({ v in .scrollViewBinding(ScrollView.Binding.willEndDragging(v)) }) }
	public static var shouldScrollToTop: BindingName<(_ scrollView: UIScrollView) -> Bool, Binding> { return BindingName<(_ scrollView: UIScrollView) -> Bool, Binding>({ v in .scrollViewBinding(ScrollView.Binding.shouldScrollToTop(v)) }) }
	public static var viewForZooming: BindingName<(_ scrollView: UIScrollView) -> UIView?, Binding> { return BindingName<(_ scrollView: UIScrollView) -> UIView?, Binding>({ v in .scrollViewBinding(ScrollView.Binding.viewForZooming(v)) }) }
}

public protocol ScrollViewConvertible: ViewConvertible {
	func uiScrollView() -> ScrollView.Instance
}
extension ScrollViewConvertible {
	public func uiView() -> View.Instance { return uiScrollView() }
}
extension ScrollView.Instance: ScrollViewConvertible {
	public func uiScrollView() -> ScrollView.Instance { return self }
}

public protocol ScrollViewBinding: ViewBinding {
	static func scrollViewBinding(_ binding: ScrollView.Binding) -> Self
}
extension ScrollViewBinding {
	public static func viewBinding(_ binding: View.Binding) -> Self {
		return scrollViewBinding(.inheritedBinding(binding))
	}
}

public class GestureRecognizer: ConstructingBinder, GestureRecognizerConvertible {
	public typealias Instance = UIGestureRecognizer
	public typealias Inherited = BaseBinder
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiGestureRecognizer() -> Instance { return instance() }
	
	public enum Binding: GestureRecognizerBinding {
		public typealias EnclosingBinder = GestureRecognizer
		public static func gestureRecognizerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case cancelsTouchesInView(Dynamic<Bool>)
		case delaysTouchesBegan(Dynamic<Bool>)
		case delaysTouchesEnded(Dynamic<Bool>)
		case allowedPressTypes(Dynamic<[NSNumber]>)
		case allowedTouchTypes(Dynamic<[NSNumber]>)
		@available(iOS 9.2, *) case requiresExclusiveTouchType(Dynamic<Bool>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.
		case action(SignalInput<Void>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case shouldBegin((UIGestureRecognizer) -> Bool)
		case shouldReceiveTouch((UIGestureRecognizer, UITouch) -> Bool)
		case shouldRecognizeSimultanously((UIGestureRecognizer, UIGestureRecognizer) -> Bool)
		case shouldRequireFailure((UIGestureRecognizer, _ of: UIGestureRecognizer) -> Bool)
		case shouldBeRequiredToFail((UIGestureRecognizer, _ by: UIGestureRecognizer) -> Bool)
		case shouldReceivePress((UIGestureRecognizer, UIPress) -> Bool)
	}

	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = GestureRecognizer
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }

		public init() {
			self.init(delegateClass: Delegate.self)
		}
		public init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		public let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		public mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .shouldBegin(let x):
				let s = #selector(UIGestureRecognizerDelegate.gestureRecognizerShouldBegin(_:))
				delegate().addSelector(s).shouldBegin = x
			case .shouldReceiveTouch(let x):
				let s = #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldReceive:) as((UIGestureRecognizerDelegate) -> (UIGestureRecognizer, UITouch) -> Bool)?)
				delegate().addSelector(s).shouldReceiveTouch = x
			case .shouldRecognizeSimultanously(let x):
				let s = #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldRecognizeSimultaneouslyWith:))
				delegate().addSelector(s).shouldRecognizeSimultanously = x
			case .shouldRequireFailure(let x):
				let s = #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldRequireFailureOf:))
				delegate().addSelector(s).shouldRequireFailure = x
			case .shouldBeRequiredToFail(let x):
				let s = #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldBeRequiredToFailBy:))
				delegate().addSelector(s).shouldBeRequiredToFail = x
			case .shouldReceivePress(let x):
				let s = #selector(UIGestureRecognizerDelegate.gestureRecognizer(_:shouldReceive:) as((UIGestureRecognizerDelegate) -> (UIGestureRecognizer, UIPress) -> Bool)?)
				delegate().addSelector(s).shouldReceivePress = x
			case .inheritedBinding(let preceeding): linkedPreparer.prepareBinding(preceeding)
			default: break
			}
		}

		public mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
			storage.dynamicDelegate = possibleDelegate
			if storage.inUse {
				instance.delegate = storage
			}

			linkedPreparer.prepareInstance(instance, storage: storage)
		}

		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .action(let x):
				let target = SignalActionTarget()
				instance.addTarget(target, action: SignalActionTarget.selector)
				return target.signal.map { _ in () }.cancellableBind(to: x)
			case .cancelsTouchesInView(let x): return x.apply(instance, storage) { i, s, v in i.cancelsTouchesInView = v }
			case .delaysTouchesBegan(let x): return x.apply(instance, storage) { i, s, v in i.delaysTouchesBegan = v }
			case .delaysTouchesEnded(let x): return x.apply(instance, storage) { i, s, v in i.delaysTouchesEnded = v }
			case .allowedPressTypes(let x): return x.apply(instance, storage) { i, s, v in i.allowedPressTypes = v }
			case .allowedTouchTypes(let x): return x.apply(instance, storage) { i, s, v in i.allowedTouchTypes = v }
			case .requiresExclusiveTouchType(let x):
				return x.apply(instance, storage) { i, s, v in
					if #available(iOS 9.2, *) {
						i.requiresExclusiveTouchType = v
					}
				}
			case .shouldBegin: return nil
			case .shouldReceiveTouch: return nil
			case .shouldRecognizeSimultanously: return nil
			case .shouldRequireFailure: return nil
			case .shouldBeRequiredToFail: return nil
			case .shouldReceivePress: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}

	open class Storage: ObjectBinderStorage, UIGestureRecognizerDelegate {}

	open class Delegate: DynamicDelegate, UIGestureRecognizerDelegate {
		public required override init() {
			super.init()
		}
		
		open var shouldBegin: ((UIGestureRecognizer) -> Bool)?
		open func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -> Bool {
			return shouldBegin!(gestureRecognizer)
		}
		
		open var shouldReceiveTouch: ((UIGestureRecognizer, UITouch) -> Bool)?
		open func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldReceive touch: UITouch) -> Bool {
			return shouldReceiveTouch!(gestureRecognizer, touch)
		}
		
		open var shouldRecognizeSimultanously: ((UIGestureRecognizer, UIGestureRecognizer) -> Bool)?
		open func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
			return shouldRecognizeSimultanously!(gestureRecognizer, otherGestureRecognizer)
		}
		
		open var shouldRequireFailure: ((UIGestureRecognizer, _ of: UIGestureRecognizer) -> Bool)?
		open func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRequireFailureOf otherGestureRecognizer: UIGestureRecognizer) -> Bool {
			return shouldRequireFailure!(gestureRecognizer, otherGestureRecognizer)
		}
		
		open var shouldBeRequiredToFail: ((UIGestureRecognizer, _ by: UIGestureRecognizer) -> Bool)?
		open func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldBeRequiredToFailBy otherGestureRecognizer: UIGestureRecognizer) -> Bool {
			return shouldBeRequiredToFail!(gestureRecognizer, otherGestureRecognizer)
		}
		
		open var shouldReceivePress: ((UIGestureRecognizer, UIPress) -> Bool)?
		open func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldReceive press: UIPress) -> Bool {
			return shouldReceivePress!(gestureRecognizer, press)
		}
	}
}

extension BindingName where Binding: GestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.$1(v)) }) }
	public static var cancelsTouchesInView: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.cancelsTouchesInView(v)) }) }
	public static var delaysTouchesBegan: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.delaysTouchesBegan(v)) }) }
	public static var delaysTouchesEnded: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.delaysTouchesEnded(v)) }) }
	public static var allowedPressTypes: BindingName<Dynamic<[NSNumber]>, Binding> { return BindingName<Dynamic<[NSNumber]>, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.allowedPressTypes(v)) }) }
	public static var allowedTouchTypes: BindingName<Dynamic<[NSNumber]>, Binding> { return BindingName<Dynamic<[NSNumber]>, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.allowedTouchTypes(v)) }) }
	@available(iOS 9.2, *) public static var requiresExclusiveTouchType: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.requiresExclusiveTouchType(v)) }) }
	public static var action: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.action(v)) }) }
	public static var shouldBegin: BindingName<(UIGestureRecognizer) -> Bool, Binding> { return BindingName<(UIGestureRecognizer) -> Bool, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.shouldBegin(v)) }) }
	public static var shouldReceiveTouch: BindingName<(UIGestureRecognizer, UITouch) -> Bool, Binding> { return BindingName<(UIGestureRecognizer, UITouch) -> Bool, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.shouldReceiveTouch(v)) }) }
	public static var shouldRecognizeSimultanously: BindingName<(UIGestureRecognizer, UIGestureRecognizer) -> Bool, Binding> { return BindingName<(UIGestureRecognizer, UIGestureRecognizer) -> Bool, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.shouldRecognizeSimultanously(v)) }) }
	public static var shouldRequireFailure: BindingName<(UIGestureRecognizer, _ of: UIGestureRecognizer) -> Bool, Binding> { return BindingName<(UIGestureRecognizer, _ of: UIGestureRecognizer) -> Bool, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.shouldRequireFailure(v)) }) }
	public static var shouldBeRequiredToFail: BindingName<(UIGestureRecognizer, _ by: UIGestureRecognizer) -> Bool, Binding> { return BindingName<(UIGestureRecognizer, _ by: UIGestureRecognizer) -> Bool, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.shouldBeRequiredToFail(v)) }) }
	public static var shouldReceivePress: BindingName<(UIGestureRecognizer, UIPress) -> Bool, Binding> { return BindingName<(UIGestureRecognizer, UIPress) -> Bool, Binding>({ v in .gestureRecognizerBinding(GestureRecognizer.Binding.shouldReceivePress(v)) }) }
}

public protocol GestureRecognizerConvertible {
	func uiGestureRecognizer() -> GestureRecognizer.Instance
}
extension GestureRecognizer.Instance: GestureRecognizerConvertible {
	public func uiGestureRecognizer() -> GestureRecognizer.Instance { return self }
}

public protocol GestureRecognizerBinding: BaseBinding {
	static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self
}

extension GestureRecognizerBinding {
	public static func baseBinding(_ binding: BaseBinder.Binding) -> Self {
		return gestureRecognizerBinding(.inheritedBinding(binding))
	}
}

public class Control: ConstructingBinder, ControlConvertible {
	public typealias Instance = UIControl
	public typealias Inherited = View
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiControl() -> Instance { return instance() }
	
	public enum Binding: ControlBinding {
		public typealias EnclosingBinder = Control
		public static func controlBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case isEnabled(Dynamic<Bool>)
		case isSelected(Dynamic<Bool>)
		case isHighlighted(Dynamic<Bool>)
		case contentVerticalAlignment(Dynamic<UIControl.ContentVerticalAlignment>)
		case contentHorizontalAlignment(Dynamic<UIControl.ContentHorizontalAlignment>)
		case actions(Dynamic<ControlActions>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = Control
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		public init() {}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .isEnabled(let x): return x.apply(instance, storage) { i, s, v in i.isEnabled = v }
			case .isSelected(let x): return x.apply(instance, storage) { i, s, v in i.isSelected = v }
			case .isHighlighted(let x): return x.apply(instance, storage) { i, s, v in i.isHighlighted = v }
			case .contentVerticalAlignment(let x): return x.apply(instance, storage) { i, s, v in i.contentVerticalAlignment = v }
			case .contentHorizontalAlignment(let x): return x.apply(instance, storage) { i, s, v in i.contentHorizontalAlignment = v }
			case .actions(let x):
				var previous: ScopedValues<UIControl.Event, ControlAction>? = nil
				var junctions = [Lifetime]()
				var lifetime = x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.removeTarget(nil, action: nil, for: c.0)
						}
					}
					previous = v
					junctions.removeAll()
					for c in v.pairs {
						switch c.1 {
						case .firstResponder(let s):
							i.addTarget(nil, action: s, for: c.0)
						case .singleTarget(let s):
							let target = SignalControlEventActionTarget()
							i.addTarget(target, action: target.selector, for: c.0)
							junctions += target.signal.cancellableBind(to: s)
						}
					}
				}
				return OnDelete {
					for var j in junctions {
						j.cancel()
					}
					lifetime?.cancel()
				}
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	public typealias Storage = View.Storage
}

extension BindingName where Binding: ControlBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .controlBinding(Control.Binding.$1(v)) }) }
	public static var isEnabled: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .controlBinding(Control.Binding.isEnabled(v)) }) }
	public static var isSelected: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .controlBinding(Control.Binding.isSelected(v)) }) }
	public static var isHighlighted: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .controlBinding(Control.Binding.isHighlighted(v)) }) }
	public static var contentVerticalAlignment: BindingName<Dynamic<UIControl.ContentVerticalAlignment>, Binding> { return BindingName<Dynamic<UIControl.ContentVerticalAlignment>, Binding>({ v in .controlBinding(Control.Binding.contentVerticalAlignment(v)) }) }
	public static var contentHorizontalAlignment: BindingName<Dynamic<UIControl.ContentHorizontalAlignment>, Binding> { return BindingName<Dynamic<UIControl.ContentHorizontalAlignment>, Binding>({ v in .controlBinding(Control.Binding.contentHorizontalAlignment(v)) }) }
	public static var actions: BindingName<Dynamic<ControlActions>, Binding> { return BindingName<Dynamic<ControlActions>, Binding>({ v in .controlBinding(Control.Binding.actions(v)) }) }
}

extension BindingName where Binding: ControlBinding, Binding.EnclosingBinder: BinderChain {
	// Additional helper binding names
	
	// This is the *preferred* construction of actions.
	public static func action<I: SignalInputInterface>(_ scope: UIControl.Event) -> BindingName<I, Binding> where I.InputValue == Void {
		return BindingName<I, Binding>({ (v: I) -> Binding in
			Binding.controlBinding(Control.Binding.actions(.constant(ControlActions.value(.singleTarget(Input<(UIControl, UIEvent)>().map { c, e in () }.bind(to: v.input)), for: scope))))
		})
	}
	public static func action<I: SignalInputInterface, Value>(_ scope: UIControl.Event, _ keyPath: KeyPath<Binding.EnclosingBinder.Instance, Value>) -> BindingName<I, Binding> where I.InputValue == Value {
		return BindingName<I, Binding> { (v: I) -> Binding in
			Binding.controlBinding(
				Control.Binding.actions(
					.constant(
						ControlActions.value(
							.singleTarget(
								Input<(UIControl, UIEvent)>()
									.map { c, e -> Value in
										(c as! Binding.EnclosingBinder.Instance)[keyPath: keyPath]
									}.bind(to: v.input)
							),
							for: scope
						)
					)
				)
			)
		}
	}
}

public protocol ControlConvertible: ViewConvertible {
	func uiControl() -> Control.Instance
}
extension ControlConvertible {
	public func uiView() -> View.Instance { return uiControl() }
}
extension Control.Instance: ControlConvertible {
	public func uiControl() -> Control.Instance { return self }
}

public protocol ControlBinding: ViewBinding {
	static func controlBinding(_ binding: Control.Binding) -> Self
}
extension ControlBinding {
	public static func viewBinding(_ binding: View.Binding) -> Self {
		return controlBinding(.inheritedBinding(binding))
	}
}

public enum ControlAction {
	case firstResponder(Selector)
	case singleTarget(SignalInput<(UIControl, UIEvent)>)
}

public typealias ControlActions = ScopedValues<UIControl.Event, ControlAction>

extension ScopedValues where Scope == UIControl.State {
	public static func normal(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .normal)
	}
	public static func highlighted(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .highlighted)
	}
	public static func disabled(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .disabled)
	}
	public static func selected(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .selected)
	}
	@available(iOS 9.0, *)
	public static func focused(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .focused)
	}
	public static func application(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .application)
	}
	public static func reserved(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .reserved)
	}
}

open class SignalControlEventActionTarget: NSObject {
	private var signalInput: SignalInput<(UIControl, UIEvent)>? = nil
	
	// Ownership note: we are owned by the output signal so we only weakly retain it.
	private weak var signalOutput: SignalMulti<(UIControl, UIEvent)>? = nil
	
	/// The `signal` emits the actions received
	public var signal: SignalMulti<(UIControl, UIEvent)> {
		// If there's a current signal output, return it
		if let so = signalOutput {
			return so
		}
		
		// Otherwise, create a new one
		let (i, s) = Signal<(UIControl, UIEvent)>.create { s in
			// Instead of using a `isContinuous` transform, use a `buffer` to do the same thing while capturing `self` so that we're owned by the signal.
			s.customActivation { (b: inout Array<(UIControl, UIEvent)>, e: inout Error?, r: Result<(UIControl, UIEvent)>) in
				withExtendedLifetime(self) {}
				switch r {
				case .success(let v):
					b.removeAll(keepingCapacity: true)
					b.append(v)
				case .failure(let err):
					e = err
				}
			}
		}
		self.signalInput = i
		self.signalOutput = s
		return s
	}
	
	/// Receiver function for the target-action events
	///
	/// - Parameter sender: typical target-action "sender" parameter
	@IBAction public func cwlSignalAction(_ sender: UIControl, forEvent event: UIEvent) {
		_ = signalInput?.send(value: (sender, event))
	}
	
	/// Convenience accessor for `#selector(SignalActionTarget<Value>.action(_:))`
	public var selector: Selector { return #selector(SignalControlEventActionTarget.cwlSignalAction(_:forEvent:)) }
}


public class Button: ConstructingBinder, ButtonConvertible {
	public typealias Instance = UIButton
	public typealias Inherited = Control
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiButton() -> Instance { return instance() }
	
	public enum Binding: ButtonBinding {
		public typealias EnclosingBinder = Button
		public static func buttonBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case type(Constant<UIButton.ButtonType>)
		case titleLabel(Constant<Label>)
		case imageView(Constant<ImageView>)
	
		// 1. Value bindings may be applied at construction and may subsequently change.
		case adjustsImageWhenHighlighted(Dynamic<Bool>)
		case adjustsImageWhenDisabled(Dynamic<Bool>)
		case showsTouchWhenHighlighted(Dynamic<Bool>)
		case contentEdgeInsets(Dynamic<UIEdgeInsets>)
		case titleEdgeInsets(Dynamic<UIEdgeInsets>)
		case imageEdgeInsets(Dynamic<UIEdgeInsets>)
		
		case title(Dynamic<ScopedValues<UIControl.State, String?>>)
		case titleColor(Dynamic<ScopedValues<UIControl.State, UIColor?>>)
		case titleShadowColor(Dynamic<ScopedValues<UIControl.State, UIColor?>>)
		case attributedTitle(Dynamic<ScopedValues<UIControl.State, NSAttributedString?>>)
		case backgroundImage(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		case image(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = Button
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance {
			return subclass.init(type: type)
		}
		
		var type: UIButton.ButtonType = .roundedRect
		
		public init() {}
		
		public mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .type(let x): type = x.value
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .titleLabel(let x):
				if let tl = instance.titleLabel {
					x.value.applyBindings(to: tl)
				}
				return nil
			case .imageView(let x):
				if let iv = instance.imageView {
					x.value.applyBindings(to: iv)
				}
				return nil
			case .type: return nil
			case .title(let x):
				var previous: ScopedValues<UIControl.State, String?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setTitle(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setTitle(c.1, for: c.0)
					}
				}
			case .titleColor(let x):
				var previous: ScopedValues<UIControl.State, UIColor?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setTitleColor(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setTitleColor(c.1, for: c.0)
					}
				}
			case .titleShadowColor(let x):
				var previous: ScopedValues<UIControl.State, UIColor?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setTitleShadowColor(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setTitleShadowColor(c.1, for: c.0)
					}
				}
			case .attributedTitle(let x):
				var previous: ScopedValues<UIControl.State, NSAttributedString?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setAttributedTitle(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setAttributedTitle(c.1, for: c.0)
					}
				}
			case .backgroundImage(let x):
				var previous: ScopedValues<UIControl.State, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setBackgroundImage(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setBackgroundImage(c.1, for: c.0)
					}
				}
			case .image(let x):
				var previous: ScopedValues<UIControl.State, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setImage(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setImage(c.1, for: c.0)
					}
				}
			case .adjustsImageWhenHighlighted(let x): return x.apply(instance, storage) { i, s, v in i.adjustsImageWhenHighlighted = v }
			case .adjustsImageWhenDisabled(let x): return x.apply(instance, storage) { i, s, v in i.adjustsImageWhenDisabled = v }
			case .showsTouchWhenHighlighted(let x): return x.apply(instance, storage) { i, s, v in i.showsTouchWhenHighlighted = v }
			case .contentEdgeInsets(let x): return x.apply(instance, storage) { i, s, v in i.contentEdgeInsets = v }
			case .titleEdgeInsets(let x): return x.apply(instance, storage) { i, s, v in i.titleEdgeInsets = v }
			case .imageEdgeInsets(let x): return x.apply(instance, storage) { i, s, v in i.imageEdgeInsets = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	public typealias Storage = Control.Storage
}

extension BindingName where Binding: ButtonBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .buttonBinding(Button.Binding.$1(v)) }) }
	public static var type: BindingName<Constant<UIButton.ButtonType>, Binding> { return BindingName<Constant<UIButton.ButtonType>, Binding>({ v in .buttonBinding(Button.Binding.type(v)) }) }
	public static var titleLabel: BindingName<Constant<Label>, Binding> { return BindingName<Constant<Label>, Binding>({ v in .buttonBinding(Button.Binding.titleLabel(v)) }) }
	public static var imageView: BindingName<Constant<ImageView>, Binding> { return BindingName<Constant<ImageView>, Binding>({ v in .buttonBinding(Button.Binding.imageView(v)) }) }
	public static var adjustsImageWhenHighlighted: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .buttonBinding(Button.Binding.adjustsImageWhenHighlighted(v)) }) }
	public static var adjustsImageWhenDisabled: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .buttonBinding(Button.Binding.adjustsImageWhenDisabled(v)) }) }
	public static var showsTouchWhenHighlighted: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .buttonBinding(Button.Binding.showsTouchWhenHighlighted(v)) }) }
	public static var contentEdgeInsets: BindingName<Dynamic<UIEdgeInsets>, Binding> { return BindingName<Dynamic<UIEdgeInsets>, Binding>({ v in .buttonBinding(Button.Binding.contentEdgeInsets(v)) }) }
	public static var titleEdgeInsets: BindingName<Dynamic<UIEdgeInsets>, Binding> { return BindingName<Dynamic<UIEdgeInsets>, Binding>({ v in .buttonBinding(Button.Binding.titleEdgeInsets(v)) }) }
	public static var imageEdgeInsets: BindingName<Dynamic<UIEdgeInsets>, Binding> { return BindingName<Dynamic<UIEdgeInsets>, Binding>({ v in .buttonBinding(Button.Binding.imageEdgeInsets(v)) }) }
	public static var title: BindingName<Dynamic<ScopedValues<UIControl.State, String?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, String?>>, Binding>({ v in .buttonBinding(Button.Binding.title(v)) }) }
	public static var titleColor: BindingName<Dynamic<ScopedValues<UIControl.State, UIColor?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, UIColor?>>, Binding>({ v in .buttonBinding(Button.Binding.titleColor(v)) }) }
	public static var titleShadowColor: BindingName<Dynamic<ScopedValues<UIControl.State, UIColor?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, UIColor?>>, Binding>({ v in .buttonBinding(Button.Binding.titleShadowColor(v)) }) }
	public static var attributedTitle: BindingName<Dynamic<ScopedValues<UIControl.State, NSAttributedString?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, NSAttributedString?>>, Binding>({ v in .buttonBinding(Button.Binding.attributedTitle(v)) }) }
	public static var backgroundImage: BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding>({ v in .buttonBinding(Button.Binding.backgroundImage(v)) }) }
	public static var image: BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding>({ v in .buttonBinding(Button.Binding.image(v)) }) }
}

public protocol ButtonConvertible: ControlConvertible {
	func uiButton() -> Button.Instance
}
extension ButtonConvertible {
	public func uiControl() -> Control.Instance { return uiButton() }
}
extension Button.Instance: ButtonConvertible {
	public func uiButton() -> Button.Instance { return self }
}

public protocol ButtonBinding: ControlBinding {
	static func buttonBinding(_ binding: Button.Binding) -> Self
}

extension ButtonBinding {
	public static func controlBinding(_ binding: Control.Binding) -> Self {
		return buttonBinding(.inheritedBinding(binding))
	}
}


public struct TextInputTraits {
	let bindings: [Binding]
	public init(bindings: [Binding]) {
		self.bindings = bindings
	}
	public init(_ bindings: Binding...) {
		self.init(bindings: bindings)
	}
	
	public enum Binding {
		case autocapitalizationType(Dynamic<UITextAutocapitalizationType>)
		case autocorrectionType(Dynamic<UITextAutocorrectionType>)
		case spellCheckingType(Dynamic<UITextSpellCheckingType>)
		case enablesReturnKeyAutomatically(Dynamic<Bool>)
		case keyboardAppearance(Dynamic<UIKeyboardAppearance>)
		case keyboardType(Dynamic<UIKeyboardType>)
		case returnKeyType(Dynamic<UIReturnKeyType>)
		@available(iOS 11.0, *)
		case smartDashesType(Dynamic<UITextSmartDashesType>)
		@available(iOS 11.0, *)
		case smartQuotesType(Dynamic<UITextSmartQuotesType>)
		@available(iOS 11.0, *)
		case smartInsertDeleteType(Dynamic<UITextSmartInsertDeleteType>)
		case isSecureTextEntry(Dynamic<Bool>)
		@available(iOS 10.0, *)
		case textContentType(Dynamic<UITextContentType>)
	}
}

extension BindingName where Binding == TextInputTraits.Binding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in TextInputTraits.$1(v) }) }
	public static var autocapitalizationType: BindingName<Dynamic<UITextAutocapitalizationType>, Binding> { return BindingName<Dynamic<UITextAutocapitalizationType>, Binding>({ v in TextInputTraits.Binding.autocapitalizationType(v) }) }
	public static var autocorrectionType: BindingName<Dynamic<UITextAutocorrectionType>, Binding> { return BindingName<Dynamic<UITextAutocorrectionType>, Binding>({ v in TextInputTraits.Binding.autocorrectionType(v) }) }
	public static var spellCheckingType: BindingName<Dynamic<UITextSpellCheckingType>, Binding> { return BindingName<Dynamic<UITextSpellCheckingType>, Binding>({ v in TextInputTraits.Binding.spellCheckingType(v) }) }
	public static var enablesReturnKeyAutomatically: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in TextInputTraits.Binding.enablesReturnKeyAutomatically(v) }) }
	public static var keyboardAppearance: BindingName<Dynamic<UIKeyboardAppearance>, Binding> { return BindingName<Dynamic<UIKeyboardAppearance>, Binding>({ v in TextInputTraits.Binding.keyboardAppearance(v) }) }
	public static var keyboardType: BindingName<Dynamic<UIKeyboardType>, Binding> { return BindingName<Dynamic<UIKeyboardType>, Binding>({ v in TextInputTraits.Binding.keyboardType(v) }) }
	public static var returnKeyType: BindingName<Dynamic<UIReturnKeyType>, Binding> { return BindingName<Dynamic<UIReturnKeyType>, Binding>({ v in TextInputTraits.Binding.returnKeyType(v) }) }
	@available(iOS 11.0, *)
	public static var smartDashesType: BindingName<Dynamic<UITextSmartDashesType>, Binding> { return BindingName<Dynamic<UITextSmartDashesType>, Binding>({ v in TextInputTraits.Binding.smartDashesType(v) }) }
	@available(iOS 11.0, *)
	public static var smartQuotesType: BindingName<Dynamic<UITextSmartQuotesType>, Binding> { return BindingName<Dynamic<UITextSmartQuotesType>, Binding>({ v in TextInputTraits.Binding.smartQuotesType(v) }) }
	@available(iOS 11.0, *)
	public static var smartInsertDeleteType: BindingName<Dynamic<UITextSmartInsertDeleteType>, Binding> { return BindingName<Dynamic<UITextSmartInsertDeleteType>, Binding>({ v in TextInputTraits.Binding.smartInsertDeleteType(v) }) }
	public static var isSecureTextEntry: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in TextInputTraits.Binding.isSecureTextEntry(v) }) }
	@available(iOS 10.0, *)
	public static var textContentType: BindingName<Dynamic<UITextContentType>, Binding> { return BindingName<Dynamic<UITextContentType>, Binding>({ v in TextInputTraits.Binding.textContentType(v) }) }
}

public class ViewController: ConstructingBinder, ViewControllerConvertible {
	public typealias Instance = UIViewController
	public typealias Inherited = BaseBinder
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiViewController() -> Instance { return instance() }
	
	public enum Binding: ViewControllerBinding {
		public typealias EnclosingBinder = ViewController
		public static func viewControllerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case navigationItem(Constant<NavigationItem>)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case view(Dynamic<ViewConvertible>)
		case title(Dynamic<String>)
		case preferredContentSize(Dynamic<CGSize>)
		case modalPresentationStyle(Dynamic<UIModalPresentationStyle>)
		case modalTransitionStyle(Dynamic<UIModalTransitionStyle>)
		case isModalInPopover(Dynamic<Bool>)
		case definesPresentationContext(Dynamic<Bool>)
		case providesPresentationContextTransitionStyle(Dynamic<Bool>)
		case transitioningDelegate(Dynamic<UIViewControllerTransitioningDelegate>)
		case edgesForExtendedLayout(Dynamic<UIRectEdge>)
		case extendedLayoutIncludesOpaqueBars(Dynamic<Bool>)
		case restorationIdentifier(Dynamic<String?>)
		case restorationClass(Dynamic<UIViewControllerRestoration.Type?>)
		case modalPresentationCapturesStatusBarAppearance(Dynamic<Bool>)
		case hidesBottomBarWhenPushed(Dynamic<Bool>)
		case toolbarItems(Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>)
		case tabBarItem(Dynamic<TabBarItemConvertible>)
		case isEditing(Signal<SetOrAnimate<Bool>>)
		
		// 2. Signal bindings are performed on the object after construction.
		case present(Signal<ModalPresentation>)
		
		// 3. Action bindings are triggered by the object after construction.
		case traitCollectionDidChange(SignalInput<(previous: UITraitCollection?, new: UITraitCollection)>)
		case willAppear(SignalInput<Bool>)
		case didAppear(SignalInput<Bool>)
		case didDisappear(SignalInput<Bool>)
		case willDisappear(SignalInput<Bool>)
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case loadView(() -> ViewConvertible)
		case didReceiveMemoryWarning(() -> Void)
	}
	
	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = ViewController
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init(nibName: nil, bundle: nil) }
		
		public init() {}
		
		public var view: InitialSubsequent<ViewConvertible>?
		public var loadView: (() -> ViewConvertible)?
		
		public mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .loadView(let x):
				assert(view == nil, "Construct the view using either .loadView or .view, not both.")
				loadView = x
			case .view(let x):
				assert(loadView == nil, "Construct the view using either .loadView or .view, not both.")
				view = x.initialSubsequent()
			case .inheritedBinding(let preceeding): linkedPreparer.prepareBinding(preceeding)
			default: break
			}
		}
		
		public mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			// The loadView function needs to be ready in case one of the bindings triggers a view load.
			if let v = view?.initial() {
				storage.view = v
				instance.setBinderStorage(storage)
			} else if let lv = loadView {
				storage.viewConstructor = lv
				instance.setBinderStorage(storage)
			}
		}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .loadView: return nil
			case .view:
				return view?.subsequent.flatMap { $0.apply(instance, storage) { i, s, v in
					storage.view = v
					if i.isViewLoaded {
						i.view = v.uiView()
					}
				} }
			case .title(let x): return x.apply(instance, storage) { i, s, v in i.title = v }
			case .preferredContentSize(let x): return x.apply(instance, storage) { i, s, v in i.preferredContentSize = v }
			case .modalPresentationStyle(let x): return x.apply(instance, storage) { i, s, v in i.modalPresentationStyle = v }
			case .modalTransitionStyle(let x): return x.apply(instance, storage) { i, s, v in i.modalTransitionStyle = v }
			case .isModalInPopover(let x): return x.apply(instance, storage) { i, s, v in i.isModalInPopover = v }
			case .definesPresentationContext(let x): return x.apply(instance, storage) { i, s, v in i.definesPresentationContext = v }
			case .providesPresentationContextTransitionStyle(let x): return x.apply(instance, storage) { i, s, v in i.providesPresentationContextTransitionStyle = v }
			case .transitioningDelegate(let x): return x.apply(instance, storage) { i, s, v in i.transitioningDelegate = v }
			case .edgesForExtendedLayout(let x): return x.apply(instance, storage) { i, s, v in i.edgesForExtendedLayout = v }
			case .extendedLayoutIncludesOpaqueBars(let x): return x.apply(instance, storage) { i, s, v in i.extendedLayoutIncludesOpaqueBars = v }
			case .restorationIdentifier(let x): return x.apply(instance, storage) { i, s, v in i.restorationIdentifier = v }
			case .restorationClass(let x): return x.apply(instance, storage) { i, s, v in i.restorationClass = v }
			case .modalPresentationCapturesStatusBarAppearance(let x): return x.apply(instance, storage) { i, s, v in i.modalPresentationCapturesStatusBarAppearance = v }
			case .hidesBottomBarWhenPushed(let x): return x.apply(instance, storage) { i, s, v in i.hidesBottomBarWhenPushed = v }
			case .toolbarItems(let x): return x.apply(instance, storage) { i, s, v in i.setToolbarItems(v.value.map { $0.uiBarButtonItem() }, animated: v.isAnimated) }
			case .tabBarItem(let x): return x.apply(instance, storage) { i, s, v in i.tabBarItem = v.uiTabBarItem() }
			case .isEditing(let x): return x.apply(instance, storage) { i, s, v in i.setEditing(v.value, animated: v.isAnimated) }
			case .present(let x):
				return x.apply(instance, storage) { i, s, v in
					s.queuedModalPresentations.append(v)
					s.processModalPresentations(viewController: i)
				}
			case .navigationItem(let x):
				x.value.applyBindings(to: instance.navigationItem)
				return nil
			case .traitCollectionDidChange(let x):
				storage.traitCollectionDidChange = x
				return x
			case .willAppear(let x):
				storage.willAppear = x
				return x
			case .didDisappear(let x):
				storage.didDisappear = x
				return x
			case .didAppear(let x):
				storage.didAppear = x
				return x
			case .willDisappear(let x):
				storage.willDisappear = x
				return x
			case .didReceiveMemoryWarning(let x):
				storage.didReceiveMemoryWarning = x
				return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: (), storage: ())
			}
		}
		
		public mutating func finalizeInstance(_ instance: Instance, storage: Storage) -> Lifetime? {
			let lifetime = linkedPreparer.finalizeInstance((), storage: ())
			
			// Send the initial "traitsCollection" once construction is complete.
			if let tcdc = storage.traitCollectionDidChange {
				tcdc.send(value: (previous: nil, new: instance.traitCollection))
			}
			return lifetime
		}
	}
	
	open class Storage: ObjectBinderStorage {
		open var traitCollectionDidChange: SignalInput<(previous: UITraitCollection?, new: UITraitCollection)>?
		open var didDisappear: SignalInput<Bool>?
		open var willAppear: SignalInput<Bool>?
		open var willDisappear: SignalInput<Bool>?
		open var didAppear: SignalInput<Bool>?
		open var queuedModalPresentations: [ModalPresentation] = []
		open var presentationInProgress: Bool = false
		open var view: ViewConvertible?
		open var viewConstructor: (() -> ViewConvertible?)?
		open var didReceiveMemoryWarning: (() -> Void)?
		
		open override var inUse: Bool {
			return super.inUse || view != nil || viewConstructor != nil || didReceiveMemoryWarning != nil
		}
		
		private static var isSwizzled: Bool = false
		private static let ensureSwizzled: () = {
			if isSwizzled {
				assertionFailure("This line should be unreachable")
				return
			}
			
			let loadViewSource = class_getInstanceMethod(UIViewController.self, #selector(UIViewController.loadView))!
			let loadViewDestination = class_getInstanceMethod(ViewController.Storage.self, #selector(ViewController.Storage.swizzledLoadView))!
			method_exchangeImplementations(loadViewSource, loadViewDestination)
			
			let traitCollectionDidChangeSource = class_getInstanceMethod(UIViewController.self, #selector(UIViewController.traitCollectionDidChange(_:)))!
			let traitCollectionDidChangeDestination = class_getInstanceMethod(ViewController.Storage.self, #selector(ViewController.Storage.swizzledTraitCollectionDidChange(_:)))!
			method_exchangeImplementations(traitCollectionDidChangeSource, traitCollectionDidChangeDestination)
			
			let willAppearSource = class_getInstanceMethod(UIViewController.self, #selector(UIViewController.viewWillAppear(_:)))!
			let willAppearDestination = class_getInstanceMethod(ViewController.Storage.self, #selector(ViewController.Storage.swizzledViewWillAppear(_:)))!
			method_exchangeImplementations(willAppearSource, willAppearDestination)
			
			let didDisappearSource = class_getInstanceMethod(UIViewController.self, #selector(UIViewController.viewDidDisappear(_:)))!
			let didDisappearDestination = class_getInstanceMethod(ViewController.Storage.self, #selector(ViewController.Storage.swizzledViewDidDisappear(_:)))!
			method_exchangeImplementations(didDisappearSource, didDisappearDestination)
			
			let didAppearSource = class_getInstanceMethod(UIViewController.self, #selector(UIViewController.viewDidAppear(_:)))!
			let didAppearDestination = class_getInstanceMethod(ViewController.Storage.self, #selector(ViewController.Storage.swizzledViewDidAppear(_:)))!
			method_exchangeImplementations(didAppearSource, didAppearDestination)
			
			let willDisappearSource = class_getInstanceMethod(UIViewController.self, #selector(UIViewController.viewWillDisappear(_:)))!
			let willDisappearDestination = class_getInstanceMethod(ViewController.Storage.self, #selector(ViewController.Storage.swizzledViewWillDisappear(_:)))!
			method_exchangeImplementations(willDisappearSource, willDisappearDestination)
			
			let didReceiveMemoryWarningSource = class_getInstanceMethod(UIViewController.self, #selector(UIViewController.didReceiveMemoryWarning))!
			let didReceiveMemoryWarningDestination = class_getInstanceMethod(ViewController.Storage.self, #selector(ViewController.Storage.swizzledDidReceiveMemoryWarning))!
			method_exchangeImplementations(didReceiveMemoryWarningSource, didReceiveMemoryWarningDestination)
			
			isSwizzled = true
		}()
		
		public override init() {
			ViewController.Storage.ensureSwizzled
			super.init()
		}
		
		open func processModalPresentations(viewController: UIViewController) {
			if presentationInProgress {
				return
			}
			if let mp = queuedModalPresentations.first {
				if let vc = mp.viewController {
					guard viewController.view.window != nil else {
						presentationInProgress = false
						return
					}
					presentationInProgress = true
					viewController.present(vc.uiViewController(), animated: mp.animated) {
						mp.completion?.send(value: ())
						self.queuedModalPresentations.removeFirst()
						self.presentationInProgress = false
						self.processModalPresentations(viewController: viewController)
					}
				} else {
					presentationInProgress = true
					if let vc = viewController.presentedViewController, !vc.isBeingDismissed {
						vc.dismiss(animated: mp.animated, completion: { () -> Void in
							mp.completion?.send(value: ())
							self.queuedModalPresentations.removeFirst()
							self.presentationInProgress = false
							self.processModalPresentations(viewController: viewController)
						})
					} else {
						mp.completion?.send(value: ())
						self.queuedModalPresentations.removeFirst()
						self.presentationInProgress = false
						self.processModalPresentations(viewController: viewController)
					}
				}
			}
		}
		
		open func traitCollectionDidChange(_ previous: UITraitCollection?, _ new: UITraitCollection) {
			traitCollectionDidChange?.send(value: (previous: previous, new: new))
		}
		
		open func viewWillAppear(controller: UIViewController, animated: Bool) {
			willAppear?.send(value: animated)
		}
		
		open func viewDidDisappear(controller: UIViewController, animated: Bool) {
			didDisappear?.send(value: animated)
		}
		
		open func viewDidAppear(controller: UIViewController, animated: Bool) {
			didAppear?.send(value: animated)
		}
		
		open func viewWillDisappear(controller: UIViewController, animated: Bool) {
			willDisappear?.send(value: animated)
		}
		
		open func controllerDidReceiveMemoryWarning(controller: UIViewController) {
			didReceiveMemoryWarning?()
			
			if viewConstructor != nil, let view = controller.viewIfLoaded, view.window == nil {
				controller.view = nil
			}
		}
		
		open func loadView(for viewController: UIViewController) -> Bool {
			if let wrapper = view ?? viewConstructor?() {
				viewController.view = wrapper.uiView()
				return true
			}
			return false
		}
		
		@objc dynamic private func swizzledLoadView() {
			assert(ViewController.Storage.isSwizzled)
			
			// SWIZZLED METHOD WARNING: `self` is an instance of UIViewController, not ViewController.Storage. Don't access any instance members on `self`.
			if let storage = getBinderStorage(type: ViewController.Storage.self) {
				let vc = unsafeBitCast(self, to: UIViewController.self)
				
				if storage.loadView(for: vc) {
					return
				}
			}
			
			// Relay back to the original implementation
			let sel = #selector(ViewController.Storage.swizzledLoadView)
			let m = class_getMethodImplementation(ViewController.Storage.self, sel)!
			unsafeBitCast(m, to: (@convention(c) (NSObjectProtocol, Selector) -> Void).self)(self, sel)
		}
		
		@objc dynamic private func swizzledTraitCollectionDidChange(_ previous: UITraitCollection?) {
			assert(ViewController.Storage.isSwizzled)
			
			// SWIZZLED METHOD WARNING: `self` is an instance of UIViewController, not ViewController.Storage. Don't access any instance members on `self`.
			if let storage = getBinderStorage(type: ViewController.Storage.self) {
				let vc = unsafeBitCast(self, to: UIViewController.self)
				storage.traitCollectionDidChange(previous, vc.traitCollection)
			}
			
			// Relay back to the original implementation
			let sel = #selector(ViewController.Storage.swizzledTraitCollectionDidChange(_:))
			let m = class_getMethodImplementation(ViewController.Storage.self, sel)!
			unsafeBitCast(m, to: (@convention(c) (NSObjectProtocol, Selector, UITraitCollection?) -> Void).self)(self, sel, previous)
		}
		
		@objc dynamic private func swizzledViewWillAppear(_ animated: Bool) {
			assert(ViewController.Storage.isSwizzled)
			
			// SWIZZLED METHOD WARNING: `self` is an instance of UIViewController, not ViewController.Storage. Don't access any instance members on `self`.
			if let storage = getBinderStorage(type: ViewController.Storage.self) {
				let vc = unsafeBitCast(self, to: UIViewController.self)
				storage.viewWillAppear(controller: vc, animated: animated)
			}
			
			// Relay back to the original implementation
			let sel = #selector(ViewController.Storage.swizzledViewWillAppear(_:))
			let m = class_getMethodImplementation(ViewController.Storage.self, sel)!
			unsafeBitCast(m, to: (@convention(c) (NSObjectProtocol, Selector, Bool) -> Void).self)(self, sel, animated)
		}
		
		@objc dynamic private func swizzledViewDidDisappear(_ animated: Bool) {
			assert(ViewController.Storage.isSwizzled)
			
			// SWIZZLED METHOD WARNING: `self` is an instance of UIViewController, not ViewController.Storage. Don't access any instance members on `self`.
			if let storage = getBinderStorage(type: ViewController.Storage.self) {
				let vc = unsafeBitCast(self, to: UIViewController.self)
				storage.viewDidDisappear(controller: vc, animated: animated)
			}
			
			// Relay back to the original implementation
			let sel = #selector(ViewController.Storage.swizzledViewDidDisappear(_:))
			let m = class_getMethodImplementation(ViewController.Storage.self, sel)!
			unsafeBitCast(m, to: (@convention(c) (NSObjectProtocol, Selector, Bool) -> Void).self)(self, sel, animated)
		}
		
		@objc dynamic private func swizzledViewDidAppear(_ animated: Bool) {
			assert(ViewController.Storage.isSwizzled)
			
			// SWIZZLED METHOD WARNING: `self` is an instance of UIViewController, not ViewController.Storage. Don't access any instance members on `self`.
			if let storage = getBinderStorage(type: ViewController.Storage.self) {
				let vc = unsafeBitCast(self, to: UIViewController.self)
				storage.viewDidAppear(controller: vc, animated: animated)
				
				// Handle any modal presentation that were deferred until adding to the window
				storage.processModalPresentations(viewController: vc)
			}
			
			// Relay back to the original implementation
			let sel = #selector(ViewController.Storage.swizzledViewDidAppear(_:))
			let m = class_getMethodImplementation(ViewController.Storage.self, sel)!
			unsafeBitCast(m, to: (@convention(c) (NSObjectProtocol, Selector, Bool) -> Void).self)(self, sel, animated)
		}
		
		@objc dynamic private func swizzledViewWillDisappear(_ animated: Bool) {
			assert(ViewController.Storage.isSwizzled)
			
			// SWIZZLED METHOD WARNING: `self` is an instance of UIViewController, not ViewController.Storage. Don't access any instance members on `self`.
			if let storage = getBinderStorage(type: ViewController.Storage.self) {
				let vc = unsafeBitCast(self, to: UIViewController.self)
				storage.viewWillDisappear(controller: vc, animated: animated)
			}
			
			// Relay back to the original implementation
			let sel = #selector(ViewController.Storage.swizzledViewWillDisappear(_:))
			let m = class_getMethodImplementation(ViewController.Storage.self, sel)!
			unsafeBitCast(m, to: (@convention(c) (NSObjectProtocol, Selector, Bool) -> Void).self)(self, sel, animated)
		}
		
		@objc dynamic private func swizzledDidReceiveMemoryWarning() {
			assert(ViewController.Storage.isSwizzled)
			
			// SWIZZLED METHOD WARNING: `self` is an instance of UIViewController, not ViewController.Storage. Don't access any instance members on `self`.
			if let storage = getBinderStorage(type: ViewController.Storage.self) {
				let vc = unsafeBitCast(self, to: UIViewController.self)
				storage.controllerDidReceiveMemoryWarning(controller: vc)
			}
			
			// Relay back to the original implementation
			let sel = #selector(ViewController.Storage.swizzledDidReceiveMemoryWarning)
			let m = class_getMethodImplementation(ViewController.Storage.self, sel)!
			unsafeBitCast(m, to: (@convention(c) (NSObjectProtocol, Selector) -> Void).self)(self, sel)
		}
	}
}

extension BindingName where Binding: ViewControllerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .viewControllerBinding(ViewController.Binding.$1(v)) }) }
	public static var view: BindingName<Dynamic<ViewConvertible>, Binding> { return BindingName<Dynamic<ViewConvertible>, Binding>({ v in .viewControllerBinding(ViewController.Binding.view(v)) }) }
	public static var navigationItem: BindingName<Constant<NavigationItem>, Binding> { return BindingName<Constant<NavigationItem>, Binding>({ v in .viewControllerBinding(ViewController.Binding.navigationItem(v)) }) }
	public static var title: BindingName<Dynamic<String>, Binding> { return BindingName<Dynamic<String>, Binding>({ v in .viewControllerBinding(ViewController.Binding.title(v)) }) }
	public static var preferredContentSize: BindingName<Dynamic<CGSize>, Binding> { return BindingName<Dynamic<CGSize>, Binding>({ v in .viewControllerBinding(ViewController.Binding.preferredContentSize(v)) }) }
	public static var modalPresentationStyle: BindingName<Dynamic<UIModalPresentationStyle>, Binding> { return BindingName<Dynamic<UIModalPresentationStyle>, Binding>({ v in .viewControllerBinding(ViewController.Binding.modalPresentationStyle(v)) }) }
	public static var modalTransitionStyle: BindingName<Dynamic<UIModalTransitionStyle>, Binding> { return BindingName<Dynamic<UIModalTransitionStyle>, Binding>({ v in .viewControllerBinding(ViewController.Binding.modalTransitionStyle(v)) }) }
	public static var isModalInPopover: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .viewControllerBinding(ViewController.Binding.isModalInPopover(v)) }) }
	public static var definesPresentationContext: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .viewControllerBinding(ViewController.Binding.definesPresentationContext(v)) }) }
	public static var providesPresentationContextTransitionStyle: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .viewControllerBinding(ViewController.Binding.providesPresentationContextTransitionStyle(v)) }) }
	public static var transitioningDelegate: BindingName<Dynamic<UIViewControllerTransitioningDelegate>, Binding> { return BindingName<Dynamic<UIViewControllerTransitioningDelegate>, Binding>({ v in .viewControllerBinding(ViewController.Binding.transitioningDelegate(v)) }) }
	public static var edgesForExtendedLayout: BindingName<Dynamic<UIRectEdge>, Binding> { return BindingName<Dynamic<UIRectEdge>, Binding>({ v in .viewControllerBinding(ViewController.Binding.edgesForExtendedLayout(v)) }) }
	public static var extendedLayoutIncludesOpaqueBars: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .viewControllerBinding(ViewController.Binding.extendedLayoutIncludesOpaqueBars(v)) }) }
	public static var restorationIdentifier: BindingName<Dynamic<String?>, Binding> { return BindingName<Dynamic<String?>, Binding>({ v in .viewControllerBinding(ViewController.Binding.restorationIdentifier(v)) }) }
	public static var restorationClass: BindingName<Dynamic<UIViewControllerRestoration.Type?>, Binding> { return BindingName<Dynamic<UIViewControllerRestoration.Type?>, Binding>({ v in .viewControllerBinding(ViewController.Binding.restorationClass(v)) }) }
	public static var modalPresentationCapturesStatusBarAppearance: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .viewControllerBinding(ViewController.Binding.modalPresentationCapturesStatusBarAppearance(v)) }) }
	public static var hidesBottomBarWhenPushed: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .viewControllerBinding(ViewController.Binding.hidesBottomBarWhenPushed(v)) }) }
	public static var toolbarItems: BindingName<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding> { return BindingName<Dynamic<SetOrAnimate<[BarButtonItemConvertible]>>, Binding>({ v in .viewControllerBinding(ViewController.Binding.toolbarItems(v)) }) }
	public static var tabBarItem: BindingName<Dynamic<TabBarItemConvertible>, Binding> { return BindingName<Dynamic<TabBarItemConvertible>, Binding>({ v in .viewControllerBinding(ViewController.Binding.tabBarItem(v)) }) }
	public static var isEditing: BindingName<Signal<SetOrAnimate<Bool>>, Binding> { return BindingName<Signal<SetOrAnimate<Bool>>, Binding>({ v in .viewControllerBinding(ViewController.Binding.isEditing(v)) }) }
	public static var present: BindingName<Signal<ModalPresentation>, Binding> { return BindingName<Signal<ModalPresentation>, Binding>({ v in .viewControllerBinding(ViewController.Binding.present(v)) }) }
	public static var traitCollectionDidChange: BindingName<SignalInput<(previous: UITraitCollection?, new: UITraitCollection)>, Binding> { return BindingName<SignalInput<(previous: UITraitCollection?, new: UITraitCollection)>, Binding>({ v in .viewControllerBinding(ViewController.Binding.traitCollectionDidChange(v)) }) }
	public static var willAppear: BindingName<SignalInput<Bool>, Binding> { return BindingName<SignalInput<Bool>, Binding>({ v in .viewControllerBinding(ViewController.Binding.willAppear(v)) }) }
	public static var didAppear: BindingName<SignalInput<Bool>, Binding> { return BindingName<SignalInput<Bool>, Binding>({ v in .viewControllerBinding(ViewController.Binding.didAppear(v)) }) }
	public static var didDisappear: BindingName<SignalInput<Bool>, Binding> { return BindingName<SignalInput<Bool>, Binding>({ v in .viewControllerBinding(ViewController.Binding.didDisappear(v)) }) }
	public static var willDisappear: BindingName<SignalInput<Bool>, Binding> { return BindingName<SignalInput<Bool>, Binding>({ v in .viewControllerBinding(ViewController.Binding.willDisappear(v)) }) }
	public static var loadView: BindingName<() -> ViewConvertible, Binding> { return BindingName<() -> ViewConvertible, Binding>({ v in .viewControllerBinding(ViewController.Binding.loadView(v)) }) }
}

public protocol ViewControllerConvertible {
	func uiViewController() -> ViewController.Instance
}
extension ViewController.Instance: ViewControllerConvertible {
	public func uiViewController() -> ViewController.Instance { return self }
}

public protocol ViewControllerBinding: BaseBinding {
	static func viewControllerBinding(_ binding: ViewController.Binding) -> Self
}
extension ViewControllerBinding {
	public static func baseBinding(_ binding: BaseBinder.Binding) -> Self {
		return viewControllerBinding(.inheritedBinding(binding))
	}
}

public struct ModalPresentation {
	let viewController: ViewControllerConvertible?
	let animated: Bool
	let completion: SignalInput<Void>?
	
	public init(_ viewController: ViewControllerConvertible? = nil, animated: Bool = true, completion: SignalInput<Void>? = nil) {
		self.viewController = viewController
		self.animated = animated
		self.completion = completion
	}
}

extension SignalInterface {
	public func modalPresentation<T>(_ construct: @escaping (T) -> ViewControllerConvertible) -> Signal<ModalPresentation> where OutputValue == Optional<T> {
		return transform { (result, next) in
			switch result {
			case .success(.some(let t)): next.send(value: ModalPresentation(construct(t)))
			case .success: next.send(value: ModalPresentation(nil))
			case .failure(let e): next.send(error: e)
			}
		}
	}
}

public class SearchBar: ConstructingBinder, SearchBarConvertible {
	public typealias Instance = UISearchBar
	public typealias Inherited = View
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiSearchBar() -> Instance { return instance() }
	
	public enum Binding: SearchBarBinding {
		public typealias EnclosingBinder = SearchBar
		public static func searchBarBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case textInputTraits(Constant<TextInputTraits>)

		// 1. Value bindings may be applied at construction and may subsequently change.
		case placeholder(Dynamic<String>)
		case prompt(Dynamic<String>)
		case text(Dynamic<String>)
		case barStyle(Dynamic<UIBarStyle>)
		case tintColor(Dynamic<UIColor>)
		case isTranslucent(Dynamic<Bool>)
		case showsBookmarkButton(Dynamic<Bool>)
		case showsSearchResultsButton(Dynamic<Bool>)
		case showCancelButton(Dynamic<SetOrAnimate<Bool>>)
		case scopeButtonTitles(Dynamic<[String]?>)
		case selectedScopeButtonIndex(Dynamic<Int>)
		case showsScopeBar(Dynamic<Bool>)
		case backgroundImage(Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>)
		case image(Dynamic<ScopedValues<IconAndControlState, UIImage?>>)
		case positionAdjustment(Dynamic<ScopedValues<UISearchBar.Icon, UIOffset>>)
		case inputAccessoryView(Dynamic<UIView?>)
		case scopeBarButtonBackgroundImage(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		case scopeBarButtonDividerImage(Dynamic<ScopedValues<LeftRightControlState, UIImage?>>)
		case scopeBarButtonTitleTextAttributes(Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]?>>)
		case searchFieldBackgroundImage(Dynamic<ScopedValues<UIControl.State, UIImage?>>)
		case searchFieldBackgroundPositionAdjustment(Dynamic<UIOffset>)
		case searchTextPositionAdjustment(Dynamic<UIOffset>)

		// 2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.
		case didChange(SignalInput<String>)
		case didBeginEditing(SignalInput<Void>)
		case didEndEditing(SignalInput<Void>)
		case bookmarkButtonClicked(SignalInput<Void>)
		case cancelButtonClicked(SignalInput<Void>)
		case searchButtonClicked(SignalInput<String>)
		case resultsListButtonClicked(SignalInput<Void>)
		case selectedScopeButtonIndexDidChange(SignalInput<Int>)

		// 4. Delegate bindings require synchronous evaluation within the object's context.
		case shouldChangeText((NSRange, String) -> Bool)
		case shouldBeginEditing((UISearchBar) -> Bool)
		case shouldEndEditing((UISearchBar) -> Bool)
		case position((UIBarPositioning) -> UIBarPosition)
	}

	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = SearchBar
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }

		public init() {
			self.init(delegateClass: Delegate.self)
		}
		public init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		public let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}

		public mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .didChange(let x):
				let s = #selector(UISearchBarDelegate.searchBar(_:textDidChange:))
				delegate().addSelector(s).didChange = x
			case .didBeginEditing(let x):
				let s = #selector(UISearchBarDelegate.searchBarTextDidBeginEditing(_:))
				delegate().addSelector(s).didBeginEditing = x
			case .didEndEditing(let x):
				let s = #selector(UISearchBarDelegate.searchBarTextDidEndEditing(_:))
				delegate().addSelector(s).didEndEditing = x
			case .bookmarkButtonClicked(let x):
				let s = #selector(UISearchBarDelegate.searchBarBookmarkButtonClicked(_:))
				delegate().addSelector(s).bookmarkButtonClicked = x
			case .cancelButtonClicked(let x):
				let s = #selector(UISearchBarDelegate.searchBarCancelButtonClicked(_:))
				delegate().addSelector(s).cancelButtonClicked = x
			case .searchButtonClicked(let x):
				let s = #selector(UISearchBarDelegate.searchBarSearchButtonClicked(_:))
				delegate().addSelector(s).searchButtonClicked = x
			case .resultsListButtonClicked(let x):
				let s = #selector(UISearchBarDelegate.searchBarResultsListButtonClicked(_:))
				delegate().addSelector(s).resultsListButtonClicked = x
			case .selectedScopeButtonIndexDidChange(let x):
				let s = #selector(UISearchBarDelegate.searchBar(_:selectedScopeButtonIndexDidChange:))
				delegate().addSelector(s).selectedScopeButtonIndexDidChange = x
			case .shouldChangeText(let x):
				let s = #selector(UISearchBarDelegate.searchBar(_:shouldChangeTextIn:replacementText:))
				delegate().addSelector(s).shouldChangeText = x
			case .shouldBeginEditing(let x):
				let s = #selector(UISearchBarDelegate.searchBarShouldBeginEditing(_:))
				delegate().addSelector(s).shouldBeginEditing = x
			case .shouldEndEditing(let x):
				let s = #selector(UISearchBarDelegate.searchBarShouldEndEditing(_:))
				delegate().addSelector(s).shouldEndEditing = x
			case .position(let x):
				let s = #selector(UISearchBarDelegate.position(for:))
				delegate().addSelector(s).position = x
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}

		public mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
			storage.dynamicDelegate = possibleDelegate
			if storage.inUse {
				instance.delegate = storage
			}

			linkedPreparer.prepareInstance(instance, storage: storage)
		}

		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .textInputTraits(let x):
				return AggregateLifetime(lifetimes: x.value.bindings.lazy.compactMap { trait in
					switch trait {
					case .autocapitalizationType(let y): return y.apply(instance, storage) { i, s, v in i.autocapitalizationType = v }
					case .autocorrectionType(let y): return y.apply(instance, storage) { i, s, v in i.autocorrectionType = v }
					case .spellCheckingType(let y): return y.apply(instance, storage) { i, s, v in i.spellCheckingType = v }
					case .enablesReturnKeyAutomatically(let y): return y.apply(instance, storage) { i, s, v in i.enablesReturnKeyAutomatically = v }
					case .keyboardAppearance(let y): return y.apply(instance, storage) { i, s, v in i.keyboardAppearance = v }
					case .keyboardType(let y): return y.apply(instance, storage) { i, s, v in i.keyboardType = v }
					case .returnKeyType(let y): return y.apply(instance, storage) { i, s, v in i.returnKeyType = v }
					case .isSecureTextEntry(let y): return y.apply(instance, storage) { i, s, v in i.isSecureTextEntry = v }
					case .textContentType(let y):
						return y.apply(instance, storage) { i, s, v in
							if #available(iOS 10.0, *) {
								i.textContentType = v
							}
						}
					case .smartDashesType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartDashesType = v
							}
						}
					case .smartQuotesType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartQuotesType = v
							}
						}
					case .smartInsertDeleteType(let x):
						return x.apply(instance, storage) { i, s, v in
							if #available(iOS 11.0, *) {
								i.smartInsertDeleteType = v
							}
						}
					}
				})
			case .placeholder(let x): return x.apply(instance, storage) { i, s, v in i.placeholder = v }
			case .prompt(let x): return x.apply(instance, storage) { i, s, v in i.prompt = v }
			case .text(let x): return x.apply(instance, storage) { i, s, v in i.text = v }
			case .barStyle(let x): return x.apply(instance, storage) { i, s, v in i.barStyle = v }
			case .tintColor(let x): return x.apply(instance, storage) { i, s, v in i.tintColor = v }
			case .isTranslucent(let x): return x.apply(instance, storage) { i, s, v in i.isTranslucent = v }
			case .showsBookmarkButton(let x): return x.apply(instance, storage) { i, s, v in i.showsBookmarkButton = v }
			case .showsSearchResultsButton(let x): return x.apply(instance, storage) { i, s, v in i.showsSearchResultsButton = v }
			case .showCancelButton(let x): return x.apply(instance, storage) { i, s, v in i.setShowsCancelButton(v.value, animated: v.isAnimated) }
			case .scopeButtonTitles(let x): return x.apply(instance, storage) { i, s, v in i.scopeButtonTitles = v }
			case .selectedScopeButtonIndex(let x): return x.apply(instance, storage) { i, s, v in i.selectedScopeButtonIndex = v }
			case .showsScopeBar(let x): return x.apply(instance, storage) { i, s, v in i.showsScopeBar = v }
			case .inputAccessoryView(let x): return x.apply(instance, storage) { i, s, v in i.inputAccessoryView = v }
			case .searchFieldBackgroundPositionAdjustment(let x): return x.apply(instance, storage) { i, s, v in i.searchFieldBackgroundPositionAdjustment = v }
			case .searchTextPositionAdjustment(let x): return x.apply(instance, storage) { i, s, v in i.searchTextPositionAdjustment = v }
			
			case .backgroundImage(let x):
				var previous: ScopedValues<PositionAndMetrics, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for conditions in p.pairs {
							if conditions.value != nil {
								i.setBackgroundImage(nil, for: conditions.scope.barPosition, barMetrics: conditions.scope.barMetrics)
							}
						}
					}
					previous = v
					for conditions in v.pairs {
						if let image = conditions.value {
							i.setBackgroundImage(image, for: conditions.scope.barPosition, barMetrics: conditions.scope.barMetrics)
						}
					}
				}
			case .image(let x):
				var previous: ScopedValues<IconAndControlState, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for conditions in p.pairs {
							if conditions.value != nil {
								i.setImage(nil, for: conditions.scope.icon, state: conditions.scope.controlState)
							}
						}
					}
					previous = v
					for conditions in v.pairs {
						if let image = conditions.value {
							i.setImage(image, for: conditions.scope.icon, state: conditions.scope.controlState)
						}
					}
				}
			case .positionAdjustment(let x):
				var previous: ScopedValues<UISearchBar.Icon, UIOffset>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setPositionAdjustment(UIOffset(), for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setPositionAdjustment(c.1, for: c.0)
					}
				}
			case .scopeBarButtonBackgroundImage(let x):
				var previous: ScopedValues<UIControl.State, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setScopeBarButtonBackgroundImage(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setScopeBarButtonBackgroundImage(c.1, for: c.0)
					}
				}
			case .scopeBarButtonDividerImage(let x):
				var previous: ScopedValues<LeftRightControlState, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v -> Void in
					if let p = previous {
						for conditions in p.pairs {
							i.setScopeBarButtonDividerImage(nil, forLeftSegmentState: conditions.scope.left, rightSegmentState: conditions.scope.right)
						}
					}
					previous = v
					for conditions in v.pairs {
						i.setScopeBarButtonDividerImage(conditions.value, forLeftSegmentState: conditions.scope.left, rightSegmentState: conditions.scope.right)
					}
				}
			case .scopeBarButtonTitleTextAttributes(let x):
				var previous: ScopedValues<UIControl.State, [NSAttributedString.Key: Any]?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setScopeBarButtonTitleTextAttributes(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setScopeBarButtonTitleTextAttributes(c.1, for: c.0)
					}
				}
			case .searchFieldBackgroundImage(let x):
				var previous: ScopedValues<UIControl.State, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setScopeBarButtonBackgroundImage(nil, for: c.0)
						}
					}
					previous = v
					for c in v.pairs {
						i.setScopeBarButtonBackgroundImage(c.1, for: c.0)
					}
				}
			case .didChange: return nil
			case .didBeginEditing: return nil
			case .didEndEditing: return nil
			case .bookmarkButtonClicked: return nil
			case .cancelButtonClicked: return nil
			case .searchButtonClicked: return nil
			case .resultsListButtonClicked: return nil
			case .selectedScopeButtonIndexDidChange: return nil
			case .shouldChangeText: return nil
			case .shouldBeginEditing: return nil
			case .shouldEndEditing: return nil
			case .position: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}

	open class Storage: View.Storage, UISearchBarDelegate {}
	
	open class Delegate: DynamicDelegate, UISearchBarDelegate {
		public required override init() {
			super.init()
		}
		
		open var didChange: SignalInput<String>?
		open func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {
			didChange!.send(value: searchText)
		}
		
		open var didBeginEditing: SignalInput<Void>?
		open func searchBarTextDidBeginEditing(_ searchBar: UISearchBar) {
			didBeginEditing!.send(value: ())
		}
		
		open var didEndEditing: SignalInput<Void>?
		open func searchBarTextDidEndEditing(_ searchBar: UISearchBar) {
			didEndEditing!.send(value: ())
		}
		
		open var bookmarkButtonClicked: SignalInput<Void>?
		open func searchBarBookmarkButtonClicked(_ searchBar: UISearchBar) {
			bookmarkButtonClicked!.send(value: ())
		}
		
		open var cancelButtonClicked: SignalInput<Void>?
		open func searchBarCancelButtonClicked(_ searchBar: UISearchBar) {
			cancelButtonClicked!.send(value: ())
		}
		
		open var searchButtonClicked: SignalInput<String>?
		open func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {
			searchButtonClicked!.send(value: searchBar.text ?? "")
		}
		
		open var resultsListButtonClicked: SignalInput<Void>?
		open func searchBarResultsListButtonClicked(_ searchBar: UISearchBar) {
			resultsListButtonClicked!.send(value: ())
		}
		
		open var selectedScopeButtonIndexDidChange: SignalInput<Int>?
		open func searchBarSelectedScopeButtonIndexDidChange(_ searchBar: UISearchBar, selectedScopeButtonIndexDidChange selectedScope: Int) {
			selectedScopeButtonIndexDidChange!.send(value: selectedScope)
		}
		
		open var shouldBeginEditing: ((_ searchBar: UISearchBar) -> Bool)?
		open func searchBarShouldBeginEditing(_ searchBar: UISearchBar) -> Bool {
			return shouldBeginEditing!(searchBar)
		}
		
		open var shouldEndEditing: ((_ searchBar: UISearchBar) -> Bool)?
		open func searchBarShouldEndEditing(_ searchBar: UISearchBar) -> Bool {
			return shouldEndEditing!(searchBar)
		}
		
		open var shouldChangeText: ((_ range: NSRange, _ replacementString: String) -> Bool)?
		open func searchBar(_ searchBar: UISearchBar, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
			return shouldChangeText!(range, text)
		}
		
		open var position: ((UIBarPositioning) -> UIBarPosition)?
		open func position(for bar: UIBarPositioning) -> UIBarPosition {
			return position!(bar)
		}
	}
}

extension BindingName where Binding: SearchBarBinding {
	// You can easily convert the `Binding` cases to `BindingName` by copying them to here and using the following Xcode-style regex:
	// Find:    case ([^\(]+)\((.+)\)$
	// Replace: public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .searchBarBinding(SearchBar.Binding.$1(v)) }) }
	public static var textInputTraits: BindingName<Constant<TextInputTraits>, Binding> { return BindingName<Constant<TextInputTraits>, Binding>({ v in .searchBarBinding(SearchBar.Binding.textInputTraits(v)) }) }
	public static var placeholder: BindingName<Dynamic<String>, Binding> { return BindingName<Dynamic<String>, Binding>({ v in .searchBarBinding(SearchBar.Binding.placeholder(v)) }) }
	public static var prompt: BindingName<Dynamic<String>, Binding> { return BindingName<Dynamic<String>, Binding>({ v in .searchBarBinding(SearchBar.Binding.prompt(v)) }) }
	public static var text: BindingName<Dynamic<String>, Binding> { return BindingName<Dynamic<String>, Binding>({ v in .searchBarBinding(SearchBar.Binding.text(v)) }) }
	public static var barStyle: BindingName<Dynamic<UIBarStyle>, Binding> { return BindingName<Dynamic<UIBarStyle>, Binding>({ v in .searchBarBinding(SearchBar.Binding.barStyle(v)) }) }
	public static var tintColor: BindingName<Dynamic<UIColor>, Binding> { return BindingName<Dynamic<UIColor>, Binding>({ v in .searchBarBinding(SearchBar.Binding.tintColor(v)) }) }
	public static var isTranslucent: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .searchBarBinding(SearchBar.Binding.isTranslucent(v)) }) }
	public static var showsBookmarkButton: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .searchBarBinding(SearchBar.Binding.showsBookmarkButton(v)) }) }
	public static var showsSearchResultsButton: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .searchBarBinding(SearchBar.Binding.showsSearchResultsButton(v)) }) }
	public static var showCancelButton: BindingName<Dynamic<SetOrAnimate<Bool>>, Binding> { return BindingName<Dynamic<SetOrAnimate<Bool>>, Binding>({ v in .searchBarBinding(SearchBar.Binding.showCancelButton(v)) }) }
	public static var scopeButtonTitles: BindingName<Dynamic<[String]?>, Binding> { return BindingName<Dynamic<[String]?>, Binding>({ v in .searchBarBinding(SearchBar.Binding.scopeButtonTitles(v)) }) }
	public static var selectedScopeButtonIndex: BindingName<Dynamic<Int>, Binding> { return BindingName<Dynamic<Int>, Binding>({ v in .searchBarBinding(SearchBar.Binding.selectedScopeButtonIndex(v)) }) }
	public static var showsScopeBar: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .searchBarBinding(SearchBar.Binding.showsScopeBar(v)) }) }
	public static var backgroundImage: BindingName<Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<PositionAndMetrics, UIImage?>>, Binding>({ v in .searchBarBinding(SearchBar.Binding.backgroundImage(v)) }) }
	public static var image: BindingName<Dynamic<ScopedValues<IconAndControlState, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<IconAndControlState, UIImage?>>, Binding>({ v in .searchBarBinding(SearchBar.Binding.image(v)) }) }
	public static var positionAdjustment: BindingName<Dynamic<ScopedValues<UISearchBar.Icon, UIOffset>>, Binding> { return BindingName<Dynamic<ScopedValues<UISearchBar.Icon, UIOffset>>, Binding>({ v in .searchBarBinding(SearchBar.Binding.positionAdjustment(v)) }) }
	public static var inputAccessoryView: BindingName<Dynamic<UIView?>, Binding> { return BindingName<Dynamic<UIView?>, Binding>({ v in .searchBarBinding(SearchBar.Binding.inputAccessoryView(v)) }) }
	public static var scopeBarButtonBackgroundImage: BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding>({ v in .searchBarBinding(SearchBar.Binding.scopeBarButtonBackgroundImage(v)) }) }
	public static var scopeBarButtonDividerImage: BindingName<Dynamic<ScopedValues<LeftRightControlState, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<LeftRightControlState, UIImage?>>, Binding>({ v in .searchBarBinding(SearchBar.Binding.scopeBarButtonDividerImage(v)) }) }
	public static var scopeBarButtonTitleTextAttributes: BindingName<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, [NSAttributedString.Key: Any]?>>, Binding>({ v in .searchBarBinding(SearchBar.Binding.scopeBarButtonTitleTextAttributes(v)) }) }
	public static var searchFieldBackgroundImage: BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<UIControl.State, UIImage?>>, Binding>({ v in .searchBarBinding(SearchBar.Binding.searchFieldBackgroundImage(v)) }) }
	public static var searchFieldBackgroundPositionAdjustment: BindingName<Dynamic<UIOffset>, Binding> { return BindingName<Dynamic<UIOffset>, Binding>({ v in .searchBarBinding(SearchBar.Binding.searchFieldBackgroundPositionAdjustment(v)) }) }
	public static var searchTextPositionAdjustment: BindingName<Dynamic<UIOffset>, Binding> { return BindingName<Dynamic<UIOffset>, Binding>({ v in .searchBarBinding(SearchBar.Binding.searchTextPositionAdjustment(v)) }) }
	public static var didChange: BindingName<SignalInput<String>, Binding> { return BindingName<SignalInput<String>, Binding>({ v in .searchBarBinding(SearchBar.Binding.didChange(v)) }) }
	public static var didBeginEditing: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .searchBarBinding(SearchBar.Binding.didBeginEditing(v)) }) }
	public static var didEndEditing: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .searchBarBinding(SearchBar.Binding.didEndEditing(v)) }) }
	public static var bookmarkButtonClicked: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .searchBarBinding(SearchBar.Binding.bookmarkButtonClicked(v)) }) }
	public static var cancelButtonClicked: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .searchBarBinding(SearchBar.Binding.cancelButtonClicked(v)) }) }
	public static var searchButtonClicked: BindingName<SignalInput<String>, Binding> { return BindingName<SignalInput<String>, Binding>({ v in .searchBarBinding(SearchBar.Binding.searchButtonClicked(v)) }) }
	public static var resultsListButtonClicked: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .searchBarBinding(SearchBar.Binding.resultsListButtonClicked(v)) }) }
	public static var selectedScopeButtonIndexDidChange: BindingName<SignalInput<Int>, Binding> { return BindingName<SignalInput<Int>, Binding>({ v in .searchBarBinding(SearchBar.Binding.selectedScopeButtonIndexDidChange(v)) }) }
	public static var shouldChangeText: BindingName<(NSRange, String) -> Bool, Binding> { return BindingName<(NSRange, String) -> Bool, Binding>({ v in .searchBarBinding(SearchBar.Binding.shouldChangeText(v)) }) }
	public static var shouldBeginEditing: BindingName<(UISearchBar) -> Bool, Binding> { return BindingName<(UISearchBar) -> Bool, Binding>({ v in .searchBarBinding(SearchBar.Binding.shouldBeginEditing(v)) }) }
	public static var shouldEndEditing: BindingName<(UISearchBar) -> Bool, Binding> { return BindingName<(UISearchBar) -> Bool, Binding>({ v in .searchBarBinding(SearchBar.Binding.shouldEndEditing(v)) }) }
	public static var position: BindingName<(UIBarPositioning) -> UIBarPosition, Binding> { return BindingName<(UIBarPositioning) -> UIBarPosition, Binding>({ v in .searchBarBinding(SearchBar.Binding.position(v)) }) }
}

public protocol SearchBarConvertible: ViewConvertible {
	func uiSearchBar() -> SearchBar.Instance
}
extension SearchBarConvertible {
	public func uiView() -> View.Instance { return uiSearchBar() }
}
extension SearchBar.Instance: SearchBarConvertible {
	public func uiSearchBar() -> SearchBar.Instance { return self }
}

public protocol SearchBarBinding: ViewBinding {
	static func searchBarBinding(_ binding: SearchBar.Binding) -> Self
}
extension SearchBarBinding {
	public static func viewBinding(_ binding: View.Binding) -> Self {
		return searchBarBinding(.inheritedBinding(binding))
	}
}

public struct LeftRightControlState {
	public let left: UIControl.State
	public let right: UIControl.State
	public init(left: UIControl.State = .normal, right: UIControl.State = .normal) {
		self.left = left
		self.right = right
	}
}

public struct IconAndControlState {
	public let icon: UISearchBar.Icon
	public let controlState: UIControl.State
	public init(icon: UISearchBar.Icon = .search, state: UIControl.State = .normal) {
		self.icon = icon
		self.controlState = state
	}
}

extension ScopedValues where Scope == LeftRightControlState {
	public static func normal(right: UIControl.State = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .normal, right: right))
	}
	public static func highlighted(right: UIControl.State = .highlighted, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .highlighted, right: right))
	}
	public static func disabled(right: UIControl.State = .disabled, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .disabled, right: right))
	}
	public static func selected(right: UIControl.State = .selected, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .selected, right: right))
	}
	@available(iOS 9.0, *)
	public static func focused(right: UIControl.State = .focused, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .focused, right: right))
	}
	public static func application(right: UIControl.State = .application, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .application, right: right))
	}
	public static func reserved(right: UIControl.State = .reserved, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: LeftRightControlState(left: .reserved, right: right))
	}
}

extension ScopedValues where Scope == IconAndControlState {
	public static func search(state: UIControl.State = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: IconAndControlState(icon: .search, state: state))
	}
	public static func clear(state: UIControl.State = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: IconAndControlState(icon: .clear, state: state))
	}
	public static func bookmark(state: UIControl.State = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: IconAndControlState(icon: .bookmark, state: state))
	}
	public static func resultsList(state: UIControl.State = .normal, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: IconAndControlState(icon: .resultsList, state: state))
	}
}

extension ScopedValues where Scope == UISearchBar.Icon {
	public static func search(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .search)
	}
	public static func clear(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .clear)
	}
	public static func bookmark(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .bookmark)
	}
	public static func resultsList(_ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: .resultsList)
	}
}

public class ScreenEdgePanGestureRecognizer: ConstructingBinder, ScreenEdgePanGestureRecognizerConvertible {
	public typealias Instance = UIScreenEdgePanGestureRecognizer
	public typealias Inherited = GestureRecognizer
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiScreenEdgePanGestureRecognizer() -> Instance { return instance() }
	
	public enum Binding: ScreenEdgePanGestureRecognizerBinding {
		public typealias EnclosingBinder = ScreenEdgePanGestureRecognizer
		public static func screenEdgePanGestureRecognizerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case edges(Dynamic<UIRectEdge>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
		
		public struct Name<Value> {
			// You can easily convert the `Binding` cases to `Binding.Name` using the following Xcode-style regex:
			// Replace: case ([^\(]+)\((.+)\)$
			// With:    public static var $1: Name<$2> { return Name<$2>(Binding.$1) }
			public static var edges: Name<Dynamic<UIRectEdge>> { return Name<Dynamic<UIRectEdge>>(Binding.edges) }
			
			let constructor: (Value) -> Binding
			init(_ constructor: @escaping (Value) -> Binding) {
				self.constructor = constructor
			}
		}
	}
	
	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = ScreenEdgePanGestureRecognizer
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		public init() {}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .edges(let x): return x.apply(instance, storage) { i, s, v in i.edges = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	public typealias Storage = GestureRecognizer.Storage
}

extension BindingName where Binding: ScreenEdgePanGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .screenEdgePanGestureRecognizerBinding(ScreenEdgePanGestureRecognizer.Binding.$1(v)) }) }
	public static var edges: BindingName<Dynamic<UIRectEdge>, Binding> { return BindingName<Dynamic<UIRectEdge>, Binding>({ v in .screenEdgePanGestureRecognizerBinding(ScreenEdgePanGestureRecognizer.Binding.edges(v)) }) }
}

public protocol ScreenEdgePanGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiScreenEdgePanGestureRecognizer() -> ScreenEdgePanGestureRecognizer.Instance
}
extension ScreenEdgePanGestureRecognizerConvertible {
	public func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiScreenEdgePanGestureRecognizer() }
}
extension ScreenEdgePanGestureRecognizer.Instance: ScreenEdgePanGestureRecognizerConvertible {
	public func uiScreenEdgePanGestureRecognizer() -> ScreenEdgePanGestureRecognizer.Instance { return self }
}

public protocol ScreenEdgePanGestureRecognizerBinding: GestureRecognizerBinding {
	static func screenEdgePanGestureRecognizerBinding(_ binding: ScreenEdgePanGestureRecognizer.Binding) -> Self
}
extension ScreenEdgePanGestureRecognizerBinding {
	public static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return screenEdgePanGestureRecognizerBinding(.inheritedBinding(binding))
	}
}

public class RotationGestureRecognizer: ConstructingBinder, RotationGestureRecognizerConvertible {
	public typealias Instance = UIRotationGestureRecognizer
	public typealias Inherited = GestureRecognizer
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiRotationGestureRecognizer() -> Instance { return instance() }
	
	public enum Binding: RotationGestureRecognizerBinding {
		public typealias EnclosingBinder = RotationGestureRecognizer
		public static func rotationGestureRecognizerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case rotation(Dynamic<CGFloat>)
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = RotationGestureRecognizer
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		public init() {}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .rotation(let x): return x.apply(instance, storage) { i, s, v in i.rotation = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	public typealias Storage = GestureRecognizer.Storage
}

extension BindingName where Binding: RotationGestureRecognizerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .rotationGestureRecognizerBinding(RotationGestureRecognizer.Binding.$1(v)) }) }
	public static var rotation: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .rotationGestureRecognizerBinding(RotationGestureRecognizer.Binding.rotation(v)) }) }
}

public protocol RotationGestureRecognizerConvertible: GestureRecognizerConvertible {
	func uiRotationGestureRecognizer() -> RotationGestureRecognizer.Instance
}
extension RotationGestureRecognizerConvertible {
	public func uiGestureRecognizer() -> GestureRecognizer.Instance { return uiRotationGestureRecognizer() }
}
extension RotationGestureRecognizer.Instance: RotationGestureRecognizerConvertible {
	public func uiRotationGestureRecognizer() -> RotationGestureRecognizer.Instance { return self }
}

public protocol RotationGestureRecognizerBinding: GestureRecognizerBinding {
	static func rotationGestureRecognizerBinding(_ binding: RotationGestureRecognizer.Binding) -> Self
}
extension RotationGestureRecognizerBinding {
	public static func gestureRecognizerBinding(_ binding: GestureRecognizer.Binding) -> Self {
		return rotationGestureRecognizerBinding(.inheritedBinding(binding))
	}
}

public class BarButtonItem: ConstructingBinder, BarButtonItemConvertible {
	public typealias Instance = UIBarButtonItem
	public typealias Inherited = BarItem
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiBarButtonItem() -> Instance { return instance() }
	
	public enum Binding: BarButtonItemBinding {
		public typealias EnclosingBinder = BarButtonItem
		public static func barButtonItemBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case barButtonSystemItem(Constant<UIBarButtonItem.SystemItem>)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case itemStyle(Dynamic<UIBarButtonItem.Style>)
		case possibleTitles(Dynamic<Set<String>?>)
		case width(Dynamic<CGFloat>)
		case customView(Dynamic<ViewConvertible?>)
		case tintColor(Dynamic<UIColor?>)
		case backgroundImage(Dynamic<ScopedValues<StateStyleAndMetrics, UIImage?>>)
		case backButtonBackgroundImage(Dynamic<ScopedValues<StateAndMetrics, UIImage?>>)
		case backButtonTitlePositionAdjustment(Dynamic<ScopedValues<UIBarMetrics, UIOffset>>)
		case backgroundVerticalPositionAdjustment(Dynamic<ScopedValues<UIBarMetrics, CGFloat>>)
		case titlePositionAdjustment(Dynamic<ScopedValues<UIBarMetrics, UIOffset>>)
		
		//	2. Signal bindings are performed on the object after construction.
		
		//	3. Action bindings are triggered by the object after construction.
		case action(TargetAction)
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = BarButtonItem
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance {
			let x: UIBarButtonItem
			if let si = systemItem {
				x = subclass.init(barButtonSystemItem: si, target: nil, action: nil)
			} else if case .some(.some(let cv)) = customViewInitial {
				x = subclass.init(customView: cv.uiView())
			} else if case .some(.some(let i)) = imageInitial {
				x = subclass.init(image: i, landscapeImagePhone: landscapeImagePhoneInitial ?? nil, style: itemStyleInitial ?? .plain, target: nil, action: nil)
			} else {
				x = subclass.init(title: titleInitial ?? nil, style: itemStyleInitial ?? .plain, target: nil, action: nil)
			}
			return x
		}
		
		public var systemItem: UIBarButtonItem.SystemItem?
		public var customView = InitialSubsequent<ViewConvertible?>()
		public var customViewInitial: ViewConvertible?? = nil
		public var itemStyle = InitialSubsequent<UIBarButtonItem.Style>()
		public var itemStyleInitial: UIBarButtonItem.Style? = nil
		public var image = InitialSubsequent<UIImage?>()
		public var imageInitial: UIImage?? = nil
		public var landscapeImagePhone = InitialSubsequent<UIImage?>()
		public var landscapeImagePhoneInitial: UIImage?? = nil
		public var title = InitialSubsequent<String>()
		public var titleInitial: String? = nil
		
		public init() {}
		
		public mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .barButtonSystemItem(let x): systemItem = x.value
			case .customView(let x):
				customView = x.initialSubsequent()
				customViewInitial = customView.initial()
			case .itemStyle(let x):
				itemStyle = x.initialSubsequent()
				itemStyleInitial = itemStyle.initial()
			case .inheritedBinding(.image(let x)):
				image = x.initialSubsequent()
				imageInitial = image.initial()
			case .inheritedBinding(.landscapeImagePhone(let x)):
				landscapeImagePhone = x.initialSubsequent()
				landscapeImagePhoneInitial = landscapeImagePhone.initial()
			case .inheritedBinding(.title(let x)):
				title = x.initialSubsequent()
				titleInitial = title.initial()
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .barButtonSystemItem: return nil
			case .backgroundImage(let x):
				var previous: ScopedValues<StateStyleAndMetrics, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for conditions in p.pairs {
							if conditions.value != nil {
								i.setBackgroundImage(nil, for: conditions.scope.controlState, style: conditions.scope.itemStyle, barMetrics: conditions.scope.barMetrics)
							}
						}
					}
					previous = v
					for conditions in v.pairs {
						if let image = conditions.value {
							i.setBackgroundImage(image, for: conditions.scope.controlState, style: conditions.scope.itemStyle, barMetrics: conditions.scope.barMetrics)
						}
					}
				}
			case .backButtonBackgroundImage(let x):
				var previous: ScopedValues<StateAndMetrics, UIImage?>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for conditions in p.pairs {
							if conditions.value != nil {
								i.setBackButtonBackgroundImage(nil, for: conditions.scope.controlState, barMetrics: conditions.scope.barMetrics)
							}
						}
					}
					previous = v
					for conditions in v.pairs {
						if let image = conditions.value {
							i.setBackButtonBackgroundImage(image, for: conditions.scope.controlState, barMetrics: conditions.scope.barMetrics)
						}
					}
				}
			case .backButtonTitlePositionAdjustment(let x):
				var previous: ScopedValues<UIBarMetrics, UIOffset>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setBackButtonTitlePositionAdjustment(UIOffset(), for: c.scope)
						}
					}
					previous = v
					for c in v.pairs {
						i.setBackButtonTitlePositionAdjustment(c.value, for: c.scope)
					}
				}
			case .backgroundVerticalPositionAdjustment(let x):
				var previous: ScopedValues<UIBarMetrics, CGFloat>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setBackgroundVerticalPositionAdjustment(0, for: c.scope)
						}
					}
					previous = v
					for c in v.pairs {
						i.setBackgroundVerticalPositionAdjustment(c.value, for: c.scope)
					}
				}
			case .titlePositionAdjustment(let x):
				var previous: ScopedValues<UIBarMetrics, UIOffset>? = nil
				return x.apply(instance, storage) { i, s, v in
					if let p = previous {
						for c in p.pairs {
							i.setTitlePositionAdjustment(UIOffset(), for: c.scope)
						}
					}
					previous = v
					for c in v.pairs {
						i.setTitlePositionAdjustment(c.value, for: c.scope)
					}
				}
			case .itemStyle:
				return itemStyle.subsequent.flatMap { $0.apply(instance, storage) { i, s, v in i.style = v } }
			case .possibleTitles(let x): return x.apply(instance, storage) { i, s, v in i.possibleTitles = v }
			case .width(let x): return x.apply(instance, storage) { i, s, v in i.width = v }
			case .customView:
				return customView.subsequent.flatMap { $0.apply(instance, storage) { i, s, v in i.customView = v?.uiView() } }
			case .tintColor(let x): return x.apply(instance, storage) { i, s, v in i.tintColor = v }
			case .action(let x): return x.apply(instance: instance, constructTarget: SignalActionTarget.init, processor: { sender in () })
				
			case .inheritedBinding(.image): return image.subsequent.flatMap { $0.apply(instance, storage) { i, s, v in i.image = v } }
			case .inheritedBinding(.landscapeImagePhone): return landscapeImagePhone.subsequent.flatMap { $0.apply(instance, storage) { i, s, v in i.landscapeImagePhone = v } }
			case .inheritedBinding(.title): return title.subsequent.flatMap { $0.apply(instance, storage) { i, s, v in i.title = v } }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}
	
	public typealias Storage = BarItem.Storage
}

extension BindingName where Binding: BarButtonItemBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.$1(v)) }) }
	public static var barButtonSystemItem: BindingName<Constant<UIBarButtonItem.SystemItem>, Binding> { return BindingName<Constant<UIBarButtonItem.SystemItem>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.barButtonSystemItem(v)) }) }
	public static var itemStyle: BindingName<Dynamic<UIBarButtonItem.Style>, Binding> { return BindingName<Dynamic<UIBarButtonItem.Style>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.itemStyle(v)) }) }
	public static var possibleTitles: BindingName<Dynamic<Set<String>?>, Binding> { return BindingName<Dynamic<Set<String>?>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.possibleTitles(v)) }) }
	public static var width: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.width(v)) }) }
	public static var customView: BindingName<Dynamic<ViewConvertible?>, Binding> { return BindingName<Dynamic<ViewConvertible?>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.customView(v)) }) }
	public static var tintColor: BindingName<Dynamic<UIColor?>, Binding> { return BindingName<Dynamic<UIColor?>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.tintColor(v)) }) }
	public static var backgroundImage: BindingName<Dynamic<ScopedValues<StateStyleAndMetrics, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<StateStyleAndMetrics, UIImage?>>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.backgroundImage(v)) }) }
	public static var backButtonBackgroundImage: BindingName<Dynamic<ScopedValues<StateAndMetrics, UIImage?>>, Binding> { return BindingName<Dynamic<ScopedValues<StateAndMetrics, UIImage?>>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.backButtonBackgroundImage(v)) }) }
	public static var backButtonTitlePositionAdjustment: BindingName<Dynamic<ScopedValues<UIBarMetrics, UIOffset>>, Binding> { return BindingName<Dynamic<ScopedValues<UIBarMetrics, UIOffset>>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.backButtonTitlePositionAdjustment(v)) }) }
	public static var backgroundVerticalPositionAdjustment: BindingName<Dynamic<ScopedValues<UIBarMetrics, CGFloat>>, Binding> { return BindingName<Dynamic<ScopedValues<UIBarMetrics, CGFloat>>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.backgroundVerticalPositionAdjustment(v)) }) }
	public static var titlePositionAdjustment: BindingName<Dynamic<ScopedValues<UIBarMetrics, UIOffset>>, Binding> { return BindingName<Dynamic<ScopedValues<UIBarMetrics, UIOffset>>, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.titlePositionAdjustment(v)) }) }
	public static var action: BindingName<TargetAction, Binding> { return BindingName<TargetAction, Binding>({ v in .barButtonItemBinding(BarButtonItem.Binding.action(v)) }) }
}

extension BindingName where Binding: BarButtonItemBinding, Binding.EnclosingBinder: BinderChain {
	public static func action<I: SignalInputInterface, Value>(_ keyPath: KeyPath<Binding.EnclosingBinder.Instance, Value>) -> BindingName<I, Binding> where I.InputValue == Value {
		return BindingName<I, Binding> { (v: I) -> Binding in
			Binding.barButtonItemBinding(
				BarButtonItem.Binding.action(
					TargetAction.singleTarget(
						Input<Any?>()
							.map { i -> Value in
								(i as! Binding.EnclosingBinder.Instance)[keyPath: keyPath]
							}
							.bind(to: v.input)
					)
				)
			)
		}
	}
}

public protocol BarButtonItemConvertible: BarItemConvertible {
	func uiBarButtonItem() -> BarButtonItem.Instance
}
extension BarButtonItemConvertible {
	public func uiBarItem() -> BarItem.Instance { return uiBarButtonItem() }
}
extension BarButtonItem.Instance: BarButtonItemConvertible {
	public func uiBarButtonItem() -> BarButtonItem.Instance { return self }
}

public protocol BarButtonItemBinding: BarItemBinding {
	static func barButtonItemBinding(_ binding: BarButtonItem.Binding) -> Self
}
extension BarButtonItemBinding {
	public static func barItemBinding(_ binding: BarItem.Binding) -> Self {
		return barButtonItemBinding(.inheritedBinding(binding))
	}
}

extension UIBarButtonItem: TargetActionSender {}

public struct StateStyleAndMetrics {
	public let controlState: UIControl.State
	public let itemStyle: UIBarButtonItem.Style
	public let barMetrics: UIBarMetrics
	public init(state: UIControl.State = .normal, style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default) {
		self.controlState = state
		self.itemStyle = style
		self.barMetrics = metrics
	}
}

public struct StateAndMetrics {
	public let controlState: UIControl.State
	public let barMetrics: UIBarMetrics
	public init(state: UIControl.State = .normal, metrics: UIBarMetrics = .default) {
		self.controlState = state
		self.barMetrics = metrics
	}
}

extension ScopedValues where Scope == StateAndMetrics {
	public static func normal(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .normal, metrics: metrics))
	}
	public static func highlighted(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .highlighted, metrics: metrics))
	}
	public static func disabled(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .disabled, metrics: metrics))
	}
	public static func selected(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .selected, metrics: metrics))
	}
	@available(iOS 9.0, *)
	public static func focused(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .focused, metrics: metrics))
	}
	public static func application(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .application, metrics: metrics))
	}
	public static func reserved(metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateAndMetrics(state: .reserved, metrics: metrics))
	}
}

extension ScopedValues where Scope == StateStyleAndMetrics {
	public static func normal(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .normal, metrics: metrics))
	}
	public static func highlighted(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .highlighted, metrics: metrics))
	}
	public static func disabled(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .disabled, metrics: metrics))
	}
	public static func selected(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .selected, metrics: metrics))
	}
	@available(iOS 9.0, *)
	public static func focused(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .focused, metrics: metrics))
	}
	public static func application(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .application, metrics: metrics))
	}
	public static func reserved(style: UIBarButtonItem.Style = .plain, metrics: UIBarMetrics = .default, _ value: Value) -> ScopedValues<Scope, Value> {
		return .value(value, for: StateStyleAndMetrics(state: .reserved, metrics: metrics))
	}
}

extension ScopedValues where Scope == UIBarMetrics {
	public static func `default`(_ value: Value) -> ScopedValues<Scope, Value> {
		return ScopedValues<Scope, Value>(scope: .default, value: value)
	}
	public static func compact(_ value: Value) -> ScopedValues<Scope, Value> {
		return ScopedValues<Scope, Value>(scope: .compact, value: value)
	}
	public static func defaultPrompt(_ value: Value) -> ScopedValues<Scope, Value> {
		return ScopedValues<Scope, Value>(scope: .defaultPrompt, value: value)
	}
	public static func compactPrompt(_ value: Value) -> ScopedValues<Scope, Value> {
		return ScopedValues<Scope, Value>(scope: .compactPrompt, value: value)
	}
}


import QuartzCore

public class BackingLayer: Binder {
	public typealias Instance = CALayer
	public typealias Inherited = BaseBinder

	public var state: BinderState<Instance, BindingsOnlyParameters<Binding>>
	public required init(state: BinderState<Instance, BindingsOnlyParameters<Binding>>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	
	public enum Binding: BackingLayerBinding {
		public typealias EnclosingBinder = BackingLayer
		public static func backingLayerBinding(_ binding: BackingLayer.Binding) -> BackingLayer.Binding { return binding }
		
		case inheritedBinding(Inherited.Binding)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case affineTransform(Dynamic<CGAffineTransform>)
		case anchorPoint(Dynamic<CGPoint>)
		case anchorPointZ(Dynamic<CGFloat>)
		case actions(Dynamic<[String: SignalInput<[AnyHashable: Any]?>?]>)
		case backgroundColor(Dynamic<CGColor?>)
		case borderColor(Dynamic<CGColor?>)
		case borderWidth(Dynamic<CGFloat>)
		case bounds(Dynamic<CGRect>)
		case contents(Dynamic<Any?>)
		case contentsCenter(Dynamic<CGRect>)
		case contentsGravity(Dynamic<CALayerContentsGravity>)
		case contentsRect(Dynamic<CGRect>)
		case contentsScale(Dynamic<CGFloat>)
		case cornerRadius(Dynamic<CGFloat>)
		case isDoubleSided(Dynamic<Bool>)
		case drawsAsynchronously(Dynamic<Bool>)
		case edgeAntialiasingMask(Dynamic<CAEdgeAntialiasingMask>)
		case frame(Dynamic<CGRect>)
		case isGeometryFlipped(Dynamic<Bool>)
		case isHidden(Dynamic<Bool>)
		case magnificationFilter(Dynamic<CALayerContentsFilter>)
		case masksToBounds(Dynamic<Bool>)
		case minificationFilter(Dynamic<CALayerContentsFilter>)
		case minificationFilterBias(Dynamic<Float>)
		case name(Dynamic<String>)
		case needsDisplayOnBoundsChange(Dynamic<Bool>)
		case opacity(Dynamic<Float>)
		case isOpaque(Dynamic<Bool>)
		case position(Dynamic<CGPoint>)
		case rasterizationScale(Dynamic<CGFloat>)
		case shadowColor(Dynamic<CGColor?>)
		case shadowOffset(Dynamic<CGSize>)
		case shadowOpacity(Dynamic<Float>)
		case shadowPath(Dynamic<CGPath?>)
		case shadowRadius(Dynamic<CGFloat>)
		case shouldRasterize(Dynamic<Bool>)
		case style(Dynamic<[AnyHashable: Any]>)
		case sublayerTransform(Dynamic<CATransform3D>)
		case transform(Dynamic<CATransform3D>)
		case zPosition(Dynamic<CGFloat>)
		case mask(Dynamic<LayerConvertible?>)
		case sublayers(Dynamic<[LayerConvertible]>)
		
		#if os(macOS)
			case autoresizingMask(Dynamic<CAAutoresizingMask>)
			case backgroundFilters(Dynamic<[CIFilter]?>)
			case compositingFilter(Dynamic<CIFilter?>)
			case filters(Dynamic<[CIFilter]?>)
		#else
			@available(*, unavailable)
			case autoresizingMask(())
			@available(*, unavailable)
			case backgroundFilters(())
			@available(*, unavailable)
			case compositingFilter(())
			@available(*, unavailable)
			case filters(())
		#endif
		
		//	2. Signal bindings are performed on the object after construction.
		case addAnimation(Signal<AnimationForKey>)
		case needsDisplay(Signal<Void>)
		case needsDisplayInRect(Signal<CGRect>)
		case removeAllAnimations(Signal<String>)
		case removeAnimationForKey(Signal<String>)
		case scrollRectToVisible(Signal<CGRect>)
		
		//	3. Action bindings are triggered by the object after construction.
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
	}
	
	public struct Preparer: StoragePreparer {
		public typealias EnclosingBinder = BackingLayer
		public var linkedPreparer = EnclosingBinder.Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		
		public init() {}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .autoresizingMask(let x):
				#if os(macOS)
					return x.apply(instance, storage) { i, s, v in i.autoresizingMask = v }
				#else
					return nil
				#endif
			case .backgroundFilters(let x):
				#if os(macOS)
					return x.apply(instance, storage) { i, s, v in i.backgroundFilters = v }
				#else
					return nil
				#endif
			case .compositingFilter(let x):
				#if os(macOS)
					return x.apply(instance, storage) { i, s, v in i.compositingFilter = v }
				#else
					return nil
				#endif
			case .filters(let x):
				#if os(macOS)
					return x.apply(instance, storage) { i, s, v in i.filters = v }
				#else
					return nil
				#endif
			case .sublayers(let x):
				return x.apply(instance, storage) { i, s, v in
					i.sublayers = v.map { $0.cgLayer }
				}
			case .affineTransform(let x): return x.apply(instance, storage) { i, s, v in i.setAffineTransform(v) }
			case .anchorPoint(let x): return x.apply(instance, storage) { i, s, v in i.anchorPoint = v }
			case .anchorPointZ(let x): return x.apply(instance, storage) { i, s, v in i.anchorPointZ = v }
			case .backgroundColor(let x): return x.apply(instance, storage) { i, s, v in i.backgroundColor = v }
			case .borderColor(let x): return x.apply(instance, storage) { i, s, v in i.borderColor = v }
			case .borderWidth(let x): return x.apply(instance, storage) { i, s, v in i.borderWidth = v }
			case .bounds(let x): return x.apply(instance, storage) { i, s, v in i.bounds = v }
			case .contents(let x): return x.apply(instance, storage) { i, s, v in i.contents = v }
			case .contentsCenter(let x): return x.apply(instance, storage) { i, s, v in i.contentsCenter = v }
			case .contentsGravity(let x): return x.apply(instance, storage) { i, s, v in i.contentsGravity = v }
			case .contentsRect(let x): return x.apply(instance, storage) { i, s, v in i.contentsRect = v }
			case .contentsScale(let x): return x.apply(instance, storage) { i, s, v in i.contentsScale = v }
			case .cornerRadius(let x): return x.apply(instance, storage) { i, s, v in i.cornerRadius = v }
			case .isDoubleSided(let x): return x.apply(instance, storage) { i, s, v in i.isDoubleSided = v }
			case .drawsAsynchronously(let x): return x.apply(instance, storage) { i, s, v in i.drawsAsynchronously = v }
			case .edgeAntialiasingMask(let x): return x.apply(instance, storage) { i, s, v in i.edgeAntialiasingMask = v }
			case .frame(let x): return x.apply(instance, storage) { i, s, v in i.frame = v }
			case .isGeometryFlipped(let x): return x.apply(instance, storage) { i, s, v in i.isGeometryFlipped = v }
			case .isHidden(let x): return x.apply(instance, storage) { i, s, v in i.isHidden = v }
			case .magnificationFilter(let x): return x.apply(instance, storage) { i, s, v in i.magnificationFilter = v }
			case .masksToBounds(let x): return x.apply(instance, storage) { i, s, v in i.masksToBounds = v }
			case .minificationFilter(let x): return x.apply(instance, storage) { i, s, v in i.minificationFilter = v }
			case .minificationFilterBias(let x): return x.apply(instance, storage) { i, s, v in i.minificationFilterBias = v }
			case .name(let x): return x.apply(instance, storage) { i, s, v in i.name = v }
			case .needsDisplayOnBoundsChange(let x): return x.apply(instance, storage) { i, s, v in i.needsDisplayOnBoundsChange = v }
			case .opacity(let x): return x.apply(instance, storage) { i, s, v in i.opacity = v }
			case .isOpaque(let x): return x.apply(instance, storage) { i, s, v in i.isOpaque = v }
			case .position(let x): return x.apply(instance, storage) { i, s, v in i.position = v }
			case .rasterizationScale(let x): return x.apply(instance, storage) { i, s, v in i.rasterizationScale = v }
			case .shadowColor(let x): return x.apply(instance, storage) { i, s, v in i.shadowColor = v }
			case .shadowOffset(let x): return x.apply(instance, storage) { i, s, v in i.shadowOffset = v }
			case .shadowOpacity(let x): return x.apply(instance, storage) { i, s, v in i.shadowOpacity = v }
			case .shadowPath(let x): return x.apply(instance, storage) { i, s, v in i.shadowPath = v }
			case .shadowRadius(let x): return x.apply(instance, storage) { i, s, v in i.shadowRadius = v }
			case .shouldRasterize(let x): return x.apply(instance, storage) { i, s, v in i.shouldRasterize = v }
			case .style(let x): return x.apply(instance, storage) { i, s, v in i.style = v }
			case .sublayerTransform(let x): return x.apply(instance, storage) { i, s, v in i.sublayerTransform = v }
			case .transform(let x): return x.apply(instance, storage) { i, s, v in i.transform = v }
			case .zPosition(let x): return x.apply(instance, storage) { i, s, v in i.zPosition = v }
			case .addAnimation(let x): return x.apply(instance, storage) { i, s, v in i.add(v.animation, forKey: v.key) }
			case .needsDisplay(let x): return x.apply(instance, storage) { i, s, v in i.setNeedsDisplay() }
			case .needsDisplayInRect(let x): return x.apply(instance, storage) { i, s, v in i.setNeedsDisplay(v) }
			case .removeAllAnimations(let x): return x.apply(instance, storage) { i, s, v in i.removeAllAnimations() }
			case .removeAnimationForKey(let x): return x.apply(instance, storage) { i, s, v in i.removeAnimation(forKey: v) }
			case .scrollRectToVisible(let x): return x.apply(instance, storage) { i, s, v in i.scrollRectToVisible(v) }
			case .actions(let x):
				return x.apply(instance, storage) { i, s, v in
					var actions = i.actions ?? [String: CAAction]()
					for (key, input) in v {
						if let i = input {
							actions[key] = storage
							storage.layerActions[key] = i
						} else {
							actions[key] = NSNull()
							storage.layerActions.removeValue(forKey: key)
						}
					}
					i.actions = actions
				}
			case .mask(let x):
				return x.apply(instance, storage) { i, s, v in
					i.mask = v?.cgLayer
				}
			case .inheritedBinding(let s):
				return linkedPreparer.applyBinding(s, instance: (), storage: ())
			}
		}
	}
	
	open class Storage: ObjectBinderStorage, CAAction {
		open override var inUse: Bool {
			return super.inUse || !layerActions.isEmpty
		}
		
		// LayerBinderStorage implementation
		open var layerActions = [String: SignalInput<[AnyHashable: Any]?>]()
		@objc open func run(forKey event: String, object anObject: Any, arguments dict: [AnyHashable: Any]?) {
			_ = layerActions[event]?.send(value: dict)
		}
	}
}

extension BindingName where Binding: BackingLayerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.$1(v)) }) }
	public static var affineTransform: BindingName<Dynamic<CGAffineTransform>, Binding> { return BindingName<Dynamic<CGAffineTransform>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.affineTransform(v)) }) }
	public static var anchorPoint: BindingName<Dynamic<CGPoint>, Binding> { return BindingName<Dynamic<CGPoint>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.anchorPoint(v)) }) }
	public static var anchorPointZ: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.anchorPointZ(v)) }) }
	public static var actions: BindingName<Dynamic<[String: SignalInput<[AnyHashable: Any]?>?]>, Binding> { return BindingName<Dynamic<[String: SignalInput<[AnyHashable: Any]?>?]>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.actions(v)) }) }
	public static var backgroundColor: BindingName<Dynamic<CGColor?>, Binding> { return BindingName<Dynamic<CGColor?>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.backgroundColor(v)) }) }
	public static var borderColor: BindingName<Dynamic<CGColor?>, Binding> { return BindingName<Dynamic<CGColor?>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.borderColor(v)) }) }
	public static var borderWidth: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.borderWidth(v)) }) }
	public static var bounds: BindingName<Dynamic<CGRect>, Binding> { return BindingName<Dynamic<CGRect>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.bounds(v)) }) }
	public static var contents: BindingName<Dynamic<Any?>, Binding> { return BindingName<Dynamic<Any?>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.contents(v)) }) }
	public static var contentsCenter: BindingName<Dynamic<CGRect>, Binding> { return BindingName<Dynamic<CGRect>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.contentsCenter(v)) }) }
	public static var contentsGravity: BindingName<Dynamic<CALayerContentsGravity>, Binding> { return BindingName<Dynamic<CALayerContentsGravity>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.contentsGravity(v)) }) }
	public static var contentsRect: BindingName<Dynamic<CGRect>, Binding> { return BindingName<Dynamic<CGRect>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.contentsRect(v)) }) }
	public static var contentsScale: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.contentsScale(v)) }) }
	public static var cornerRadius: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.cornerRadius(v)) }) }
	public static var isDoubleSided: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.isDoubleSided(v)) }) }
	public static var drawsAsynchronously: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.drawsAsynchronously(v)) }) }
	public static var edgeAntialiasingMask: BindingName<Dynamic<CAEdgeAntialiasingMask>, Binding> { return BindingName<Dynamic<CAEdgeAntialiasingMask>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.edgeAntialiasingMask(v)) }) }
	public static var frame: BindingName<Dynamic<CGRect>, Binding> { return BindingName<Dynamic<CGRect>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.frame(v)) }) }
	public static var isGeometryFlipped: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.isGeometryFlipped(v)) }) }
	public static var isHidden: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.isHidden(v)) }) }
	public static var magnificationFilter: BindingName<Dynamic<CALayerContentsFilter>, Binding> { return BindingName<Dynamic<CALayerContentsFilter>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.magnificationFilter(v)) }) }
	public static var masksToBounds: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.masksToBounds(v)) }) }
	public static var minificationFilter: BindingName<Dynamic<CALayerContentsFilter>, Binding> { return BindingName<Dynamic<CALayerContentsFilter>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.minificationFilter(v)) }) }
	public static var minificationFilterBias: BindingName<Dynamic<Float>, Binding> { return BindingName<Dynamic<Float>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.minificationFilterBias(v)) }) }
	public static var name: BindingName<Dynamic<String>, Binding> { return BindingName<Dynamic<String>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.name(v)) }) }
	public static var needsDisplayOnBoundsChange: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.needsDisplayOnBoundsChange(v)) }) }
	public static var opacity: BindingName<Dynamic<Float>, Binding> { return BindingName<Dynamic<Float>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.opacity(v)) }) }
	public static var isOpaque: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.isOpaque(v)) }) }
	public static var position: BindingName<Dynamic<CGPoint>, Binding> { return BindingName<Dynamic<CGPoint>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.position(v)) }) }
	public static var rasterizationScale: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.rasterizationScale(v)) }) }
	public static var shadowColor: BindingName<Dynamic<CGColor?>, Binding> { return BindingName<Dynamic<CGColor?>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.shadowColor(v)) }) }
	public static var shadowOffset: BindingName<Dynamic<CGSize>, Binding> { return BindingName<Dynamic<CGSize>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.shadowOffset(v)) }) }
	public static var shadowOpacity: BindingName<Dynamic<Float>, Binding> { return BindingName<Dynamic<Float>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.shadowOpacity(v)) }) }
	public static var shadowPath: BindingName<Dynamic<CGPath?>, Binding> { return BindingName<Dynamic<CGPath?>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.shadowPath(v)) }) }
	public static var shadowRadius: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.shadowRadius(v)) }) }
	public static var shouldRasterize: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.shouldRasterize(v)) }) }
	public static var style: BindingName<Dynamic<[AnyHashable: Any]>, Binding> { return BindingName<Dynamic<[AnyHashable: Any]>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.style(v)) }) }
	public static var sublayerTransform: BindingName<Dynamic<CATransform3D>, Binding> { return BindingName<Dynamic<CATransform3D>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.sublayerTransform(v)) }) }
	public static var transform: BindingName<Dynamic<CATransform3D>, Binding> { return BindingName<Dynamic<CATransform3D>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.transform(v)) }) }
	public static var zPosition: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.zPosition(v)) }) }
	public static var mask: BindingName<Dynamic<LayerConvertible?>, Binding> { return BindingName<Dynamic<LayerConvertible?>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.mask(v)) }) }
	public static var sublayers: BindingName<Dynamic<[LayerConvertible]>, Binding> { return BindingName<Dynamic<[LayerConvertible]>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.sublayers(v)) }) }
	#if os(macOS)
		public static var autoresizingMask: BindingName<Dynamic<CAAutoresizingMask>, Binding> { return BindingName<Dynamic<CAAutoresizingMask>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.autoresizingMask(v)) }) }
		public static var backgroundFilters: BindingName<Dynamic<[CIFilter]?>, Binding> { return BindingName<Dynamic<[CIFilter]?>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.backgroundFilters(v)) }) }
		public static var compositingFilter: BindingName<Dynamic<CIFilter?>, Binding> { return BindingName<Dynamic<CIFilter?>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.compositingFilter(v)) }) }
		public static var filters: BindingName<Dynamic<[CIFilter]?>, Binding> { return BindingName<Dynamic<[CIFilter]?>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.filters(v)) }) }
	#endif
	public static var addAnimation: BindingName<Signal<AnimationForKey>, Binding> { return BindingName<Signal<AnimationForKey>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.addAnimation(v)) }) }
	public static var needsDisplay: BindingName<Signal<Void>, Binding> { return BindingName<Signal<Void>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.needsDisplay(v)) }) }
	public static var needsDisplayInRect: BindingName<Signal<CGRect>, Binding> { return BindingName<Signal<CGRect>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.needsDisplayInRect(v)) }) }
	public static var removeAllAnimations: BindingName<Signal<String>, Binding> { return BindingName<Signal<String>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.removeAllAnimations(v)) }) }
	public static var removeAnimationForKey: BindingName<Signal<String>, Binding> { return BindingName<Signal<String>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.removeAnimationForKey(v)) }) }
	public static var scrollRectToVisible: BindingName<Signal<CGRect>, Binding> { return BindingName<Signal<CGRect>, Binding>({ v in .backingLayerBinding(BackingLayer.Binding.scrollRectToVisible(v)) }) }
}

public protocol BackingLayerBinding: BaseBinding {
	static func backingLayerBinding(_ binding: BackingLayer.Binding) -> Self
}

extension BackingLayerBinding {
	public static func baseBinding(_ binding: BaseBinder.Binding) -> Self {
		return backingLayerBinding(.inheritedBinding(binding))
	}
}

public struct AnimationForKey {
	public let animation: CAAnimation
	public let key: String?
	
	public init(animation: CAAnimation, forKey: String? = nil) {
		self.animation = animation
		self.key = forKey
	}
	
	public static var fade: AnimationForKey {
		let t = CATransition()
		t.type = CATransitionType.fade
		return AnimationForKey(animation: t)
	}
	
	public enum Direction {
		case left
		case right
		case top
		case bottom
		
		func transition(ofType: CATransitionType) -> AnimationForKey {
			let t = CATransition()
			t.type = ofType
			switch self {
			case .left: t.subtype = CATransitionSubtype.fromLeft
			case .right: t.subtype = CATransitionSubtype.fromRight
			case .top: t.subtype = CATransitionSubtype.fromTop
			case .bottom: t.subtype = CATransitionSubtype.fromBottom
			}
			return AnimationForKey(animation: t)
		}
	}
	
	public static func moveIn(from: Direction) -> AnimationForKey {
		return from.transition(ofType: CATransitionType.moveIn)
	}
	
	public static func push(from: Direction) -> AnimationForKey {
		return from.transition(ofType: CATransitionType.push)
	}
	
	public static func reveal(from: Direction) -> AnimationForKey {
		return from.transition(ofType: CATransitionType.reveal)
	}
}

public class GradientLayer: ConstructingBinder, GradientLayerConvertible {
	public typealias Instance = CAGradientLayer
	public typealias Inherited = Layer
	
	public var state: BinderState<Instance, BinderSubclassParameters<Instance, Binding>>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public func uiGradientLayer() -> Instance { return instance() }

	public enum Binding: GradientLayerBinding {
		public typealias EnclosingBinder = GradientLayer
		public static func gradientLayerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		case colors(Dynamic<[CGColor]>)
		case locations(Dynamic<[CGFloat]>)
		case endPoint(Dynamic<CGPoint>)
		case startPoint(Dynamic<CGPoint>)

		// 2. Signal bindings are performed on the object after construction.

		// 3. Action bindings are triggered by the object after construction.

		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}

	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = GradientLayer
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		public init() {}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .colors(let x): return x.apply(instance, storage) { i, s, v in i.colors = v }
			case .locations(let x): return x.apply(instance, storage) { i, s, v in i.locations = v.map { NSNumber(value: Double($0)) } }
			case .endPoint(let x): return x.apply(instance, storage) { i, s, v in i.endPoint = v }
			case .startPoint(let x): return x.apply(instance, storage) { i, s, v in i.startPoint = v }
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}

	public typealias Storage = Layer.Storage
}

extension BindingName where Binding: GradientLayerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .gradientLayerBinding(GradientLayer.Binding.$1(v)) }) }
	public static var colors: BindingName<Dynamic<[CGColor]>, Binding> { return BindingName<Dynamic<[CGColor]>, Binding>({ v in .gradientLayerBinding(GradientLayer.Binding.colors(v)) }) }
	public static var locations: BindingName<Dynamic<[CGFloat]>, Binding> { return BindingName<Dynamic<[CGFloat]>, Binding>({ v in .gradientLayerBinding(GradientLayer.Binding.locations(v)) }) }
	public static var endPoint: BindingName<Dynamic<CGPoint>, Binding> { return BindingName<Dynamic<CGPoint>, Binding>({ v in .gradientLayerBinding(GradientLayer.Binding.endPoint(v)) }) }
	public static var startPoint: BindingName<Dynamic<CGPoint>, Binding> { return BindingName<Dynamic<CGPoint>, Binding>({ v in .gradientLayerBinding(GradientLayer.Binding.startPoint(v)) }) }
}

public protocol GradientLayerConvertible: LayerConvertible {
	func uiGradientLayer() -> GradientLayer.Instance
}
extension GradientLayerConvertible {
	public var cgLayer: Layer.Instance { return uiGradientLayer() }
}
extension GradientLayer.Instance: GradientLayerConvertible {
	public func uiGradientLayer() -> GradientLayer.Instance { return self }
}

public protocol GradientLayerBinding: LayerBinding {
	static func gradientLayerBinding(_ binding: GradientLayer.Binding) -> Self
}

extension GradientLayerBinding {
	public static func layerBinding(_ binding: Layer.Binding) -> Self {
		return gradientLayerBinding(.inheritedBinding(binding))
	}
}

import WebKit

public class WebView: ConstructingBinder, WebViewConvertible {
	public typealias Instance = WKWebView
	public typealias Inherited = View
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public var wkWebView: Instance { return instance() }
	
	public enum Binding: WebViewBinding {
		public typealias EnclosingBinder = WebView
		public static func webViewBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		//	0. Static bindings are applied at construction and are subsequently immutable.
		case configuration(Constant<WKWebViewConfiguration>)
		#if os(iOS)
			case scrollView(Constant<ScrollView>)
		#else
			@available(*, unavailable)
			case scrollView(())
		#endif
		
		//	1. Value bindings may be applied at construction and may subsequently change.
		@available(macOS 10.11, *)
		case customUserAgent(Dynamic<String?>)
		#if os(macOS)
			case allowsMagnification(Dynamic<Bool>)
			case magnification(Dynamic<(factor: CGFloat, centeredAt: CGPoint)>)
		#else
			@available(*, unavailable)
			case allowsMagnification(())
			@available(*, unavailable)
			case magnification(())
		#endif
		case allowsBackForwardNavigationGestures(Dynamic<Bool>)
		@available(macOS 10.11, *)
		case allowsLinkPreview(Dynamic<Bool>)
		
		//	2. Signal bindings are performed on the object after construction.
		case load(Signal<Callback<URLRequest, WKNavigation?>>)
		@available(macOS 10.11, *)
		case loadFile(Signal<Callback<(url: URL, allowingReadAccessTo: URL), WKNavigation?>>)
		case loadHTMLString(Signal<Callback<(string: String, baseURL: URL?), WKNavigation?>>)
		@available(macOS 10.11, *)
		case loadData(Signal<Callback<(data: Data, mimeType: String, baseURL: URL, characterEncodingName: String), WKNavigation?>>)
		case reload(Signal<Callback<Void, WKNavigation?>>)
		case reloadFromOrigin(Signal<Callback<Void, WKNavigation?>>)
		case goBack(Signal<Callback<Void, WKNavigation?>>)
		case goForward(Signal<Callback<Void, WKNavigation?>>)
		case goTo(Signal<Callback<WKBackForwardListItem, WKNavigation?>>)
		case stopLoading(Signal<Void>)
		case evaluateJavaScript(Signal<Callback<String, (Any?, Error?)>>)
		
		//	3. Action bindings are triggered by the object after construction.
		case didCommit(SignalInput<WKNavigation>)
		case didStartProvisionalNavigation(SignalInput<WKNavigation>)
		case didReceiveServerRedirectForProvisionalNavigation(SignalInput<WKNavigation>)
		case didFail(SignalInput<(WKNavigation, Error)>)
		case didFailProvisionalNavigation(SignalInput<(WKNavigation, Error)>)
		case didFinish(SignalInput<WKNavigation>)
		case contentProcessDidTerminate(SignalInput<Void>)
		case decideActionPolicy(SignalInput<Callback<WKNavigationAction, WKNavigationActionPolicy>>)
		case decideResponsePolicy(SignalInput<Callback<WKNavigationResponse, WKNavigationResponsePolicy>>)
		case didReceiveAuthenticationChallenge(SignalInput<Callback<URLAuthenticationChallenge, (URLSession.AuthChallengeDisposition, URLCredential?)>>)
		case runJavaScriptAlertPanel(SignalInput<Callback<(message: String, frame: WKFrameInfo), ()>>)
		case runJavaScriptConfirmPanel(SignalInput<Callback<(message: String, frame: WKFrameInfo), Bool>>)
		case runJavaScriptTextInputPanel(SignalInput<Callback<(prompt: String, defaultText: String?, frame: WKFrameInfo), String?>>)
		@available(macOS 10.11, iOS 9.0, *)
		case didClose(SignalInput<Void>)
		#if os(macOS)
			@available(macOS 10.12, *)
			case runOpenPanel(SignalInput<(parameters: WKOpenPanelParameters, frame: WKFrameInfo, completion: SignalInput<[URL]?>)>)
		#else
			@available(*, unavailable)
			case runOpenPanel(())
		#endif
		
		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case createWebView((_ webView: WKWebView, _ with: WKWebViewConfiguration, _ for: WKNavigationAction, _ windowFeatures: WKWindowFeatures) -> WKWebView?)
		#if os(iOS)
			@available(iOS 10.0, *)
			case shouldPreviewElement((_ webView: WKWebView, _ elementInfo: WKPreviewElementInfo) -> Bool)
			@available(iOS 10.0, *)
			case previewingViewController((_ webView: WKWebView, _ elementInfo: WKPreviewElementInfo, _ previewActions: [WKPreviewActionItem]) -> UIViewController?)
			@available(iOS 10.0, *)
			case commitPreviewingViewController((_ webView: WKWebView, _ previewingViewController: UIViewController) -> Void)
		#else
			@available(*, unavailable)
			case shouldPreviewElement(())
			@available(*, unavailable)
			case previewingViewController(())
			@available(*, unavailable)
			case commitPreviewingViewController(())
		#endif
	}

	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = WebView
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init(frame: .zero, configuration: configuration ?? WKWebViewConfiguration()) }
		
		public init() {
			self.init(delegateClass: Delegate.self)
		}
		public init<Value>(delegateClass: Value.Type) where Value: Delegate {
			self.delegateClass = delegateClass
		}
		public let delegateClass: Delegate.Type
		var possibleDelegate: Delegate? = nil
		mutating func delegate() -> Delegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		var configuration: WKWebViewConfiguration?
		
		public mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .configuration(let x): configuration = x.value
			case .didCommit(let x):
				let s = #selector(WKNavigationDelegate.webView(_:didCommit:))
				delegate().addSelector(s).didCommit = x
			case .didStartProvisionalNavigation(let x):
				let s = #selector(WKNavigationDelegate.webView(_:didStartProvisionalNavigation:))
				delegate().addSelector(s).didStartProvisionalNavigation = x
			case .didReceiveServerRedirectForProvisionalNavigation(let x):
				let s = #selector(WKNavigationDelegate.webView(_:didReceiveServerRedirectForProvisionalNavigation:))
				delegate().addSelector(s).didReceiveServerRedirectForProvisionalNavigation = x
			case .didFail(let x):
				let s = #selector(WKNavigationDelegate.webView(_:didFail:withError:))
				delegate().addSelector(s).didFail = x
			case .didFailProvisionalNavigation(let x):
				let s = #selector(WKNavigationDelegate.webView(_:didFailProvisionalNavigation:withError:))
				delegate().addSelector(s).didFailProvisionalNavigation = x
			case .didFinish(let x):
				let s = #selector(WKNavigationDelegate.webView(_:didFinish:))
				delegate().addSelector(s).didFinish = x
			case .contentProcessDidTerminate(let x):
				if #available(macOS 10.11, *) {
					let s = #selector(WKNavigationDelegate.webViewWebContentProcessDidTerminate(_:))
					delegate().addSelector(s).contentProcessDidTerminate = x
				}
			case .decideActionPolicy(let x):
				let s = #selector(WKNavigationDelegate.webView(_:decidePolicyFor:decisionHandler:) as ((WKNavigationDelegate) -> (WKWebView,WKNavigationAction, @escaping (WKNavigationActionPolicy) -> Void) -> Void)?)
				delegate().addSelector(s).decideActionPolicy = x
			case .decideResponsePolicy(let x):
				let s = #selector(WKNavigationDelegate.webView(_:decidePolicyFor:decisionHandler:) as ((WKNavigationDelegate) -> (WKWebView, WKNavigationResponse, @escaping (WKNavigationResponsePolicy) -> Void) -> Void)?)
				delegate().addSelector(s).decideResponsePolicy = x
			case .didReceiveAuthenticationChallenge(let x):
				let s = #selector(WKNavigationDelegate.webView(_:didReceive:completionHandler:))
				delegate().addSelector(s).didReceiveAuthenticationChallenge = x
			case .runJavaScriptAlertPanel(let x):
				let s = #selector(WKUIDelegate.webView(_:runJavaScriptAlertPanelWithMessage:initiatedByFrame:completionHandler:))
				delegate().addSelector(s).runJavaScriptAlertPanel = x
			case .runJavaScriptConfirmPanel(let x):
				let s = #selector(WKUIDelegate.webView(_:runJavaScriptConfirmPanelWithMessage:initiatedByFrame:completionHandler:))
				delegate().addSelector(s).runJavaScriptConfirmPanel = x
			case .runJavaScriptTextInputPanel(let x):
				let s = #selector(WKUIDelegate.webView(_:runJavaScriptTextInputPanelWithPrompt:defaultText:initiatedByFrame:completionHandler:))
				delegate().addSelector(s).runJavaScriptTextInputPanel = x
			case .createWebView(let x):
				let s = #selector(WKUIDelegate.webView(_:createWebViewWith:for:windowFeatures:))
				delegate().addSelector(s).createWebView = x
			case .didClose(let x):
				if #available(macOS 10.11, iOS 9.0, *) {
					let s = #selector(WKUIDelegate.webViewDidClose(_:))
					delegate().addSelector(s).didClose = x
				}
			case .runOpenPanel(let x):
				#if os(macOS)
					if #available(macOS 10.12, *) {
						let s = #selector(WKUIDelegate.webView(_:runOpenPanelWith:initiatedByFrame:completionHandler:))
						delegate().addSelector(s).runOpenPanel = x
					}
				#endif
			case .shouldPreviewElement(let x):
				#if os(iOS)
					if #available(iOS 10.0, *) {
						let s = #selector(WKUIDelegate.webView(_:shouldPreviewElement:))
						delegate().addSelector(s).shouldPreviewElement = x
					}
				#endif
			case .previewingViewController(let x):
				#if os(iOS)
					if #available(iOS 10.0, *) {
						let s = #selector(WKUIDelegate.webView(_:previewingViewControllerForElement:defaultActions:))
						delegate().addSelector(s).previewingViewController = x
					}
				#endif
			case .commitPreviewingViewController(let x):
				#if os(iOS)
					if #available(iOS 10.0, *) {
						let s = #selector(WKUIDelegate.webView(_:commitPreviewingViewController:))
						delegate().addSelector(s).commitPreviewingViewController = x
					}
				#endif
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		public mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			if possibleDelegate != nil {
				precondition(instance.navigationDelegate == nil && instance.uiDelegate == nil, "Conflicting delegate applied to instance")
				storage.dynamicDelegate = possibleDelegate
				instance.navigationDelegate = storage
				instance.uiDelegate = storage
			}
			
			linkedPreparer.prepareInstance(instance, storage: storage)
		}

		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .configuration: return nil
			case .scrollView(let x):
				#if os(macOS)
					return nil
				#else
					x.value.applyBindings(to: instance.scrollView)
					return nil
				#endif
			case .customUserAgent(let x):
				return x.apply(instance, storage) { i, s, v in
					if #available(macOS 10.11, *) {
						i.customUserAgent = v
					}
				}
			case .allowsMagnification(let x):
				#if os(macOS)
					return x.apply(instance, storage) { i, s, v in i.allowsMagnification = v }
				#else
					return nil
				#endif
			case .magnification(let x):
				#if os(macOS)
					return x.apply(instance, storage) { i, s, v in i.setMagnification(v.factor, centeredAt: v.centeredAt) }
				#else
					return nil
				#endif
			case .allowsBackForwardNavigationGestures(let x): return x.apply(instance, storage) { i, s, v in i.allowsBackForwardNavigationGestures = v }
			case .allowsLinkPreview(let x):
				return x.apply(instance, storage) { i, s, v in
					if #available(macOS 10.11, *) {
						i.allowsLinkPreview = v
					}
				}
			case .load(let x):
				return x.apply(instance, storage) { i, s, v in
					let n = i.load(v.value)
					v.callback?.send(value: n)
				}
			case .loadFile(let x):
				return x.apply(instance, storage) { i, s, v in
					if #available(macOS 10.11, *) {
						let n = i.loadFileURL(v.value.url, allowingReadAccessTo: v.value.allowingReadAccessTo)
						v.callback?.send(value: n)
					}
				}
			case .loadHTMLString(let x):
				return x.apply(instance, storage) { i, s, v in
					let n = i.loadHTMLString(v.value.string, baseURL: v.value.baseURL)
					v.callback?.send(value: n)
				}
			case .loadData(let x):
				return x.apply(instance, storage) { i, s, v in
					if #available(macOS 10.11, *) {
						let n = i.load(v.value.data, mimeType: v.value.mimeType, characterEncodingName: v.value.characterEncodingName, baseURL: v.value.baseURL)
						v.callback?.send(value: n)
					}
				}
			case .reload(let x):
				return x.apply(instance, storage) { i, s, v in
					let n = i.reload()
					v.callback?.send(value: n)
				}
			case .reloadFromOrigin(let x):
				return x.apply(instance, storage) { i, s, v in
					let n = i.reloadFromOrigin()
					v.callback?.send(value: n)
				}
			case .goBack(let x):
				return x.apply(instance, storage) { i, s, v in
					let n = i.goBack()
					v.callback?.send(value: n)
				}
			case .goForward(let x):
				return x.apply(instance, storage) { i, s, v in
					let n = i.goForward()
					v.callback?.send(value: n)
				}
			case .goTo(let x):
				return x.apply(instance, storage) { i, s, v in
					let n = i.go(to: v.value)
					v.callback?.send(value: n)
				}
			case .stopLoading(let x):
				return x.apply(instance, storage) { i, s, v in i.stopLoading() }
			case .evaluateJavaScript(let x):
				return x.apply(instance, storage) { i, s, v in
					i.evaluateJavaScript(v.value) { (output, error) in
						v.callback?.send(value: (output, error))
					}
				}
				
			case .didCommit: return nil
			case .didStartProvisionalNavigation: return nil
			case .didReceiveServerRedirectForProvisionalNavigation: return nil
			case .didFail: return nil
			case .didFailProvisionalNavigation: return nil
			case .didFinish: return nil
			case .contentProcessDidTerminate: return nil
			case .decideActionPolicy: return nil
			case .decideResponsePolicy: return nil
			case .didReceiveAuthenticationChallenge: return nil
			case .runJavaScriptAlertPanel: return nil
			case .runJavaScriptConfirmPanel: return nil
			case .runJavaScriptTextInputPanel: return nil
			case .didClose: return nil
			case .runOpenPanel: return nil
			case .createWebView: return nil
			case .shouldPreviewElement: return nil
			case .previewingViewController: return nil
			case .commitPreviewingViewController: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}

	open class Storage: View.Storage, WKUIDelegate, WKNavigationDelegate {}

	open class Delegate: DynamicDelegate, WKUIDelegate, WKNavigationDelegate {
		public required override init() {
			super.init()
		}
		
		open var didCommit: SignalInput<WKNavigation>?
		open func webView(_ webView: WKWebView, didCommit navigation: WKNavigation!) {
			didCommit!.send(value: navigation)
		}
		
		open var didStartProvisionalNavigation: SignalInput<WKNavigation>?
		open func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) {
			didStartProvisionalNavigation!.send(value: navigation)
		}
		
		open var didReceiveServerRedirectForProvisionalNavigation: SignalInput<WKNavigation>?
		open func webView(_ webView: WKWebView, didReceiveServerRedirectForProvisionalNavigation navigation: WKNavigation!) {
			didReceiveServerRedirectForProvisionalNavigation!.send(value: navigation)
		}
		
		open var didFail: SignalInput<(WKNavigation, Error)>?
		open func webView(_ webView: WKWebView, didFail navigation: WKNavigation!, withError error: Error) {
			didFail!.send(value: (navigation, error))
		}
		
		open var didFailProvisionalNavigation: SignalInput<(WKNavigation, Error)>?
		open func webView(_ webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation!, withError error: Error) {
			didFailProvisionalNavigation!.send(value: (navigation, error))
		}
		
		open var didFinish: SignalInput<WKNavigation>?
		open func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
			didFinish!.send(value: navigation)
		}
		
		open var contentProcessDidTerminate: SignalInput<Void>?
		open func webViewWebContentProcessDidTerminate(_ webView: WKWebView) {
			contentProcessDidTerminate!.send(value: ())
		}
		
		open var decideActionPolicy: SignalInput<Callback<WKNavigationAction, WKNavigationActionPolicy>>?
		open func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {
			decideActionPolicy!.send(value: Callback(navigationAction, Input().subscribeWhile(context: .main) { r in decisionHandler(r.value ?? .cancel); return false }))
		}
		
		open var decideResponsePolicy: SignalInput<Callback<WKNavigationResponse, WKNavigationResponsePolicy>>?
		open func webView(_ webView: WKWebView, decidePolicyFor navigationResponse: WKNavigationResponse, decisionHandler: @escaping (WKNavigationResponsePolicy) -> Void) {
			decideResponsePolicy!.send(value: Callback(navigationResponse, Input().subscribeWhile(context: .main) { r in decisionHandler(r.value ?? .cancel); return false }))
		}
		
		open var didReceiveAuthenticationChallenge: SignalInput<Callback<URLAuthenticationChallenge, (URLSession.AuthChallengeDisposition, URLCredential?)>>?
		open func webView(_ webView: WKWebView, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
			didReceiveAuthenticationChallenge!.send(value: Callback(challenge, Input().subscribeWhile(context: .main) { r in completionHandler(r.value?.0 ?? .cancelAuthenticationChallenge, r.value?.1); return false }))
		}
		
		open var runJavaScriptAlertPanel: SignalInput<Callback<(message: String, frame: WKFrameInfo), ()>>?
		open func webView(_ webView: WKWebView, runJavaScriptAlertPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping () -> Void) {
			runJavaScriptAlertPanel!.send(value: Callback((message: message, frame: frame), Input().subscribeWhile(context: .main) { r in completionHandler(); return false }))
		}
		
		open var runJavaScriptConfirmPanel: SignalInput<Callback<(message: String, frame: WKFrameInfo), Bool>>?
		open func webView(_ webView: WKWebView, runJavaScriptConfirmPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (Bool) -> Void) {
			runJavaScriptConfirmPanel!.send(value: Callback((message: message, frame: frame), Input().subscribeWhile(context: .main) { r in completionHandler(r.value ?? false); return false }))
		}
		
		open var runJavaScriptTextInputPanel: SignalInput<Callback<(prompt: String, defaultText: String?, frame: WKFrameInfo), String?>>?
		open func webView(_ webView: WKWebView, runJavaScriptTextInputPanelWithPrompt prompt: String, defaultText: String?, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (String?) -> Void) {
			runJavaScriptTextInputPanel!.send(value: Callback((prompt: prompt, defaultText: defaultText, frame: frame), Input().subscribeWhile(context: .main) { r in completionHandler(r.value ?? nil); return false }))
		}
		
		open var createWebView: ((_ webView: WKWebView, _ configuration: WKWebViewConfiguration, _ navigationAction: WKNavigationAction, _ windowFeatures: WKWindowFeatures) -> WKWebView?)?
		open func webView(_ webView: WKWebView, createWebViewWith configuration: WKWebViewConfiguration, for navigationAction: WKNavigationAction, windowFeatures: WKWindowFeatures) -> WKWebView? {
			return createWebView!(webView, configuration, navigationAction, windowFeatures)
		}

		open var didClose: SignalInput<Void>?
		open func webViewDidClose(_ webView: WKWebView) {
			didClose!.send(value: ())
		}

		#if os(iOS)
			open var shouldPreviewElement: Any?
			@available(iOS 10.0, *)
			open func webView(_ webView: WKWebView, shouldPreviewElement elementInfo: WKPreviewElementInfo) -> Bool {
				return (shouldPreviewElement as! (_ webView: WKWebView, _ elementInfo: WKPreviewElementInfo) -> Bool)(webView, elementInfo)
			}
			
			open var commitPreviewingViewController: ((_ webView: WKWebView, _ previewingViewController: UIViewController) -> Void)?
			open func webView(_ webView: WKWebView, commitPreviewingViewController previewingViewController: UIViewController) {
				commitPreviewingViewController!(webView, previewingViewController)
			}
			
			open var previewingViewController: Any?
			@available(iOS 10.0, *)
			open func webView(_ webView: WKWebView, previewingViewControllerForElement elementInfo: WKPreviewElementInfo, defaultActions previewActions: [WKPreviewActionItem]) -> UIViewController? {
				return (previewingViewController as! (_ webView: WKWebView, _ elementInfo: WKPreviewElementInfo, _ previewActions: [WKPreviewActionItem]) -> UIViewController?)(webView, elementInfo, previewActions)
			}
		#else
			open var runOpenPanel: Any?
			@available(macOS 10.12, *)
			open func webView(_ webView: WKWebView, runOpenPanelWith parameters: WKOpenPanelParameters, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping ([URL]?) -> Void) {
				(runOpenPanel as! SignalInput<(parameters: WKOpenPanelParameters, frame: WKFrameInfo, completion: SignalInput<[URL]?>)>).send(value: (parameters: parameters, frame: frame, completion: Input().subscribeWhile(context: .main) { r in completionHandler(r.value ?? nil); return false }))
			}
		#endif
	}
}

extension BindingName where Binding: WebViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .webViewBinding(WebView.Binding.$1(v)) }) }

	public static var configuration: BindingName<Constant<WKWebViewConfiguration>, Binding> { return BindingName<Constant<WKWebViewConfiguration>, Binding>({ v in .webViewBinding(WebView.Binding.configuration(v)) }) }
	
	#if os(iOS)
		public static var scrollView: BindingName<Constant<ScrollView>, Binding> { return BindingName<Constant<ScrollView>, Binding>({ v in .webViewBinding(WebView.Binding.scrollView(v)) }) }
	#endif
	
	//	1. Value bindings may be applied at construction and may subsequently change.
	@available(macOS 10.11, *)
	public static var customUserAgent: BindingName<Dynamic<String?>, Binding> { return BindingName<Dynamic<String?>, Binding>({ v in .webViewBinding(WebView.Binding.customUserAgent(v)) }) }
	
	#if os(macOS)
		public static var allowsMagnification: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .webViewBinding(WebView.Binding.allowsMagnification(v)) }) }
		public static var magnification: BindingName<Dynamic<(factor: CGFloat, centeredAt: CGPoint)>, Binding> { return BindingName<Dynamic<(factor: CGFloat, centeredAt: CGPoint)>, Binding>({ v in .webViewBinding(WebView.Binding.magnification(v)) }) }
	#endif
	
	public static var allowsBackForwardNavigationGestures: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .webViewBinding(WebView.Binding.allowsBackForwardNavigationGestures(v)) }) }
	@available(macOS 10.11, *)
	public static var allowsLinkPreview: BindingName<Dynamic<Bool>, Binding> { return BindingName<Dynamic<Bool>, Binding>({ v in .webViewBinding(WebView.Binding.allowsLinkPreview(v)) }) }
	
	//	2. Signal bindings are performed on the object after construction.
	public static var load: BindingName<Signal<Callback<URLRequest, WKNavigation?>>, Binding> { return BindingName<Signal<Callback<URLRequest, WKNavigation?>>, Binding>({ v in .webViewBinding(WebView.Binding.load(v)) }) }
	@available(macOS 10.11, *)
	public static var loadFile: BindingName<Signal<Callback<(url: URL, allowingReadAccessTo: URL), WKNavigation?>>, Binding> { return BindingName<Signal<Callback<(url: URL, allowingReadAccessTo: URL), WKNavigation?>>, Binding>({ v in .webViewBinding(WebView.Binding.loadFile(v)) }) }
	public static var loadHTMLString: BindingName<Signal<Callback<(string: String, baseURL: URL?), WKNavigation?>>, Binding> { return BindingName<Signal<Callback<(string: String, baseURL: URL?), WKNavigation?>>, Binding>({ v in .webViewBinding(WebView.Binding.loadHTMLString(v)) }) }
	@available(macOS 10.11, *)
	public static var loadData: BindingName<Signal<Callback<(data: Data, mimeType: String, baseURL: URL, characterEncodingName: String), WKNavigation?>>, Binding> { return BindingName<Signal<Callback<(data: Data, mimeType: String, baseURL: URL, characterEncodingName: String), WKNavigation?>>, Binding>({ v in .webViewBinding(WebView.Binding.loadData(v)) }) }
	public static var reload: BindingName<Signal<Callback<Void, WKNavigation?>>, Binding> { return BindingName<Signal<Callback<Void, WKNavigation?>>, Binding>({ v in .webViewBinding(WebView.Binding.reload(v)) }) }
	public static var reloadFromOrigin: BindingName<Signal<Callback<Void, WKNavigation?>>, Binding> { return BindingName<Signal<Callback<Void, WKNavigation?>>, Binding>({ v in .webViewBinding(WebView.Binding.reloadFromOrigin(v)) }) }
	public static var goBack: BindingName<Signal<Callback<Void, WKNavigation?>>, Binding> { return BindingName<Signal<Callback<Void, WKNavigation?>>, Binding>({ v in .webViewBinding(WebView.Binding.goBack(v)) }) }
	public static var goForward: BindingName<Signal<Callback<Void, WKNavigation?>>, Binding> { return BindingName<Signal<Callback<Void, WKNavigation?>>, Binding>({ v in .webViewBinding(WebView.Binding.goForward(v)) }) }
	public static var goTo: BindingName<Signal<Callback<WKBackForwardListItem, WKNavigation?>>, Binding> { return BindingName<Signal<Callback<WKBackForwardListItem, WKNavigation?>>, Binding>({ v in .webViewBinding(WebView.Binding.goTo(v)) }) }
	public static var stopLoading: BindingName<Signal<Void>, Binding> { return BindingName<Signal<Void>, Binding>({ v in .webViewBinding(WebView.Binding.stopLoading(v)) }) }
	public static var evaluateJavaScript: BindingName<Signal<Callback<String, (Any?, Error?)>>, Binding> { return BindingName<Signal<Callback<String, (Any?, Error?)>>, Binding>({ v in .webViewBinding(WebView.Binding.evaluateJavaScript(v)) }) }
	
	//	3. Action bindings are triggered by the object after construction.
	public static var didCommit: BindingName<SignalInput<WKNavigation>, Binding> { return BindingName<SignalInput<WKNavigation>, Binding>({ v in .webViewBinding(WebView.Binding.didCommit(v)) }) }
	public static var didStartProvisionalNavigation: BindingName<SignalInput<WKNavigation>, Binding> { return BindingName<SignalInput<WKNavigation>, Binding>({ v in .webViewBinding(WebView.Binding.didStartProvisionalNavigation(v)) }) }
	public static var didReceiveServerRedirectForProvisionalNavigation: BindingName<SignalInput<WKNavigation>, Binding> { return BindingName<SignalInput<WKNavigation>, Binding>({ v in .webViewBinding(WebView.Binding.didReceiveServerRedirectForProvisionalNavigation(v)) }) }
	public static var didFail: BindingName<SignalInput<(WKNavigation, Error)>, Binding> { return BindingName<SignalInput<(WKNavigation, Error)>, Binding>({ v in .webViewBinding(WebView.Binding.didFail(v)) }) }
	public static var didFailProvisionalNavigation: BindingName<SignalInput<(WKNavigation, Error)>, Binding> { return BindingName<SignalInput<(WKNavigation, Error)>, Binding>({ v in .webViewBinding(WebView.Binding.didFailProvisionalNavigation(v)) }) }
	public static var didFinish: BindingName<SignalInput<WKNavigation>, Binding> { return BindingName<SignalInput<WKNavigation>, Binding>({ v in .webViewBinding(WebView.Binding.didFinish(v)) }) }
	public static var contentProcessDidTerminate: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .webViewBinding(WebView.Binding.contentProcessDidTerminate(v)) }) }
	public static var decideActionPolicy: BindingName<SignalInput<Callback<WKNavigationAction, WKNavigationActionPolicy>>, Binding> { return BindingName<SignalInput<Callback<WKNavigationAction, WKNavigationActionPolicy>>, Binding>({ v in .webViewBinding(WebView.Binding.decideActionPolicy(v)) }) }
	public static var decideResponsePolicy: BindingName<SignalInput<Callback<WKNavigationResponse, WKNavigationResponsePolicy>>, Binding> { return BindingName<SignalInput<Callback<WKNavigationResponse, WKNavigationResponsePolicy>>, Binding>({ v in .webViewBinding(WebView.Binding.decideResponsePolicy(v)) }) }
	public static var didReceiveAuthenticationChallenge: BindingName<SignalInput<Callback<URLAuthenticationChallenge, (URLSession.AuthChallengeDisposition, URLCredential?)>>, Binding> { return BindingName<SignalInput<Callback<URLAuthenticationChallenge, (URLSession.AuthChallengeDisposition, URLCredential?)>>, Binding>({ v in .webViewBinding(WebView.Binding.didReceiveAuthenticationChallenge(v)) }) }
	public static var runJavaScriptAlertPanel: BindingName<SignalInput<Callback<(message: String, frame: WKFrameInfo), ()>>, Binding> { return BindingName<SignalInput<Callback<(message: String, frame: WKFrameInfo), ()>>, Binding>({ v in .webViewBinding(WebView.Binding.runJavaScriptAlertPanel(v)) }) }
	public static var runJavaScriptConfirmPanel: BindingName<SignalInput<Callback<(message: String, frame: WKFrameInfo), Bool>>, Binding> { return BindingName<SignalInput<Callback<(message: String, frame: WKFrameInfo), Bool>>, Binding>({ v in .webViewBinding(WebView.Binding.runJavaScriptConfirmPanel(v)) }) }
	public static var runJavaScriptTextInputPanel: BindingName<SignalInput<Callback<(prompt: String, defaultText: String?, frame: WKFrameInfo), String?>>, Binding> { return BindingName<SignalInput<Callback<(prompt: String, defaultText: String?, frame: WKFrameInfo), String?>>, Binding>({ v in .webViewBinding(WebView.Binding.runJavaScriptTextInputPanel(v)) }) }
	@available(macOS 10.11, iOS 9.0, *)
	public static var didClose: BindingName<SignalInput<Void>, Binding> { return BindingName<SignalInput<Void>, Binding>({ v in .webViewBinding(WebView.Binding.didClose(v)) }) }
	
	#if os(macOS)
		@available(macOS 10.12, *)
		public static var runOpenPanel: BindingName<SignalInput<(parameters: WKOpenPanelParameters, frame: WKFrameInfo, completion: SignalInput<[URL]?>)>, Binding> { return BindingName<SignalInput<(parameters: WKOpenPanelParameters, frame: WKFrameInfo, completion: SignalInput<[URL]?>)>, Binding>({ v in .webViewBinding(WebView.Binding.runOpenPanel(v)) }) }
	#endif
	
	//	4. Delegate bindings require synchronous evaluation within the object's context.
	public static var createWebView: BindingName<(_ webView: WKWebView, _ with: WKWebViewConfiguration, _ for: WKNavigationAction, _ windowFeatures: WKWindowFeatures) -> WKWebView?, Binding> { return BindingName<(_ webView: WKWebView, _ with: WKWebViewConfiguration, _ for: WKNavigationAction, _ windowFeatures: WKWindowFeatures) -> WKWebView?, Binding>({ v in .webViewBinding(WebView.Binding.createWebView(v)) }) }
	
	#if os(iOS)
		@available(iOS 10.0, *)
		public static var shouldPreviewElement: BindingName<(_ webView: WKWebView, _ elementInfo: WKPreviewElementInfo) -> Bool, Binding> { return BindingName<(_ webView: WKWebView, _ elementInfo: WKPreviewElementInfo) -> Bool, Binding>({ v in .webViewBinding(WebView.Binding.shouldPreviewElement(v)) }) }
		@available(iOS 10.0, *)
		public static var previewingViewController: BindingName<(_ webView: WKWebView, _ elementInfo: WKPreviewElementInfo, _ previewActions: [WKPreviewActionItem]) -> UIViewController?, Binding> { return BindingName<(_ webView: WKWebView, _ elementInfo: WKPreviewElementInfo, _ previewActions: [WKPreviewActionItem]) -> UIViewController?, Binding>({ v in .webViewBinding(WebView.Binding.previewingViewController(v)) }) }
		@available(iOS 10.0, *)
		public static var commitPreviewingViewController: BindingName<(_ webView: WKWebView, _ previewingViewController: UIViewController) -> Void, Binding> { return BindingName<(_ webView: WKWebView, _ previewingViewController: UIViewController) -> Void, Binding>({ v in .webViewBinding(WebView.Binding.commitPreviewingViewController(v)) }) }
	#endif
}

public protocol WebViewConvertible: ViewConvertible {
	var wkWebView: WebView.Instance { get }
}
extension WebViewConvertible {
	#if os(macOS)
		public func nsView() -> View.Instance { return wkWebView }
	#else
		public func uiView() -> View.Instance { return wkWebView }
	#endif
}
extension WKWebView: WebViewConvertible {
	public var wkWebView: WebView.Instance { return self }
}

public protocol WebViewBinding: ViewBinding {
	static func webViewBinding(_ binding: WebView.Binding) -> Self
}
extension WebViewBinding {
	public static func viewBinding(_ binding: View.Binding) -> Self {
		return webViewBinding(.inheritedBinding(binding))
	}
}

public class StackView: ConstructingBinder, StackViewConvertible {
#if os(macOS)
	public typealias NSUIView = NSView
	public typealias NSUIStackView = NSStackView
	public typealias NSUIStackViewDistribution = NSStackView.Gravity
	public typealias NSUIStackViewAlignment = NSLayoutConstraint.Attribute
	public typealias NSUIUserInterfaceLayoutOrientation = NSUserInterfaceLayoutOrientation
	public typealias NSUILayoutPriority = NSLayoutConstraint.Priority
#else
	public typealias NSUIView = UIView
	public typealias NSUIStackView = UIStackView
	public typealias NSUIStackViewDistribution = UIStackView.Distribution
	public typealias NSUIStackViewAlignment = UIStackView.Alignment
	public typealias NSUIUserInterfaceLayoutOrientation = NSLayoutConstraint.Axis
	public typealias NSUILayoutPriority = UILayoutPriority
#endif

	public typealias Instance = NSUIStackView
	public typealias Inherited = View
	
	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}

	#if os(macOS)
		public func nsStackView() -> Instance { return instance() }
	#else
		public func uiStackView() -> Instance { return instance() }
	#endif
	
	public enum Binding: StackViewBinding {
		public typealias EnclosingBinder = StackView
		public static func stackViewBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)
		
		// 1. Value bindings may be applied at construction and may subsequently change.
		case alignment(Dynamic<NSUIStackViewAlignment>)
		case spacing(Dynamic<CGFloat>)
		case distribution(Dynamic<NSUIStackViewDistribution>)
		case axis(Dynamic<NSUIUserInterfaceLayoutOrientation>)
		case views(Dynamic<[ViewConvertible]>)
		#if os(macOS)
			case horizontalClippingResistance(Dynamic<NSUILayoutPriority>)
			case verticalClippingResistance(Dynamic<NSUILayoutPriority>)
			case horizontalHuggingPriority(Dynamic<NSUILayoutPriority>)
			case verticalHuggingPriority(Dynamic<NSUILayoutPriority>)
			case edgeInsets(Dynamic<NSEdgeInsets>)
			@available(*, unavailable)
			case isLayoutMarginsRelativeArrangement(())
		#else
			case isLayoutMarginsRelativeArrangement(Dynamic<Bool>)
			@available(*, unavailable)
			case edgeInsets(())
			@available(*, unavailable)
			case horizontalClippingResistance(Dynamic<NSUILayoutPriority>)
			@available(*, unavailable)
			case verticalClippingResistance(Dynamic<NSUILayoutPriority>)
			@available(*, unavailable)
			case horizontalHuggingPriority(Dynamic<NSUILayoutPriority>)
			@available(*, unavailable)
			case verticalHuggingPriority(Dynamic<NSUILayoutPriority>)
		#endif
		
		// 2. Signal bindings are performed on the object after construction.
		
		// 3. Action bindings are triggered by the object after construction.
		
		// 4. Delegate bindings require synchronous evaluation within the object's context.
	}

	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = StackView
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		public init() {}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .alignment(let x): return x.apply(instance, storage) { i, s, v in i.alignment = v }
			case .spacing(let x): return x.apply(instance, storage) { i, s, v in i.spacing = v }
			case .distribution(let x):
				return x.apply(instance, storage) { i, s, v in
					#if os(macOS)
						s.gravity = v
						if #available(macOS 10.11, *) {
							i.setViews(i.arrangedSubviews, in: s.gravity)
						} else {
							i.setViews(i.subviews, in: s.gravity)
						}
					#else
						i.distribution = v
					#endif
				}
			case .axis(let x):
				return x.apply(instance, storage) { i, s, v in
					#if os(macOS)
						i.orientation = v
					#else
						i.axis = v
					#endif
				}
			case .horizontalClippingResistance(let x):
				#if os(macOS)
					return x.apply(instance, storage) { i, s, v in i.setClippingResistancePriority(v, for: .horizontal) }
				#else
					return nil
				#endif
			case .verticalClippingResistance(let x):
				#if os(macOS)
					return x.apply(instance, storage) { i, s, v in i.setClippingResistancePriority(v, for: .vertical) }
				#else
					return nil
				#endif
			case .horizontalHuggingPriority(let x):
				#if os(macOS)
					return x.apply(instance, storage) { i, s, v in i.setHuggingPriority(v, for: .horizontal) }
				#else
					return nil
				#endif
			case .verticalHuggingPriority(let x):
				#if os(macOS)
					return x.apply(instance, storage) { i, s, v in i.setHuggingPriority(v, for: .vertical) }
				#else
					return nil
				#endif
			case .views(let x):
				return x.apply(instance, storage) { i, s, v in
					#if os(macOS)
						i.setViews(v.map { $0.nsView() }, in: s.gravity)
					#else
						for view in i.arrangedSubviews {
							view.removeFromSuperview()
						}
						for view in v {
							i.addArrangedSubview(view.uiView())
						}
					#endif
				}
			case .edgeInsets(let x):
				#if os(macOS)
					return x.apply(instance, storage) { i, s, v in i.edgeInsets = v }
				#else
					return nil
				#endif
			case .isLayoutMarginsRelativeArrangement(let x):
				#if os(macOS)
					return nil
				#else
					return x.apply(instance, storage) { i, s, v in i.isLayoutMarginsRelativeArrangement = v }
				#endif
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}

	#if os(macOS)
		open class Storage: View.Storage {
			open var gravity: NSStackView.Gravity = .center
		}
	#else
		public typealias Storage = View.Storage
	#endif
}

extension BindingName where Binding: StackViewBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .stackViewBinding(StackView.Binding.$1(v)) }) }
	public static var alignment: BindingName<Dynamic<StackView.NSUIStackViewAlignment>, Binding> { return BindingName<Dynamic<StackView.NSUIStackViewAlignment>, Binding>({ v in .stackViewBinding(StackView.Binding.alignment(v)) }) }
	public static var spacing: BindingName<Dynamic<CGFloat>, Binding> { return BindingName<Dynamic<CGFloat>, Binding>({ v in .stackViewBinding(StackView.Binding.spacing(v)) }) }
	public static var distribution: BindingName<Dynamic<StackView.NSUIStackViewDistribution>, Binding> { return BindingName<Dynamic<StackView.NSUIStackViewDistribution>, Binding>({ v in .stackViewBinding(StackView.Binding.distribution(v)) }) }
	public static var axis: BindingName<Dynamic<StackView.NSUIUserInterfaceLayoutOrientation>, Binding> { return BindingName<Dynamic<StackView.NSUIUserInterfaceLayoutOrientation>, Binding>({ v in .stackViewBinding(StackView.Binding.axis(v)) }) }
	public static var views: BindingName<Dynamic<[ViewConvertible]>, Binding> { return BindingName<Dynamic<[ViewConvertible]>, Binding>({ v in .stackViewBinding(StackView.Binding.views(v)) }) }
	#if os(macOS)
		public static var horizontalClippingResistance: BindingName<Dynamic<StackView.NSUILayoutPriority>, Binding> { return BindingName<Dynamic<StackView.NSUILayoutPriority>, Binding>({ v in .stackViewBinding(StackView.Binding.horizontalClippingResistance(v)) }) }
		public static var verticalClippingResistance: BindingName<Dynamic<StackView.NSUILayoutPriority>, Binding> { return BindingName<Dynamic<StackView.NSUILayoutPriority>, Binding>({ v in .stackViewBinding(StackView.Binding.verticalClippingResistance(v)) }) }
		public static var horizontalHuggingPriority: BindingName<Dynamic<StackView.NSUILayoutPriority>, Binding> { return BindingName<Dynamic<StackView.NSUILayoutPriority>, Binding>({ v in .stackViewBinding(StackView.Binding.horizontalHuggingPriority(v)) }) }
		public static var verticalHuggingPriority: BindingName<Dynamic<StackView.NSUILayoutPriority>, Binding> { return BindingName<Dynamic<StackView.NSUILayoutPriority>, Binding>({ v in .stackViewBinding(StackView.Binding.verticalHuggingPriority(v)) }) }
		public static var edgeInsets: BindingName<Dynamic<NSEdgeInsets>, Binding> { return BindingName<Dynamic<NSEdgeInsets>, Binding>({ v in .stackViewBinding(StackView.Binding.edgeInsets(v)) }) }
		@available(*, unavailable)
		public static var isLayoutMarginsRelativeArrangement: BindingName<(), Binding> { return BindingName<(), Binding>({ v in .baseBinding(.lifetimes(.constant([]))) }) }
	#endif
}

#if os(macOS)
	public protocol StackViewConvertible: ViewConvertible {
		func nsStackView() -> StackView.Instance
	}
	extension StackViewConvertible {
		public func nsView() -> View.Instance { return nsStackView() }
	}
	extension StackView.Instance: StackViewConvertible {
		public func nsStackView() -> StackView.Instance { return self }
	}
#else
	public protocol StackViewConvertible: ViewConvertible {
		func uiStackView() -> StackView.Instance
	}
	extension StackViewConvertible {
		public func uiView() -> View.Instance { return uiStackView() }
	}
	extension StackView.Instance: StackViewConvertible {
		public func uiStackView() -> StackView.Instance { return self }
	}
#endif

public protocol StackViewBinding: ViewBinding {
	static func stackViewBinding(_ binding: StackView.Binding) -> Self
}

extension StackViewBinding {
	public static func viewBinding(_ binding: View.Binding) -> Self {
		return stackViewBinding(.inheritedBinding(binding))
	}
}

public class Layer: ConstructingBinder, LayerConvertible {
	public typealias Instance = CALayer
	public typealias Inherited = BackingLayer

	public var state: ConstructingBinderState<Instance, Binding>
	public required init(state: ConstructingBinderState<Instance, Binding>) {
		self.state = state
	}
	public static func bindingToInherited(_ binding: Binding) -> Inherited.Binding? {
		if case .inheritedBinding(let s) = binding { return s } else { return nil }
	}
	public var cgLayer: Instance { return instance() }
	
	public enum Binding: LayerBinding {
		public typealias EnclosingBinder = Layer
		public static func layerBinding(_ binding: Binding) -> Binding { return binding }
		case inheritedBinding(Inherited.Binding)

		//	1. Value bindings may be applied at construction and may subsequently change.
		#if os(macOS)
			case constraints(Dynamic<[CAConstraint]>)
		#else
			@available(*, unavailable)
			case constraints(())
		#endif

		//	2. Signal bindings are performed on the object after construction.

		//	3. Action bindings are triggered by the object after construction.

		//	4. Delegate bindings require synchronous evaluation within the object's context.
		case display((CALayer) -> Void)
		case draw((CALayer, CGContext) -> Void)
	}

	public struct Preparer: ConstructingPreparer {
		public typealias EnclosingBinder = Layer
		public var linkedPreparer = Inherited.Preparer()
		
		public func constructStorage() -> EnclosingBinder.Storage { return Storage() }
		public func constructInstance(subclass: EnclosingBinder.Instance.Type) -> EnclosingBinder.Instance { return subclass.init() }
		
		public init() {
			self.init(delegateClass: InternalDelegate.self)
		}
		public init<Value>(delegateClass: Value.Type) where Value: InternalDelegate {
			self.delegateClass = delegateClass
		}
		public let delegateClass: InternalDelegate.Type
		var possibleDelegate: InternalDelegate? = nil
		mutating func delegate() -> InternalDelegate {
			if let d = possibleDelegate {
				return d
			} else {
				let d = delegateClass.init()
				possibleDelegate = d
				return d
			}
		}
		
		public mutating func prepareBinding(_ binding: Binding) {
			switch binding {
			case .display(let x):
				let s = #selector(CALayerDelegate.display(_:))
				delegate().addSelector(s).display = x
			case .draw(let x):
				let s = #selector(CALayerDelegate.draw(_:in:))
				delegate().addSelector(s).drawLayer = x
			case .inheritedBinding(let x): linkedPreparer.prepareBinding(x)
			default: break
			}
		}
		
		public mutating func prepareInstance(_ instance: Instance, storage: Storage) {
			// Don't steal the delegate from the view if already set
			if possibleDelegate != nil {
				precondition(instance.delegate == nil, "Conflicting delegate applied to instance")
				storage.dynamicDelegate = possibleDelegate
				instance.delegate = storage
			}
			
			linkedPreparer.prepareInstance(instance, storage: storage)
		}
		
		public func applyBinding(_ binding: Binding, instance: Instance, storage: Storage) -> Lifetime? {
			switch binding {
			case .constraints(let x):
				#if os(macOS)
					return x.apply(instance, storage) { i, s, v in i.constraints = v }
				#else
					return nil
				#endif
			case .display: return nil
			case .draw: return nil
			case .inheritedBinding(let s): return linkedPreparer.applyBinding(s, instance: instance, storage: storage)
			}
		}
	}

	open class Storage: BackingLayer.Storage, CALayerDelegate {}

	open class InternalDelegate: DynamicDelegate, CALayerDelegate {
		public required override init() {
			super.init()
		}
		
		open var display: ((CALayer) -> Void)?
		open func display(_ layer: CALayer) {
			return display!(layer)
		}
		
		open var drawLayer: ((CALayer, CGContext) -> Void)?
		@objc(drawLayer:inContext:) open func draw(_ layer: CALayer, in ctx: CGContext) {
			return drawLayer!(layer, ctx)
		}
		
		open var layoutSublayers: ((CALayer) -> Void)?
		open func layoutSublayers(of layer: CALayer) {
			return layoutSublayers!(layer)
		}
		
		open var action: ((CALayer, String) -> CAAction?)?
		open func action(for layer: CALayer, forKey event: String) -> CAAction? {
			return action!(layer, event)
		}
	}
}

extension BindingName where Binding: LayerBinding {
	// You can easily convert the `Binding` cases to `BindingName` using the following Xcode-style regex:
	// Replace: case ([^\(]+)\((.+)\)$
	// With:    public static var $1: BindingName<$2, Binding> { return BindingName<$2, Binding>({ v in .layerBinding(Layer.Binding.$1(v)) }) }
	#if os(macOS)
		public static var constraints: BindingName<Dynamic<[CAConstraint]>, Binding> { return BindingName<Dynamic<[CAConstraint]>, Binding>({ v in .layerBinding(Layer.Binding.constraints(v)) }) }
	#endif
	public static var display: BindingName<(CALayer) -> Void, Binding> { return BindingName<(CALayer) -> Void, Binding>({ v in .layerBinding(Layer.Binding.display(v)) }) }
	public static var draw: BindingName<(CALayer, CGContext) -> Void, Binding> { return BindingName<(CALayer, CGContext) -> Void, Binding>({ v in .layerBinding(Layer.Binding.draw(v)) }) }
}

public protocol LayerConvertible {
	var cgLayer: Layer.Instance { get }
}
extension Layer.Instance: LayerConvertible {
	public var cgLayer: Layer.Instance { return self }
}

public protocol LayerBinding: BackingLayerBinding {
	static func layerBinding(_ binding: Layer.Binding) -> Self
}

extension LayerBinding {
	public static func backingLayerBinding(_ binding: BackingLayer.Binding) -> Self {
		return layerBinding(.inheritedBinding(binding))
	}
}
